<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="图形绘制概述Android框架提供了两种绘制图形的方式:Canvas和OpenGL.   android.graphics.Canvas是一个2D图形API, 并且是在开发者中最流行的图形API. Canvas运算会在Android中绘制所有原生和自定义android.view.View. 在Android中，Canvas API通过一个名为OpenGLRender的绘制库实现硬件加速，该绘制库将">
<meta property="og:type" content="article">
<meta property="og:title" content="Android图形系统分析">
<meta property="og:url" content="http://yoursite.com/2017/11/06/Android-graphic-system/index.html">
<meta property="og:site_name" content="AllenWang的个人博客">
<meta property="og:description" content="图形绘制概述Android框架提供了两种绘制图形的方式:Canvas和OpenGL.   android.graphics.Canvas是一个2D图形API, 并且是在开发者中最流行的图形API. Canvas运算会在Android中绘制所有原生和自定义android.view.View. 在Android中，Canvas API通过一个名为OpenGLRender的绘制库实现硬件加速，该绘制库将">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/gui/ape_fwk_graphics.png">
<meta property="og:image" content="http://yoursite.com/images/gui/android_gui.png">
<meta property="og:image" content="http://yoursite.com/images/gui/app_bind_wms.png">
<meta property="og:image" content="http://yoursite.com/images/gui/buffer_queue.png">
<meta property="og:updated_time" content="2017-11-06T04:21:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android图形系统分析">
<meta name="twitter:description" content="图形绘制概述Android框架提供了两种绘制图形的方式:Canvas和OpenGL.   android.graphics.Canvas是一个2D图形API, 并且是在开发者中最流行的图形API. Canvas运算会在Android中绘制所有原生和自定义android.view.View. 在Android中，Canvas API通过一个名为OpenGLRender的绘制库实现硬件加速，该绘制库将">
<meta name="twitter:image" content="http://yoursite.com/images/gui/ape_fwk_graphics.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/06/Android-graphic-system/"/>





  <title>Android图形系统分析 | AllenWang的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AllenWang的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小楼一夜听春雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/Android-graphic-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AllenWang的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android图形系统分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T12:03:41+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="图形绘制概述"><a href="#图形绘制概述" class="headerlink" title="图形绘制概述"></a>图形绘制概述</h3><p>Android框架提供了两种绘制图形的方式:Canvas和OpenGL.  </p>
<p>android.graphics.Canvas是一个2D图形API, 并且是在开发者中最流行的图形API. Canvas运算会在Android中绘制所有原生和自定义android.view.View. 在Android中，Canvas API通过一个名为OpenGLRender的绘制库实现硬件加速，该绘制库将Canvas运算转换为OpenGL运算，以便它们可以在GPU上执行。</p>
<p>从Android 4.0开始，硬件加速的Canvas默认情况下处于启用状态。因此，支持OpenGL ES 2.0的硬件GPU对于Android 4.0及更高版本的设备来说是强制要求。</p>
<p>除了Canvas,开发者渲染图形的另一个主要方式是使用OpenGL ES直接渲染到Surface. Android在Android.opengl包中提供了OpenGL ES接口，开发者可以使用这些接口通过SDK或Android NDK中提供的原生API调用其GL实现。</p>
<h3 id="Android图形组件"><a href="#Android图形组件" class="headerlink" title="Android图形组件"></a>Android图形组件</h3><p>无论开发者使用什么渲染API,一切内容都会渲染到”Surface”. Surface表示缓冲队列中的生产方，而缓冲队列通常会被SurfaceFlinger消耗。在Android平台上创建的每个窗口都由Surface提供支持。所有被渲染的可见Surface都被SurfaceFlinger合成到显示部分。</p>
<p>下图显示了关键组件是如何协作的:</p>
<img src="/images/gui/ape_fwk_graphics.png">
<p>所以，在App进程与WMS的通信过程中，我们会重点关注Surface的创建过程。</p>
<h3 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h3><ul>
<li>就像我们画画需要画板一样，App绘制图形也需要，在Android中这个画板就是”Surface”,App进程中每个窗口在Java层和C++层各有一个Surface</li>
<li>Linux中有一个FrameBuffer(帧缓冲区),系统会定时地从其中取出数据并显示</li>
<li>Android中的Activity或Dialog并不能直接向FrameBuffer中写入数据，而是需要先写入到GraphicBuffer(图形缓冲区),然后进入到BufferQueue中</li>
<li>BufferQueue采用了生产者-消费者的模型，其中生产者为BufferQueueProducer，通过调用dequeueBuffer()获取一个空闲的缓冲区，并填入要绘制的图形数据，接着调用queueBuffer()将Buffer重新返回给BufferQueue</li>
<li>BufferQueue中的消费者为BufferQueueConsumer,通过调用acquireBuffer()从BufferQueue中拿到一个被填满的缓冲区并消费</li>
</ul>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>这是App进程与SurfaceFlinger进程的关系</p>
<img src="/images/gui/android_gui.png">
<p>这是App进程,WMS与SurfaceFlinger的关系</p>
<img src="/images/gui/app_bind_wms.png">
<p>WMS负责控制所有App进程中窗口的显示，只有经过AMS与WMS的控制，在适当的时机，App才有向SurfaceFlinger中写入数据的机会。</p>
<p>图形缓冲区采用的是生产者-消费者模式:</p>
<img src="/images/gui/buffer_queue.png">
<p>流程如下:<br>1)App端与WMS建立连接，WMS与SurfaceFlinger建立连接，在这个过程中会创建大量的对象，为绘图做好准备<br>2)App端请求SurfaceFlinger进程的BufferQueue分配图形缓冲区;<br>3)BufferQueue通过Gralloc在匿名共享内存分配到空间，并将文件描述符fd通过GraphicBuffer传给App进程;<br>4)App进程通过fd将缓冲区映射到自己的内存空间中，并将首地址传递给图形库;<br>5)图形库从首地址开始绘制;<br>6)App端绘制完成后将缓冲区交还给BufferQueue;<br>7)queueBuffer()时，Layer通知SurfaceFlinger刷新</p>
<h3 id="显示前的准备工作"><a href="#显示前的准备工作" class="headerlink" title="显示前的准备工作"></a>显示前的准备工作</h3><h4 id="从Activity到ViewRootImpl"><a href="#从Activity到ViewRootImpl" class="headerlink" title="从Activity到ViewRootImpl"></a>从Activity到ViewRootImpl</h4><p>一个Activity创建好之后，它的显示过程是从ActivityThread中handleResumeActivity()开始的，该方法的主要代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</div><div class="line">       </div><div class="line">        <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></div><div class="line">        ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Activity a = r.activity;</div><div class="line">            ...</div><div class="line">            <span class="comment">// If the window hasn't yet been added to the window manager,</span></div><div class="line">            <span class="comment">// and this guy didn't finish itself or start another activity,</span></div><div class="line">            <span class="comment">// then go ahead and add the window.</span></div><div class="line">            <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</div><div class="line">            <span class="keyword">if</span> (!willBeVisible) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(</div><div class="line">                            a.getActivityToken());</div><div class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">                r.window = r.activity.getWindow();</div><div class="line">                View decor = r.window.getDecorView();</div><div class="line">                decor.setVisibility(View.INVISIBLE);</div><div class="line">                ViewManager wm = a.getWindowManager();</div><div class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">                a.mDecor = decor;</div><div class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line">                l.softInputMode |= forwardBit;</div><div class="line">                <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</div><div class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</div><div class="line">                    wm.addView(decor, l);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            <span class="comment">// If the window has already been added, but during resume</span></div><div class="line">            <span class="comment">// we started another activity, then don't yet make the</span></div><div class="line">            <span class="comment">// window visible.</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!willBeVisible)&#123;</div><div class="line">                r.hideForNow=<span class="keyword">true</span>;</div><div class="line">            &#125; </div><div class="line">            ...</div><div class="line"></div><div class="line">            <span class="comment">// Get rid of anything left hanging around.</span></div><div class="line">            cleanUpPendingRemoveWindows(r);</div><div class="line"></div><div class="line">            <span class="comment">// The window is now visible if it has been added, we are not</span></div><div class="line">            <span class="comment">// simply finishing, and we are not starting another activity.</span></div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class="line">                    &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</div><div class="line">                <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</div><div class="line">                    r.tmpConfig.setTo(r.newConfig);</div><div class="line">                    <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</div><div class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</div><div class="line">                    &#125;</div><div class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</div><div class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</div><div class="line">                    r.newConfig = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">                <span class="keyword">if</span> ((l.softInputMode</div><div class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</div><div class="line">                        != forwardBit) &#123;</div><div class="line">                    l.softInputMode = (l.softInputMode</div><div class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</div><div class="line">                            | forwardBit;</div><div class="line">                    <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class="line">                        ViewManager wm = a.getWindowManager();</div><div class="line">                        View decor = r.window.getDecorView();</div><div class="line">                        wm.updateViewLayout(decor, l);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                r.activity.mVisibleFromServer = <span class="keyword">true</span>;</div><div class="line">                mNumVisibleActivities++;</div><div class="line">                <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</div><div class="line">                    r.activity.makeVisible();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">            <span class="comment">// Tell the activity manager we have resumed.</span></div><div class="line">            <span class="keyword">if</span> (reallyResume) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</div><div class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法比较简单，主要就是分两种情况：第一种是当前Activity的Window还未添加到WindowManager,那么就需要调用wm.addView(decor,l);将窗体添加到WindowManager进行管理。当然，如果在resume的过程中我们启动了另外一个Activity,那么当前Activity会暂时隐藏。</p>
<p>第二种情况则是窗体已经添加到WM中，那么此时其实就是重新显示出来即可，这个过程中还会涉及到configuration的改变等。</p>
<p>由于这里我们关注一个Activity被创建后是如何显示出来的，所以这里关注第一种情况即可。</p>
<p>该方法中wm其实是WindowManagerImpl对象，故进入WindowManagerImpl.addView()中分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</div><div class="line">        applyDefaultToken(params);</div><div class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法很简单，就是调用了WindowManagerGlobal的addView()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></div><div class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</div><div class="line">        ...</div><div class="line">        ViewRootImpl root;</div><div class="line">        View panelParentView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            ...     </div><div class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">            view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">            mViews.add(view);</div><div class="line">            mRoots.add(root);</div><div class="line">            mParams.add(wparams);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            root.setView(view, wparams, panelParentView);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意到在这个方法中创建了ViewRootImpl对象，并且在最后调用它的setView()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</div><div class="line">              mView = view;</div><div class="line">              ...</div><div class="line">              <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></div><div class="line"></div><div class="line">              <span class="comment">// Schedule the first layout -before- adding to the window</span></div><div class="line">              <span class="comment">// manager, to make sure we do the relayout before receiving</span></div><div class="line">              <span class="comment">// any other events from the system.</span></div><div class="line">              requestLayout();</div><div class="line">              <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</div><div class="line">                      &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</div><div class="line">                  mInputChannel = <span class="keyword">new</span> InputChannel();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  mOrigWindowType = mWindowAttributes.type;</div><div class="line">                  mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</div><div class="line">                  collectViewAttributes();</div><div class="line">                  res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">                          getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">                          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</div><div class="line">                          mAttachInfo.mOutsets, mInputChannel);</div><div class="line">              &#125;</div><div class="line">             ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意其中的mWindowSession.addToDisplay()这个调用，这里通过Binder通信，最终进入Session.addToDisplay()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></div><div class="line"><span class="function"><span class="params">            Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</div><div class="line">                outContentInsets, outStableInsets, outOutsets, outInputChannel);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，它只是调用WindowManagerService的addWindow()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></div><div class="line"><span class="function"><span class="params">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></div><div class="line"><span class="function"><span class="params">           Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></div><div class="line"><span class="function"><span class="params">           InputChannel outInputChannel)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</div><div class="line">       <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</div><div class="line">       ...</div><div class="line">       WindowState attachedWindow = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">long</span> origId;</div><div class="line">           ...</div><div class="line">           <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</div><div class="line">           WindowToken token = mTokenMap.get(attrs.token);</div><div class="line">           ...</div><div class="line"></div><div class="line">           WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</div><div class="line">                   attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</div><div class="line">           ...</div><div class="line">           win.attach();</div><div class="line">           mWindowMap.put(client.asBinder(), win);</div><div class="line">           </div><div class="line">        ...</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> res;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>注意到在这里创建了WindowState对象，并且调用其attach()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</div><div class="line">            TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken</div><div class="line">            + <span class="string">", list="</span> + mToken.windows);</div><div class="line">        mSession.windowAddedLocked();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>非常简单，就是调用Session的windowAddedLocked()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</div><div class="line">            mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</div><div class="line">            mService.mSessions.add(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</div><div class="line">                mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mNumWindow++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意在这里创建了SurfaceSession对象，这个构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Create a new connection with the surface flinger. */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</div><div class="line">       mNativeClient = nativeCreate();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个注释说得很清楚，就是建立与SurfaceFlinger的连接,那究竟是如何建立连接的呢?继续往下看便知。</p>
<p>nativeCreate()是个jni调用，其定义在android_view_SurfaceSession.cpp文件中:,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</div><div class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</div><div class="line">    client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(client);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这里创建了SurfaceComposerClient对象，其构造方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SurfaceComposerClient::SurfaceComposerClient()</div><div class="line">    : mStatus(NO_INIT), mComposer(Composer::getInstance())</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其初始化列表中对Compoer对象mComposer进行了赋值。</p>
<p>但是还是没看到建立连接的地方呀？难道注释写错了？</p>
<h4 id="SurfaceComposerClient"><a href="#SurfaceComposerClient" class="headerlink" title="SurfaceComposerClient"></a>SurfaceComposerClient</h4><p>注意看SurfaceComposerClient的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceComposerClient</span> :</span> <span class="keyword">public</span> RefBase</div><div class="line">&#123;</div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Composer</span>;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">                SurfaceComposerClient();</div><div class="line">    <span class="keyword">virtual</span>     ~SurfaceComposerClient();</div><div class="line"></div><div class="line">    <span class="comment">// Always make sure we could initialize</span></div><div class="line">    <span class="keyword">status_t</span>    initCheck() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Return the connection of this client</span></div><div class="line">    sp&lt;IBinder&gt; connection() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Forcibly remove connection before all references have gone away.</span></div><div class="line">    <span class="function"><span class="keyword">void</span>        <span class="title">dispose</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// callback when the composer is dies</span></div><div class="line">    <span class="keyword">status_t</span> linkToComposerDeath(<span class="keyword">const</span> sp&lt;IBinder::DeathRecipient&gt;&amp; recipient,</div><div class="line">            <span class="keyword">void</span>* cookie = <span class="literal">NULL</span>, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Get a list of supported configurations for a given display</span></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">getDisplayConfigs</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display,</span></span></div><div class="line"><span class="function"><span class="params">            Vector&lt;DisplayInfo&gt;* configs)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Get the DisplayInfo for the currently-active configuration</span></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">getDisplayInfo</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display,</span></span></div><div class="line"><span class="function"><span class="params">            DisplayInfo* info)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Get the index of the current active configuration (relative to the list</span></div><div class="line">    <span class="comment">// returned by getDisplayInfo)</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getActiveConfig</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Set a new active configuration using an index relative to the list</span></div><div class="line">    <span class="comment">// returned by getDisplayInfo</span></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">setActiveConfig</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display, <span class="keyword">int</span> id)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Triggers screen on/off or low power mode and waits for it to complete */</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplayPowerMode</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// surface creation / destruction</span></div><div class="line"></div><div class="line">    <span class="comment">//! Create a surface</span></div><div class="line">    sp&lt;SurfaceControl&gt; createSurface(</div><div class="line">            <span class="keyword">const</span> String8&amp; name,<span class="comment">// name of the surface</span></div><div class="line">            <span class="keyword">uint32_t</span> w,         <span class="comment">// width in pixel</span></div><div class="line">            <span class="keyword">uint32_t</span> h,         <span class="comment">// height in pixel</span></div><div class="line">            PixelFormat format, <span class="comment">// pixel-format desired</span></div><div class="line">            <span class="keyword">uint32_t</span> flags = <span class="number">0</span>  <span class="comment">// usage flags</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//! Create a virtual display</span></div><div class="line">    <span class="keyword">static</span> sp&lt;IBinder&gt; createDisplay(<span class="keyword">const</span> String8&amp; displayName, <span class="keyword">bool</span> secure);</div><div class="line"></div><div class="line">    <span class="comment">//! Destroy a virtual display</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyDisplay</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; display)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//! Get the token for the existing default displays.</span></div><div class="line">    <span class="comment">//! Possible values for id are eDisplayIdMain and eDisplayIdHdmi.</span></div><div class="line">    <span class="keyword">static</span> sp&lt;IBinder&gt; getBuiltInDisplay(<span class="keyword">int32_t</span> id);</div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------------------------</span></div><div class="line">    <span class="comment">// Composer parameters</span></div><div class="line">    <span class="comment">// All composer parameters must be changed within a transaction</span></div><div class="line">    <span class="comment">// several surfaces can be updated in one transaction, all changes are</span></div><div class="line">    <span class="comment">// committed at once when the transaction is closed.</span></div><div class="line">    <span class="comment">// closeGlobalTransaction() requires an IPC with the server.</span></div><div class="line"></div><div class="line">    <span class="comment">//! Open a composer transaction on all active SurfaceComposerClients.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openGlobalTransaction</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//! Close a composer transaction on all active SurfaceComposerClients.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeGlobalTransaction</span><span class="params">(<span class="keyword">bool</span> synchronous = <span class="literal">false</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//! Flag the currently open transaction as an animation transaction.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAnimationTransaction</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">status_t</span>    hide(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id);</div><div class="line">    <span class="keyword">status_t</span>    show(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id);</div><div class="line">    <span class="keyword">status_t</span>    setFlags(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> flags, <span class="keyword">uint32_t</span> mask);</div><div class="line">    <span class="keyword">status_t</span>    setTransparentRegionHint(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">const</span> Region&amp; transparent);</div><div class="line">    <span class="keyword">status_t</span>    setLayer(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> layer);</div><div class="line">    <span class="keyword">status_t</span>    setAlpha(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">float</span> alpha=<span class="number">1.0f</span>);</div><div class="line">    <span class="keyword">status_t</span>    setMatrix(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">float</span> dsdx, <span class="keyword">float</span> dtdx, <span class="keyword">float</span> dsdy, <span class="keyword">float</span> dtdy);</div><div class="line">    <span class="keyword">status_t</span>    setPosition(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">float</span> x, <span class="keyword">float</span> y);</div><div class="line">    <span class="keyword">status_t</span>    setSize(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h);</div><div class="line">    <span class="keyword">status_t</span>    setCrop(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">const</span> Rect&amp; crop);</div><div class="line">    <span class="keyword">status_t</span>    setLayerStack(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> layerStack);</div><div class="line">    <span class="keyword">status_t</span>    destroySurface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id);</div><div class="line"></div><div class="line">    <span class="keyword">status_t</span> clearLayerFrameStats(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">status_t</span> getLayerFrameStats(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token, FrameStats* outStats) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">clearAnimationFrameStats</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">getAnimationFrameStats</span><span class="params">(FrameStats* outStats)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplaySurface</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplayLayerStack</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span> layerStack)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplaySize</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token, <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* setDisplayProjection() defines the projection of layer stacks</span></div><div class="line"><span class="comment">     * to a given display.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * - orientation defines the display's orientation.</span></div><div class="line"><span class="comment">     * - layerStackRect defines which area of the window manager coordinate</span></div><div class="line"><span class="comment">     * space will be used.</span></div><div class="line"><span class="comment">     * - displayRect defines where on the display will layerStackRect be</span></div><div class="line"><span class="comment">     * mapped to. displayRect is specified post-orientation, that is</span></div><div class="line"><span class="comment">     * it uses the orientation seen by the end-user.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplayProjection</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; token,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span> orientation,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">const</span> Rect&amp; layerStackRect,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">const</span> Rect&amp; displayRect)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFirstRef</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Composer&amp; <span class="title">getComposer</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span>     Mutex                       mLock;</div><div class="line">                <span class="keyword">status_t</span>                    mStatus;</div><div class="line">                sp&lt;ISurfaceComposerClient&gt;  mClient;</div><div class="line">                Composer&amp;                   mComposer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>它是继承自RefBase的，从而在它首次被强引用的时候，就调用onFirstRef()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</div><div class="line">    sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</div><div class="line">    <span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</div><div class="line">        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</div><div class="line">        <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</div><div class="line">            mClient = conn;</div><div class="line">            mStatus = NO_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，通过调用ComposerService::getComposerService()获取到ISurfaceComposer对象:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</div><div class="line">    ComposerService&amp; instance = ComposerService::getInstance();</div><div class="line">    Mutex::Autolock _l(instance.mLock);</div><div class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</div><div class="line">        ComposerService::getInstance().connectLocked();</div><div class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</div><div class="line">        ALOGD(<span class="string">"ComposerService reconnected"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance.mComposerService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，会在ComposerSerivce::connectLocked()方法中建立连接，并且给mComposerService赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ComposerService::connectLocked() &#123;</div><div class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">"SurfaceFlinger"</span>)</span></span>;</div><div class="line">    <span class="keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</div><div class="line">        usleep(<span class="number">250000</span>);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意其中的getService()方法是来自IServiceManager.cpp中，其目的是根据服务名称(“SurfaceFlinger”)找到对应的服务并且返回其在C++层的代理，这是属于Binder通信的内容，不熟悉的小伙伴可以自己查看相应的内容。</p>
<p>经过getService(name,&amp;mComposerService)之后，mComposerSerivce就持有了SurfaceFlinger在system_server进程中的代理，其实此时mComposerService是一个BpSurfaceComposer对象（ps.从这里可以看出这个mComposerService的命名其实相当不规范，应该取名叫mBpSurfaceComposer才恰当)。</p>
<p>再回到SurfaceComposerClient::onFirstRef()中，可知此时sm-&gt;createConnection()其实就是调用BpSurfaceComposer::createConnection()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">virtual</span> sp&lt;ISurfaceComposerClient&gt; createConnection()</div><div class="line">    &#123;</div><div class="line">        Parcel data, reply;</div><div class="line">        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</div><div class="line">        remote()-&gt;transact(BnSurfaceComposer::CREATE_CONNECTION, data, &amp;reply);</div><div class="line">        <span class="keyword">return</span> interface_cast&lt;ISurfaceComposerClient&gt;(reply.readStrongBinder());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是典型的C++层Binder通信，最终会调用到SurfaceFlinger::createConnection()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</div><div class="line">&#123;</div><div class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</div><div class="line">    sp&lt;Client&gt; client(<span class="keyword">new</span> Client(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">status_t</span> err = client-&gt;initCheck();</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">        bclient = client;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bclient;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里创建了一个Client对象并赋值给client,Client是SurfaceFlinger的一个帮手。</p>
<p><strong>再回到SurfaceComposerClient::onFirstRef()方法中，可知conn其实就是一个SurfaceFlinger中Client对象在WMS中的一个代理，即BpSurfaceComposerClient对象(相对地，Client继承自BnSurfaceComposerClient)。mark这个，在后面会用到它。</strong></p>
<h3 id="绘图过程"><a href="#绘图过程" class="headerlink" title="绘图过程"></a>绘图过程</h3><p>虽然前面已经创建了很多对象，但是实际上还没有完全做好准备，有些对象是直到真正开始绘制时才创建。首先从SurfaceControl开始。</p>
<h4 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h4><p>有很多种情况可以触发重绘，一个典型的过程是Choreographer.doFrame()—&gt;Choreographer.doCallbacks()—&gt;TraversalRunnable.run()—&gt;ViewRootImpl.doTraversal()—&gt;ViewRootImpl.performTraversals()—&gt;ViewRootImpl.relayoutWindow(),这个方法非常重要，因为在这里面会创建SurfaceControl对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></div><div class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line"></div><div class="line">       ...</div><div class="line">       <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</div><div class="line">               mWindow, mSeq, params,</div><div class="line">               (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</div><div class="line">               (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</div><div class="line">               viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</div><div class="line">               mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</div><div class="line">               mPendingStableInsets, mPendingOutsets, mPendingConfiguration, mSurface);</div><div class="line">       <span class="comment">//Log.d(TAG, "&lt;&lt;&lt;&lt;&lt;&lt; BACK FROM relayout");</span></div><div class="line">       <span class="keyword">if</span> (restore) &#123;</div><div class="line">           params.restore();</div><div class="line">       &#125;</div><div class="line">       ...</div><div class="line">       <span class="keyword">return</span> relayoutResult;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在这个方法中进行了Binder调用，最终会调用Session.relayout()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></div><div class="line"><span class="function"><span class="params">            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Configuration</span></span></div><div class="line"><span class="function"><span class="params">                    outConfig,</span></span></div><div class="line"><span class="function"><span class="params">            Surface outSurface)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</div><div class="line">                requestedWidth, requestedHeight, viewFlags, flags,</div><div class="line">                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</div><div class="line">                outStableInsets, outsets, outConfig, outSurface);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，这里就是直接调用WMS的relayoutWindow()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></div><div class="line"><span class="function"><span class="params">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></div><div class="line"><span class="function"><span class="params">           <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></div><div class="line"><span class="function"><span class="params">           Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></div><div class="line"><span class="function"><span class="params">           Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Configuration outConfig,</span></span></div><div class="line"><span class="function"><span class="params">           Surface outSurface)</span> </span>&#123;</div><div class="line">       ... </div><div class="line">       <span class="keyword">synchronized</span>(mWindowMap) &#123;</div><div class="line">           WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</div><div class="line">           <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">           &#125;</div><div class="line">           WindowStateAnimator winAnimator = win.mWinAnimator;</div><div class="line">           ...</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="keyword">if</span> (!win.mHasSurface) &#123;</div><div class="line">                       surfaceChanged = <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">                   SurfaceControl surfaceControl = winAnimator.createSurfaceLocked();</div><div class="line">                   <span class="keyword">if</span> (surfaceControl != <span class="keyword">null</span>) &#123;</div><div class="line">                       outSurface.copyFrom(surfaceControl);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// For some reason there isn't a surface.  Clear the</span></div><div class="line">                       <span class="comment">// caller's object so they see the same state.</span></div><div class="line">                       outSurface.release();</div><div class="line">                   &#125;</div><div class="line">               &#125; </div><div class="line">               ...</div><div class="line">           &#125; </div><div class="line">        ...</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在这里通过调用WindowStateAnimator的createSurfaceLocked()方法创建SurfaceControl对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="function">SurfaceControl <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> WindowState w = mWin;</div><div class="line">    <span class="keyword">if</span> (mSurfaceControl == <span class="keyword">null</span>) &#123;</div><div class="line">        mDrawState = DRAW_PENDING;</div><div class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (w.mAppToken.mAppAnimator.animation == <span class="keyword">null</span>) &#123;</div><div class="line">                w.mAppToken.allDrawn = <span class="keyword">false</span>;</div><div class="line">                w.mAppToken.deferClearAllDrawn = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Currently animating, persist current state of allDrawn until animation</span></div><div class="line">                <span class="comment">// is complete.</span></div><div class="line">                w.mAppToken.deferClearAllDrawn = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mService.makeWindowFreezingScreenIfNeededLocked(w);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> flags = SurfaceControl.HIDDEN;</div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams attrs = w.mAttrs;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mService.isSecureLocked(w)) &#123;</div><div class="line">            flags |= SurfaceControl.SECURE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> width;</div><div class="line">        <span class="keyword">int</span> height;</div><div class="line">        <span class="keyword">if</span> ((attrs.flags &amp; LayoutParams.FLAG_SCALED) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// for a scaled surface, we always want the requested</span></div><div class="line">            <span class="comment">// size.</span></div><div class="line">            width = w.mRequestedWidth;</div><div class="line">            height = w.mRequestedHeight;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            width = w.mCompatFrame.width();</div><div class="line">            height = w.mCompatFrame.height();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Something is wrong and SurfaceFlinger will not like this,</span></div><div class="line">        <span class="comment">// try to revert to sane values</span></div><div class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">0</span>) &#123;</div><div class="line">            width = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (height &lt;= <span class="number">0</span>) &#123;</div><div class="line">            height = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> left = w.mFrame.left + w.mXOffset;</div><div class="line">        <span class="keyword">float</span> top = w.mFrame.top + w.mYOffset;</div><div class="line"></div><div class="line">        <span class="comment">// Adjust for surface insets.</span></div><div class="line">        width += attrs.surfaceInsets.left + attrs.surfaceInsets.right;</div><div class="line">        height += attrs.surfaceInsets.top + attrs.surfaceInsets.bottom;</div><div class="line">        left -= attrs.surfaceInsets.left;</div><div class="line">        top -= attrs.surfaceInsets.top;</div><div class="line"></div><div class="line">        <span class="comment">// We may abort, so initialize to defaults.</span></div><div class="line">        mSurfaceShown = <span class="keyword">false</span>;</div><div class="line">        mSurfaceLayer = <span class="number">0</span>;</div><div class="line">        mSurfaceAlpha = <span class="number">0</span>;</div><div class="line">        mSurfaceX = <span class="number">0</span>;</div><div class="line">        mSurfaceY = <span class="number">0</span>;</div><div class="line">        w.mLastSystemDecorRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        mHasClipRect = <span class="keyword">false</span>;</div><div class="line">        mClipRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        mLastClipRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Set up surface control with initial size.</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mSurfaceW = width;</div><div class="line">            mSurfaceH = height;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isHwAccelerated = (attrs.flags &amp;</div><div class="line">                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> format = isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;</div><div class="line">            <span class="keyword">if</span> (!PixelFormat.formatHasAlpha(attrs.format)</div><div class="line">                    &amp;&amp; attrs.surfaceInsets.left == <span class="number">0</span></div><div class="line">                    &amp;&amp; attrs.surfaceInsets.top == <span class="number">0</span></div><div class="line">                    &amp;&amp; attrs.surfaceInsets.right == <span class="number">0</span></div><div class="line">                    &amp;&amp; attrs.surfaceInsets.bottom  == <span class="number">0</span>) &#123;</div><div class="line">                flags |= SurfaceControl.OPAQUE;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mSurfaceFormat = format;</div><div class="line">            <span class="keyword">if</span> (DEBUG_SURFACE_TRACE) &#123;</div><div class="line">                mSurfaceControl = <span class="keyword">new</span> SurfaceTrace(</div><div class="line">                        mSession.mSurfaceSession,</div><div class="line">                        attrs.getTitle().toString(),</div><div class="line">                        width, height, format, flags);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</div><div class="line">                    mSession.mSurfaceSession,</div><div class="line">                    attrs.getTitle().toString(),</div><div class="line">                    width, height, format, flags);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            w.mHasSurface = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// Start a new transaction and apply position &amp; offset.</span></div><div class="line">        SurfaceControl.openTransaction();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mSurfaceX = left;</div><div class="line">            mSurfaceY = top;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mSurfaceControl.setPosition(left, top);</div><div class="line">                mSurfaceLayer = mAnimLayer;</div><div class="line">                <span class="keyword">final</span> DisplayContent displayContent = w.getDisplayContent();</div><div class="line">                <span class="keyword">if</span> (displayContent != <span class="keyword">null</span>) &#123;</div><div class="line">                    mSurfaceControl.setLayerStack(displayContent.getDisplay().getLayerStack());</div><div class="line">                &#125;</div><div class="line">                mSurfaceControl.setLayer(mAnimLayer);</div><div class="line">                mSurfaceControl.setAlpha(<span class="number">0</span>);</div><div class="line">                mSurfaceShown = <span class="keyword">false</span>;</div><div class="line">            &#125; </div><div class="line">            ...</div><div class="line">        &#125; </div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mSurfaceControl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，在这里调用SurfaceControl的构造方法创建了一个SurfaceControl对象，并且开启事务模式进行相关属性的设置。SurfaceControl的构造方法中做了很多的事情:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></div><div class="line"><span class="function"><span class="params">            String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></div><div class="line"><span class="function">                    <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</div><div class="line">        ...</div><div class="line">        mName = name;</div><div class="line">        mNativeObject = nativeCreate(session, name, w, h, format, flags);</div><div class="line">        ...</div><div class="line">        mCloseGuard.open(<span class="string">"release"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>跟上面类似，这里也有一个nativeCreate()的jni调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></div><div class="line"><span class="function"><span class="params">        jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</div><div class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</div><div class="line">    sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</div><div class="line">    sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</div><div class="line">            String8(name.c_str()), w, h, format, flags);</div><div class="line">    <span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</div><div class="line">        jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中android_view_SurfaceSession_getClient()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">android_view_SurfaceSession_getClient</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">        JNIEnv* env, jobject surfaceSessionObj)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> reinterpret_cast&lt;SurfaceComposerClient*&gt;(</div><div class="line">            env-&gt;GetLongField(surfaceSessionObj, gSurfaceSessionClassInfo.mNativeClient));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这里是将jobject这个句柄重新转换为SurfaceComposerClient指针，而这个指针指向的就是前面创建的SurfaceComposerClient对象。</p>
<p>再回到nativeCreate()方法中，显然它是调用SurfaceComposerClient::createSurface()方法创建一个C++层的SurfaceControl对象:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</div><div class="line">        <span class="keyword">const</span> String8&amp; name,</div><div class="line">        <span class="keyword">uint32_t</span> w,</div><div class="line">        <span class="keyword">uint32_t</span> h,</div><div class="line">        PixelFormat format,</div><div class="line">        <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    sp&lt;SurfaceControl&gt; sur;</div><div class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</div><div class="line">        sp&lt;IBinder&gt; handle;</div><div class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</div><div class="line">        <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</div><div class="line">                &amp;handle, &amp;gbp);</div><div class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</div><div class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">            sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sur;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的重点其实不在新建SurfaceControl对象，而在于创建这个对象之前的准备工作，<strong>其中mClient在前面说过，它其实是一个BpSurfaceComposerClient对象，所以mClient-&gt;createSurface()最终会调用到SurfaceFlinger进程中Client对象的createSurface()方法</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> Client::createSurface(</div><div class="line">        <span class="keyword">const</span> String8&amp; name,</div><div class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</div><div class="line">        sp&lt;IBinder&gt;* handle,</div><div class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</div><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></div><div class="line"><span class="comment">     * have access to the GL context.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</div><div class="line">        SurfaceFlinger* flinger;</div><div class="line">        Client* client;</div><div class="line">        sp&lt;IBinder&gt;* handle;</div><div class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</div><div class="line">        <span class="keyword">status_t</span> result;</div><div class="line">        <span class="keyword">const</span> String8&amp; name;</div><div class="line">        <span class="keyword">uint32_t</span> w, h;</div><div class="line">        PixelFormat format;</div><div class="line">        <span class="keyword">uint32_t</span> flags;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</div><div class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</div><div class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</div><div class="line">                sp&lt;IBinder&gt;* handle,</div><div class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</div><div class="line">            : flinger(flinger), client(client),</div><div class="line">              handle(handle), gbp(gbp),</div><div class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</div><div class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</div><div class="line">                    handle, gbp);</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</div><div class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</div><div class="line">    mFlinger-&gt;postMessageSync(msg);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里调用了SurfaceFlinger的postMessageSync()方法，通知它去进行处理，最终会调用到MessageCreateLayer的handler()方法,从而调用SurfaceFlinger::createLayer()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> SurfaceFlinger::createLayer(</div><div class="line">        <span class="keyword">const</span> String8&amp; name,</div><div class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</div><div class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    sp&lt;Layer&gt; layer;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</div><div class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</div><div class="line">            result = createNormalLayer(client,</div><div class="line">                    name, w, h, flags, format,</div><div class="line">                    handle, gbp, &amp;layer);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</div><div class="line">            result = createDimLayer(client,</div><div class="line">                    name, w, h, flags,</div><div class="line">                    handle, gbp, &amp;layer);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = BAD_VALUE;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    result = addClientLayer(client, *handle, *gbp, layer);</div><div class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setTransactionFlags(eTransactionNeeded);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会走到第一个分支，即调用createNormalLayer()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</div><div class="line">        <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</div><div class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// initialize the surfaces</span></div><div class="line">    <span class="keyword">switch</span> (format) &#123;</div><div class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</div><div class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</div><div class="line">        format = PIXEL_FORMAT_RGBA_8888;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</div><div class="line">        format = PIXEL_FORMAT_RGBX_8888;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</div><div class="line">    <span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">        *handle = (*outLayer)-&gt;getHandle();</div><div class="line">        *gbp = (*outLayer)-&gt;getProducer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ALOGE_IF(err, <span class="string">"createNormalLayer() failed (%s)"</span>, strerror(-err));</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里新建了Layer对象，以及给gbp赋值，其中gbp是IGraphicBufferProducer类型指针，而Layer::getProducer()方法很简单:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sp&lt;IGraphicBufferProducer&gt; Layer::getProducer() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> mProducer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这个类的创建在onFirstRef()中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</div><div class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></div><div class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</div><div class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</div><div class="line">    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</div><div class="line">    mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</div><div class="line">    mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName);</div><div class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</div><div class="line">    mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</div><div class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</div><div class="line"></div><div class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</div><div class="line">#warning "disabling triple buffering"</div><div class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">2</span>);</div><div class="line">#else</div><div class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">3</span>);</div><div class="line">#endif</div><div class="line"></div><div class="line">    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</div><div class="line">    updateTransformHint(hw);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在这个方法中，通过调用BufferQueue::createBufferQueue()创建了IGraphicBufferProducer对象和IGraphicBufferConsumer对象，它们分别是图形缓存的生产者和消费者。</strong></p>
<p>下面就详细分析一下createBufferQueue()这个方法，注意最后一个参数allocator的默认值为NULL:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,</div><div class="line">        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</div><div class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(outProducer == <span class="literal">NULL</span>,</div><div class="line">            <span class="string">"BufferQueue: outProducer must not be NULL"</span>);</div><div class="line">    LOG_ALWAYS_FATAL_IF(outConsumer == <span class="literal">NULL</span>,</div><div class="line">            <span class="string">"BufferQueue: outConsumer must not be NULL"</span>);</div><div class="line"></div><div class="line">    sp&lt;BufferQueueCore&gt; core(<span class="keyword">new</span> BufferQueueCore(allocator));</div><div class="line">    LOG_ALWAYS_FATAL_IF(core == <span class="literal">NULL</span>,</div><div class="line">            <span class="string">"BufferQueue: failed to create BufferQueueCore"</span>);</div><div class="line"></div><div class="line">    sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</div><div class="line">    LOG_ALWAYS_FATAL_IF(producer == <span class="literal">NULL</span>,</div><div class="line">            <span class="string">"BufferQueue: failed to create BufferQueueProducer"</span>);</div><div class="line"></div><div class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</div><div class="line">    LOG_ALWAYS_FATAL_IF(consumer == <span class="literal">NULL</span>,</div><div class="line">            <span class="string">"BufferQueue: failed to create BufferQueueConsumer"</span>);</div><div class="line"></div><div class="line">    *outProducer = producer;</div><div class="line">    *outConsumer = consumer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，这个方法其实就做了三件事:</p>
<ul>
<li>创建了一个BufferQueueCore对象</li>
<li>借助刚刚创建的BufferQueueCore对象，创建一个BufferQueueProduer对象</li>
<li>类似地，创建一个BufferQueueConsumer对象</li>
</ul>
<h4 id="BpSurfaceComposerClient-createSurface-方法"><a href="#BpSurfaceComposerClient-createSurface-方法" class="headerlink" title="BpSurfaceComposerClient::createSurface()方法"></a>BpSurfaceComposerClient::createSurface()方法</h4><p>再回到SurfaceComposerClient::createSurface()方法中，前面已经分析了mClient-&gt;createSurface()的跨进程调用过程，但是没有讲在跨进程之前，在WMS中是如何调用的。</p>
<p>由于mClient其实只是surface-flinger进程中Client对象在WMS中的代理，即BpSurfaceComposerClient对象，所以mClient-&gt;createSurface()首先是执行BpSurfaceComposerClient::createSurface()方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></div><div class="line"><span class="function"><span class="params">           <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></div><div class="line"><span class="function"><span class="params">           sp&lt;IBinder&gt;* handle,</span></span></div><div class="line"><span class="function"><span class="params">           sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</div><div class="line">       Parcel data, reply;</div><div class="line">       data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor());</div><div class="line">       data.writeString8(name);</div><div class="line">       data.writeUint32(width);</div><div class="line">       data.writeUint32(height);</div><div class="line">       data.writeInt32(<span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(format));</div><div class="line">       data.writeUint32(flags);</div><div class="line">       remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</div><div class="line">       *handle = reply.readStrongBinder();</div><div class="line">       *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</div><div class="line">       <span class="keyword">return</span> reply.readInt32();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>可见gbp成了surface-flinger进程中BufferQueueProducer在WMS中的一个代理，即BpGraphicBufferProducer对象，后面可通过gdp进行跨进程调用到suface-flinger进程中的BufferQueueProducer对象。</strong></p>
<h4 id="C-层Surface对象的创建"><a href="#C-层Surface对象的创建" class="headerlink" title="C++层Surface对象的创建"></a>C++层Surface对象的创建</h4><p>再回到WMS.relayoutWindow()方法，在执行完SurfaceControl surfaceControl=winAnimator.createSurfaceLocked();之后会执行outSurface.copyFrom(surfaceControl);方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">long</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</div><div class="line">                nativeRelease(mNativeObject);</div><div class="line">            &#125;</div><div class="line">            setNativeObjectLocked(newNativeObject);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法的作用是让当前Surface指向另一个Surface所持有的数据，这里有jni调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></div><div class="line"><span class="function"><span class="params">        jlong surfaceControlNativeObj)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This is used by the WindowManagerService just after constructing</span></div><div class="line"><span class="comment">     * a Surface and is necessary for returning the Surface reference to</span></div><div class="line"><span class="comment">     * the caller. At this point, we should only have a SurfaceControl.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</div><div class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</div><div class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</div><div class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法很简单，就是先将Java层的句柄转换为C++层的SurfaceControl对象(之前创建的SurfaceControl对象是以long型保存在Java层的SurfaceControl对象中),之后调用SurfaceControl::getSurface()方法获得C++层的Surface对象，并且将句柄保存在Java层的Surface对象中。其中getSurface()方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    Mutex::Autolock _l(mLock);</div><div class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></div><div class="line">        <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></div><div class="line">        mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mSurfaceData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这里如果mSurfaceData为空的话，则会创建Surface对象。至此，C++层的Surface对象就创建好了。</p>
<h4 id="准备工作总结"><a href="#准备工作总结" class="headerlink" title="准备工作总结"></a>准备工作总结</h4><p>到这里为止，可以总结一下准备工作了，主要流程如下:</p>
<ul>
<li>从ActivityThread中handleResumeActivity()开始，调用到ViewRootImpl.setView()方法，最终通过Binder通信调用到WMS.addWindow()方法，从而在WMS中创建SurfaceSession对象，而这个Java层的SurfaceSession对象其实只是C++层SurfaceComposerClient对象的一个封装</li>
<li>在创建SurfaceComposerClient对象的过程中，还建立了WMS与SurfaceFlinger的连接,并且在SurfaceFlinger进程中创建了Client对象, Client与SurfaceComposerClient是Binder通信的对端，它们分别在system_server和surface_flinger进程中</li>
<li>接收到绘制信号后，触发重绘流程，即horeographer.doFrame()—&gt;Choreographer.doCallbacks()—&gt;TraversalRunnable.run()—&gt;ViewRootImpl.doTraversal()—&gt;ViewRootImpl.performTraversals()—&gt;ViewRootImpl.relayoutWindow()</li>
<li>ViewRootImpl.relayoutWindow()中，最终会通过Binder通信调用到WMS的relayoutWindow()方法，在该方法中创建了Java层的SurfaceControl对象</li>
<li>在创建Java层的SurfaceControl对象过程中，会通过jni调用在C++层创建一个SurfaceControl对象，并且通过Binder通信让Client对象创建一个Layer对象</li>
<li>在WMS.relayoutWindow()方法中，创建好SurfaceControl对象之后，会调用outSurface.copyFrom(surfaceControl);创建Surface对象，并且将句柄保存在Java层的SurfaceControl对象中</li>
</ul>
<h4 id="开始进入绘制流程"><a href="#开始进入绘制流程" class="headerlink" title="开始进入绘制流程"></a>开始进入绘制流程</h4><p>做完了上面这些准备，建立了App与WMS的连接，以及WMS与SurfaceFlinger的连接，并且准备好了Surface对象，下面就可以开始绘图了。前面说过，触发重绘最终会走到ViewRootImpl.draw()方法中，该方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</div><div class="line">        Surface surface = mSurface;</div><div class="line">        <span class="keyword">if</span> (!surface.isValid()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ... </div><div class="line">        <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</div><div class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</div><div class="line">                <span class="comment">// If accessibility focus moved, always invalidate the root.</span></div><div class="line">                <span class="keyword">boolean</span> invalidateRoot = accessibilityFocusDirty;</div><div class="line"></div><div class="line">                <span class="comment">// Draw with hardware renderer.</span></div><div class="line">                mIsAnimating = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</div><div class="line">                    mHardwareYOffset = yOffset;</div><div class="line">                    mHardwareXOffset = xOffset;</div><div class="line">                    invalidateRoot = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                mResizeAlpha = resizeAlpha;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (invalidateRoot) &#123;</div><div class="line">                    mAttachInfo.mHardwareRenderer.invalidateRoot();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dirty.setEmpty();</div><div class="line"></div><div class="line">                mBlockResizeBuffer = <span class="keyword">false</span>;</div><div class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// If we get here with a disabled &amp; requested hardware renderer, something went</span></div><div class="line">                <span class="comment">// wrong (an invalidate posted right before we destroyed the hardware surface</span></div><div class="line">                <span class="comment">// for instance) so we should just bail out. Locking the surface with software</span></div><div class="line">                <span class="comment">// rendering at this point would lock it forever and prevent hardware renderer</span></div><div class="line">                <span class="comment">// from doing its job when it comes back.</span></div><div class="line">                <span class="comment">// Before we request a new frame we must however attempt to reinitiliaze the</span></div><div class="line">                <span class="comment">// hardware renderer if it's in requested state. This would happen after an</span></div><div class="line">                <span class="comment">// eglTerminate() for instance.</span></div><div class="line">                <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                        !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp;</div><div class="line">                        mAttachInfo.mHardwareRenderer.isRequested()) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        mAttachInfo.mHardwareRenderer.initializeIfNeeded(</div><div class="line">                                mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);</div><div class="line">                    &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</div><div class="line">                        handleOutOfResourcesException(e);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    mFullRedrawNeeded = <span class="keyword">true</span>;</div><div class="line">                    scheduleTraversals();</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，在绘制时有两种情况，即采用硬件加速或不采用，采用硬件加速进行绘制会在后面专门分析，这里先考虑drawSoftware()这种情况，该方法的主要代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></div><div class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="comment">// Draw with software renderer.</span></div><div class="line">       <span class="keyword">final</span> Canvas canvas;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</div><div class="line"></div><div class="line">           canvas = mSurface.lockCanvas(dirty);</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">       ...</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">           <span class="comment">// If this bitmap's format includes an alpha channel, we</span></div><div class="line">           <span class="comment">// need to clear it before drawing so that the child will</span></div><div class="line">           <span class="comment">// properly re-composite its drawing on a transparent</span></div><div class="line">           <span class="comment">// background. This automatically respects the clip/dirty region</span></div><div class="line">           <span class="comment">// or</span></div><div class="line">           <span class="comment">// If we are applying an offset, we need to clear the area</span></div><div class="line">           <span class="comment">// where the offset doesn't appear to avoid having garbage</span></div><div class="line">           <span class="comment">// left in the blank areas.</span></div><div class="line">           <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</div><div class="line">               canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           dirty.setEmpty();</div><div class="line">           mIsAnimating = <span class="keyword">false</span>;</div><div class="line">           mView.mPrivateFlags |= View.PFLAG_DRAWN;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               canvas.translate(-xoff, -yoff);</div><div class="line">               <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</div><div class="line">                   mTranslator.translateCanvas(canvas);</div><div class="line">               &#125;</div><div class="line">               canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</div><div class="line">               attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">               mView.draw(canvas);</div><div class="line"></div><div class="line">               drawAccessibilityFocusedDrawableIfNeeded(canvas);</div><div class="line">           &#125; </div><div class="line">           ...</div><div class="line">       &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               surface.unlockCanvasAndPost(canvas);</div><div class="line">           &#125; </div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>mSurface在ViewRootImpl的构造方法之前就通过final Surface mSurface=new Surface();的定义创建了</p>
</li>
<li><p>这里有三个流程很重要，分别是canvas = mSurface.lockCanvas(dirty); mView.draw(canvas);以及surface.unlockCanvasAndPost(canvas);其中mView.draw(canvas);就是真正地调用skia图形库进行绘制的过程，这个在前一篇文章中分析过，这里先不分析。</p>
<p>​</p>
</li>
</ul>
<h4 id="Surface-lockCanvas-方法分析"><a href="#Surface-lockCanvas-方法分析" class="headerlink" title="Surface.lockCanvas()方法分析"></a>Surface.lockCanvas()方法分析</h4><p>下面先分析canvas=mSurface.lockCanvas(dirty);这个调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></div><div class="line"><span class="function">            <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            checkNotReleasedLocked();</div><div class="line">            <span class="keyword">if</span> (mLockedObject != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Ideally, nativeLockCanvas() would throw in this situation and prevent the</span></div><div class="line">                <span class="comment">// double-lock, but that won't happen if mNativeObject was updated.  We can't</span></div><div class="line">                <span class="comment">// abandon the old mLockedObject because it might still be in use, so instead</span></div><div class="line">                <span class="comment">// we just refuse to re-lock the Surface.</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Surface was already locked"</span>);</div><div class="line">            &#125;</div><div class="line">            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</div><div class="line">            <span class="keyword">return</span> mCanvas;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法是用于提供一个Canvas,从而让图形数据可以写入到Surface中，当然，最终其实是写入到surface-flinger进程中的Layer中。在调用这个方法之后需要调用unlockCanvasAndPost()以将要绘制的内容提交给Surface，所以这两个方法需要成对出现。</p>
<p>nativeLockCanvas()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></div><div class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</div><div class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>)</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</div><div class="line">        doThrowIAE(env);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Rect dirtyRect;</div><div class="line">    Rect* dirtyRectPtr = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</div><div class="line">        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</div><div class="line">        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</div><div class="line">        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</div><div class="line">        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</div><div class="line">        dirtyRectPtr = &amp;dirtyRect;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ANativeWindow_Buffer outBuffer;</div><div class="line">    status_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</div><div class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> exception = (err == NO_MEMORY) ?</div><div class="line">                OutOfResourcesException :</div><div class="line">                <span class="string">"java/lang/IllegalArgumentException"</span>;</div><div class="line">        jniThrowException(env, exception, NULL);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</div><div class="line">                                         convertPixelFormat(outBuffer.format),</div><div class="line">                                         kPremul_SkAlphaType);</div><div class="line">    <span class="keyword">if</span> (outBuffer.format == PIXEL_FORMAT_RGBX_8888) &#123;</div><div class="line">        info.fAlphaType = kOpaque_SkAlphaType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SkBitmap bitmap;</div><div class="line">    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</div><div class="line">    bitmap.setInfo(info, bpr);</div><div class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</div><div class="line">        bitmap.setPixels(outBuffer.bits);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// be safe with an empty bitmap.</span></div><div class="line">        bitmap.setPixels(NULL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</div><div class="line">    nativeCanvas-&gt;setBitmap(bitmap);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</div><div class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</div><div class="line">                dirtyRect.right, dirtyRect.bottom);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</div><div class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</div><div class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</div><div class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</div><div class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Create another reference to the surface and return it.  This reference</span></div><div class="line">    <span class="comment">// should be passed to nativeUnlockCanvasAndPost in place of mNativeObject,</span></div><div class="line">    <span class="comment">// because the latter could be replaced while the surface is locked.</span></div><div class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</div><div class="line">    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</div><div class="line">    <span class="keyword">return</span> (jlong) lockedSurface.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的主要作用如下：</p>
<ul>
<li>将之前创建的C++层的Surface对象的句柄还原为Surface指针</li>
</ul>
<ul>
<li>根据Java层传递的数据获取脏区域的left,top,right,bottom这四个角点的数值，从而得到矩形的大小和位置 </li>
<li>调用Surface的lock()方法，将申请的图形缓冲区赋值给outBuffer,这个lock()方法涉及到的东西非常多，后面将会详细分析</li>
<li>通过bitmap.setPixels(outBuffer.bits)将ANativeWindow_Buffer中的bits传递给SkBitmap对象，其中bits即为图形缓冲区的首地址。SkCanvas之后就可以通过这个首地址来输出UI数据了</li>
<li>创建一个Skbitmap对象，并且填充它的图形缓冲区，最终赋值给Java层的Canvas对象</li>
<li>将剪裁位置大小信息赋值给java层的inOutDirty这个Rect对象</li>
</ul>
<p>至此，drawSoftware()方法中canvas = mSurface.lockCanvas(dirty);这个调用就分析完了。为了搞清楚ANativeWindow_Buffer的来源，下面开始分析Surface的lock方法。</p>
<h4 id="C-层的Surface-lock-方法"><a href="#C-层的Surface-lock-方法" class="headerlink" title="C++层的Surface::lock()方法"></a>C++层的Surface::lock()方法</h4><p>Surface::lock()方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> Surface::lock(</div><div class="line">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    ANativeWindowBuffer* out;</div><div class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</div><div class="line">    ALOGE_IF(err, <span class="string">"dequeueBuffer failed (%s)"</span>, strerror(-err));</div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</div><div class="line">        <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</div><div class="line"></div><div class="line">        Region newDirtyRegion;</div><div class="line">        <span class="keyword">if</span> (inOutDirtyBounds) &#123;</div><div class="line">            newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</div><div class="line">            newDirtyRegion.andSelf(bounds);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            newDirtyRegion.<span class="built_in">set</span>(bounds);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// figure out if we can copy the frontbuffer back</span></div><div class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</div><div class="line">                backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</div><div class="line">                backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</div><div class="line">                backBuffer-&gt;format == frontBuffer-&gt;format);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (canCopyBack) &#123;</div><div class="line">            <span class="comment">// copy the area that is invalid and not repainted this round</span></div><div class="line">            const Region copyback(mDirtyRegion.subtract(newDirtyRegion));</div><div class="line">            <span class="keyword">if</span> (!copyback.isEmpty())</div><div class="line">                copyBlt(backBuffer, frontBuffer, copyback);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// if we can't copy-back anything, modify the user's dirty</span></div><div class="line">            <span class="comment">// region to make sure they redraw the whole buffer</span></div><div class="line">            newDirtyRegion.<span class="built_in">set</span>(bounds);</div><div class="line">            mDirtyRegion.clear();</div><div class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</div><div class="line">                mSlots[i].dirtyRegion.clear();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#123; <span class="comment">// scope for the lock</span></div><div class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</div><div class="line">            int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));</div><div class="line">            <span class="keyword">if</span> (backBufferSlot &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="function">Region&amp; <span class="title">dirtyRegion</span><span class="params">(mSlots[backBufferSlot].dirtyRegion)</span></span>;</div><div class="line">                mDirtyRegion.subtract(dirtyRegion);</div><div class="line">                dirtyRegion = newDirtyRegion;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mDirtyRegion.orSelf(newDirtyRegion);</div><div class="line">        <span class="keyword">if</span> (inOutDirtyBounds) &#123;</div><div class="line">            *inOutDirtyBounds = newDirtyRegion.getBounds();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">void</span>* vaddr;</div><div class="line">        <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</div><div class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</div><div class="line">                newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</div><div class="line"></div><div class="line">        ALOGW_IF(res, <span class="string">"failed locking buffer (handle = %p)"</span>,</div><div class="line">                backBuffer-&gt;handle);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</div><div class="line">            err = INVALID_OPERATION;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mLockedBuffer = backBuffer;</div><div class="line">            outBuffer-&gt;width  = backBuffer-&gt;width;</div><div class="line">            outBuffer-&gt;height = backBuffer-&gt;height;</div><div class="line">            outBuffer-&gt;stride = backBuffer-&gt;stride;</div><div class="line">            outBuffer-&gt;format = backBuffer-&gt;format;</div><div class="line">            outBuffer-&gt;bits   = vaddr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的主要工作为:</p>
<ul>
<li>调用dequeueBuffer()函数获取图形缓冲区</li>
<li>计算需要绘制的dirty区域，旧的区域则只需copy数据即可</li>
</ul>
<p>其实注释都已经写得很清楚了，就是将需要更新的dirty区域剪裁出来，剩余不需要更新的区域则不用重绘。在大部分情况下，UI只有一小部分发生变化(如点击按钮时，按钮颜色发生变化)，这一小部分UI只对应整个GraphicBuffer中的一小块存储(即代码中的dirtyRegion),如果此时所有区域都更新，则会造成很大的资源浪费。</p>
<p>此时就需要将变化的图像和没有发生变化的图像进行叠加，上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置。这里将根据需要，将mPostedBuffer中的旧数据copy到BackBuffer中。后续的绘画只需要更新脏区即可。</p>
<ul>
<li>lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，例如，向一块缓冲区写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突，锁定之后，就可以确定缓冲区的起始地址，并保存在vaddr中。在访问完一场图形缓冲区之后，需要解锁它。</li>
</ul>
<h4 id="图形缓冲区的分配"><a href="#图形缓冲区的分配" class="headerlink" title="图形缓冲区的分配"></a>图形缓冲区的分配</h4><p>Surface的dequeueBuffer()方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Surface::dequeueBuffer(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd) &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    <span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, swapIntervalZero,</div><div class="line">            reqWidth, reqHeight, reqFormat, reqUsage);</div><div class="line">    ...</div><div class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</div><div class="line"></div><div class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) &#123;</div><div class="line">        freeAllBuffers();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    *buffer = gbuf.get();</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这个方法是通过调用IGraphicBufferProducer对象(其实是BpGraphicBufferProducer对象，在前面分析过)的dequeueBuffer()方法来获得图形缓冲区，如果没有找到空闲的缓冲区，就需要调用mGraphicBufferProducer-&gt;requestBuffer(buf,&amp;gbuf);从匿名共享内存中重新分配。</p>
<p>显然，这里会通过跨进程调用到BufferQueueProducer::dequeueBuffer()方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> BufferQueueProducer::dequeueBuffer(<span class="keyword">int</span> *outSlot,</div><div class="line">        sp&lt;android::Fence&gt; *outFence, <span class="keyword">bool</span> async,</div><div class="line">        <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">status_t</span> returnFlags = NO_ERROR;</div><div class="line">    EGLDisplay eglDisplay = EGL_NO_DISPLAY;</div><div class="line">    EGLSyncKHR eglFence = EGL_NO_SYNC_KHR;</div><div class="line">    <span class="keyword">bool</span> attachedByConsumer = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    &#123; <span class="comment">// Autolock scope</span></div><div class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</div><div class="line">        mCore-&gt;waitWhileAllocatingLocked();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (format == <span class="number">0</span>) &#123;</div><div class="line">            format = mCore-&gt;mDefaultBufferFormat;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Enable the usage bits the consumer requested</span></div><div class="line">        usage |= mCore-&gt;mConsumerUsageBits;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> useDefaultSize = !width &amp;&amp; !height;</div><div class="line">        <span class="keyword">if</span> (useDefaultSize) &#123;</div><div class="line">            width = mCore-&gt;mDefaultWidth;</div><div class="line">            height = mCore-&gt;mDefaultHeight;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</div><div class="line">        <span class="keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;</div><div class="line">            <span class="keyword">status_t</span> status = waitForFreeSlotThenRelock(<span class="string">"dequeueBuffer"</span>, async,</div><div class="line">                    &amp;found, &amp;returnFlags);</div><div class="line">            <span class="keyword">if</span> (status != NO_ERROR) &#123;</div><div class="line">                <span class="keyword">return</span> status;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This should not happen</span></div><div class="line">            <span class="keyword">if</span> (found == BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</div><div class="line">                BQ_LOGE(<span class="string">"dequeueBuffer: no available buffer slots"</span>);</div><div class="line">                <span class="keyword">return</span> -EBUSY;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[found].mGraphicBuffer);</div><div class="line"></div><div class="line">            <span class="comment">// If we are not allowed to allocate new buffers,</span></div><div class="line">            <span class="comment">// waitForFreeSlotThenRelock must have returned a slot containing a</span></div><div class="line">            <span class="comment">// buffer. If this buffer would require reallocation to meet the</span></div><div class="line">            <span class="comment">// requested attributes, we free it and attempt to get another one.</span></div><div class="line">            <span class="keyword">if</span> (!mCore-&gt;mAllowAllocation) &#123;</div><div class="line">                <span class="keyword">if</span> (buffer-&gt;needsReallocation(width, height, format, usage)) &#123;</div><div class="line">                    mCore-&gt;freeBufferLocked(found);</div><div class="line">                    found = BufferItem::INVALID_BUFFER_SLOT;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        *outSlot = found;</div><div class="line">        ATRACE_BUFFER_INDEX(found);</div><div class="line"></div><div class="line">        attachedByConsumer = mSlots[found].mAttachedByConsumer;</div><div class="line"></div><div class="line">        mSlots[found].mBufferState = BufferSlot::DEQUEUED;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[found].mGraphicBuffer);</div><div class="line">        <span class="keyword">if</span> ((buffer == <span class="literal">NULL</span>) ||</div><div class="line">                buffer-&gt;needsReallocation(width, height, format, usage))</div><div class="line">        &#123;</div><div class="line">            mSlots[found].mAcquireCalled = <span class="literal">false</span>;</div><div class="line">            mSlots[found].mGraphicBuffer = <span class="literal">NULL</span>;</div><div class="line">            mSlots[found].mRequestBufferCalled = <span class="literal">false</span>;</div><div class="line">            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;</div><div class="line">            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</div><div class="line">            mSlots[found].mFence = Fence::NO_FENCE;</div><div class="line">            mCore-&gt;mBufferAge = <span class="number">0</span>;</div><div class="line"></div><div class="line">            returnFlags |= BUFFER_NEEDS_REALLOCATION;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// We add 1 because that will be the frame number when this buffer</span></div><div class="line">            <span class="comment">// is queued</span></div><div class="line">            mCore-&gt;mBufferAge =</div><div class="line">                    mCore-&gt;mFrameCounter + <span class="number">1</span> - mSlots[found].mFrameNumber;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        eglDisplay = mSlots[found].mEglDisplay;</div><div class="line">        eglFence = mSlots[found].mEglFence;</div><div class="line">        *outFence = mSlots[found].mFence;</div><div class="line">        mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</div><div class="line">        mSlots[found].mFence = Fence::NO_FENCE;</div><div class="line"></div><div class="line">        mCore-&gt;validateConsistencyLocked();</div><div class="line">    &#125; <span class="comment">// Autolock scope</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</div><div class="line">        <span class="keyword">status_t</span> error;</div><div class="line">        BQ_LOGV(<span class="string">"dequeueBuffer: allocating a new buffer for slot %d"</span>, *outSlot);</div><div class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(mCore-&gt;mAllocator-&gt;createGraphicBuffer(</div><div class="line">                width, height, format, usage, &amp;error));</div><div class="line">        <span class="keyword">if</span> (graphicBuffer == <span class="literal">NULL</span>) &#123;</div><div class="line">            BQ_LOGE(<span class="string">"dequeueBuffer: createGraphicBuffer failed"</span>);</div><div class="line">            <span class="keyword">return</span> error;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123; <span class="comment">// Autolock scope</span></div><div class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</div><div class="line">                BQ_LOGE(<span class="string">"dequeueBuffer: BufferQueue has been abandoned"</span>);</div><div class="line">                <span class="keyword">return</span> NO_INIT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);</div><div class="line">            mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</div><div class="line">        &#125; <span class="comment">// Autolock scope</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (attachedByConsumer) &#123;</div><div class="line">        returnFlags |= BUFFER_NEEDS_REALLOCATION;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eglFence != EGL_NO_SYNC_KHR) &#123;</div><div class="line">        EGLint result = eglClientWaitSyncKHR(eglDisplay, eglFence, <span class="number">0</span>,</div><div class="line">                <span class="number">1000000000</span>);</div><div class="line">        <span class="comment">// If something goes wrong, log the error, but return the buffer without</span></div><div class="line">        <span class="comment">// synchronizing access to it. It's too late at this point to abort the</span></div><div class="line">        <span class="comment">// dequeue operation.</span></div><div class="line">        <span class="keyword">if</span> (result == EGL_FALSE) &#123;</div><div class="line">            BQ_LOGE(<span class="string">"dequeueBuffer: error %#x waiting for fence"</span>,</div><div class="line">                    eglGetError());</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == EGL_TIMEOUT_EXPIRED_KHR) &#123;</div><div class="line">            BQ_LOGE(<span class="string">"dequeueBuffer: timeout waiting for fence"</span>);</div><div class="line">        &#125;</div><div class="line">        eglDestroySyncKHR(eglDisplay, eglFence);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> returnFlags;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法虽然看起来很长，但是其实很简单，就是根据指定的index取出mSlots中的slot中的buffer，然后让buf指向它。</p>
<h4 id="Surface-unlockCanvasAndPost-方法分析"><a href="#Surface-unlockCanvasAndPost-方法分析" class="headerlink" title="Surface.unlockCanvasAndPost()方法分析"></a>Surface.unlockCanvasAndPost()方法分析</h4><p>Surface.unlockCanvasAndPost()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            checkNotReleasedLocked();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123;</div><div class="line">                mHwuiContext.unlockAndPost(canvas);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                unlockSwCanvasAndPost(canvas);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于我们这里只分析非硬件加速的情况，所以执行unlockSwCanvasAndPost()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            nativeUnlockCanvasAndPost(mLockedObject, canvas);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            nativeRelease(mLockedObject);</div><div class="line">            mLockedObject = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>没啥好说的，就是jni调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></div><div class="line"><span class="function"><span class="params">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;</div><div class="line">    sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</div><div class="line">    <span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// detach the canvas from the surface</span></div><div class="line">    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</div><div class="line">    nativeCanvas-&gt;setBitmap(SkBitmap());</div><div class="line"></div><div class="line">    <span class="comment">// unlock surface</span></div><div class="line">    <span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</div><div class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</div><div class="line">        doThrowIAE(env);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的主要作用为:</p>
<ul>
<li>获取java层保存的Surface句柄，还原为Surface指针</li>
<li>解除java层对native层的SkBitmap对象的引用</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/09/HttpURLConnection背后的惊人真相/" rel="next" title="Http(s)URLConnection背后的惊人真相">
                <i class="fa fa-chevron-left"></i> Http(s)URLConnection背后的惊人真相
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#图形绘制概述"><span class="nav-number">1.</span> <span class="nav-text">图形绘制概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android图形组件"><span class="nav-number">2.</span> <span class="nav-text">Android图形组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比喻"><span class="nav-number">3.</span> <span class="nav-text">比喻</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图解"><span class="nav-number">4.</span> <span class="nav-text">图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示前的准备工作"><span class="nav-number">5.</span> <span class="nav-text">显示前的准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从Activity到ViewRootImpl"><span class="nav-number">5.1.</span> <span class="nav-text">从Activity到ViewRootImpl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SurfaceComposerClient"><span class="nav-number">5.2.</span> <span class="nav-text">SurfaceComposerClient</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘图过程"><span class="nav-number">6.</span> <span class="nav-text">绘图过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SurfaceControl"><span class="nav-number">6.1.</span> <span class="nav-text">SurfaceControl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BpSurfaceComposerClient-createSurface-方法"><span class="nav-number">6.2.</span> <span class="nav-text">BpSurfaceComposerClient::createSurface()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-层Surface对象的创建"><span class="nav-number">6.3.</span> <span class="nav-text">C++层Surface对象的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备工作总结"><span class="nav-number">6.4.</span> <span class="nav-text">准备工作总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始进入绘制流程"><span class="nav-number">6.5.</span> <span class="nav-text">开始进入绘制流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Surface-lockCanvas-方法分析"><span class="nav-number">6.6.</span> <span class="nav-text">Surface.lockCanvas()方法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-层的Surface-lock-方法"><span class="nav-number">6.7.</span> <span class="nav-text">C++层的Surface::lock()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图形缓冲区的分配"><span class="nav-number">6.8.</span> <span class="nav-text">图形缓冲区的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Surface-unlockCanvasAndPost-方法分析"><span class="nav-number">6.9.</span> <span class="nav-text">Surface.unlockCanvasAndPost()方法分析</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
