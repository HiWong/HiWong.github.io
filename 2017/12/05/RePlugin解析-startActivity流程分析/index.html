<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android_plugin," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1.编译时代码替换所有plugin中的Activity子类都会在编译时由gradle插件进行替换，即将继承自Activity或Activity子类(如AppCompatActivity)的类改为继承PluginActivity和PluginAppCompatActivity等,这样做的原因在于:RePlugin既不想Hook AMP,Instrumentation等，又想达到动态加载未在Manif">
<meta name="keywords" content="android_plugin">
<meta property="og:type" content="article">
<meta property="og:title" content="RePlugin解析(-):startActivity流程分析">
<meta property="og:url" content="http://yoursite.com/2017/12/05/RePlugin解析-startActivity流程分析/index.html">
<meta property="og:site_name" content="AllenWang的个人博客">
<meta property="og:description" content="1.编译时代码替换所有plugin中的Activity子类都会在编译时由gradle插件进行替换，即将继承自Activity或Activity子类(如AppCompatActivity)的类改为继承PluginActivity和PluginAppCompatActivity等,这样做的原因在于:RePlugin既不想Hook AMP,Instrumentation等，又想达到动态加载未在Manif">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/android/replugin/RePlugin_startActivity_flow.png">
<meta property="og:updated_time" content="2018-03-04T06:50:22.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RePlugin解析(-):startActivity流程分析">
<meta name="twitter:description" content="1.编译时代码替换所有plugin中的Activity子类都会在编译时由gradle插件进行替换，即将继承自Activity或Activity子类(如AppCompatActivity)的类改为继承PluginActivity和PluginAppCompatActivity等,这样做的原因在于:RePlugin既不想Hook AMP,Instrumentation等，又想达到动态加载未在Manif">
<meta name="twitter:image" content="http://yoursite.com/images/android/replugin/RePlugin_startActivity_flow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/05/RePlugin解析-startActivity流程分析/"/>





  <title>RePlugin解析(-):startActivity流程分析 | AllenWang的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AllenWang的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小楼一夜听春雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ad">
          <a href="/ad/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            menu.ad
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/RePlugin解析-startActivity流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AllenWang的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RePlugin解析(-):startActivity流程分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T00:06:11+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android-plugin/" itemprop="url" rel="index">
                    <span itemprop="name">android_plugin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-编译时代码替换"><a href="#1-编译时代码替换" class="headerlink" title="1.编译时代码替换"></a>1.编译时代码替换</h2><p>所有plugin中的Activity子类都会在编译时由gradle插件进行替换，即将继承自Activity或Activity子类(如AppCompatActivity)的类改为继承PluginActivity和PluginAppCompatActivity等,这样做的原因在于:RePlugin既不想Hook AMP,Instrumentation等，又想达到动态加载未在Manifest中声明的组件的目的，那么就只能在编译期做更多的事情，即通过gradle插件来修改plugin中的代码(特别是组件的代码),比如这里所有本来继承自Activity或AppCompatActivity改为继承PluginActivity和PluginAppCompatActivity,而PluginActivity虽然也是继承自Activity,但是其内部的方法已经重写了，代码如下<a id="more"></a>（在replugin-plugin-library中):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 插件内的BaseActivity，建议插件内所有的Activity都要继承此类</span></div><div class="line"><span class="comment"> * 此类通过override方式来完成插件框架的相关工作</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> RePlugin Team</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</div><div class="line">        newBase = RePluginInternal.createActivityContext(<span class="keyword">this</span>, newBase);</div><div class="line">        <span class="keyword">super</span>.attachBaseContext(newBase);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        RePluginInternal.handleActivityCreateBefore(<span class="keyword">this</span>, savedInstanceState);</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        RePluginInternal.handleActivityCreate(<span class="keyword">this</span>, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        RePluginInternal.handleActivityDestroy(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        RePluginInternal.handleRestoreInstanceState(<span class="keyword">this</span>, savedInstanceState);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">            <span class="comment">// Crash Hash: B1F67129BC6A67C882AF2BBE62202BF0</span></div><div class="line">            <span class="comment">// java.lang.IllegalArgumentException: Wrong state class异常</span></div><div class="line">            <span class="comment">// 原因：恢复现场时，Activity坑位找错了。通常是用于占坑的Activity的层级过深导致</span></div><div class="line">            <span class="comment">// 举例：假如我们只有一个坑位可用，A和B分别是清理和通讯录的两个Activity</span></div><div class="line">            <span class="comment">//      如果进程重启，系统原本恢复B，却走到了A，从而出现此问题</span></div><div class="line">            <span class="comment">// 解决：将其Catch住，这样系统在找ViewState时不会出错。</span></div><div class="line">            <span class="comment">// 后遗症：</span></div><div class="line">            <span class="comment">// 1、可能无法恢复系统级View的保存的状态；</span></div><div class="line">            <span class="comment">// 2、如果自己代码处理不当，可能会出现异常。故自己代码一定要用SecExtraUtils来获取Bundle数据</span></div><div class="line">            <span class="keyword">if</span> (LogRelease.LOGR) &#123;</div><div class="line">                LogRelease.e(<span class="string">"PluginActivity"</span>, <span class="string">"o r i s: p="</span> + getPackageCodePath() + <span class="string">"; "</span> + e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">if</span> (RePluginInternal.startActivity(<span class="keyword">this</span>, intent)) &#123;</div><div class="line">            <span class="comment">// 这个地方不需要回调startActivityAfter，因为Factory2最终还是会回调回来，最终还是要走super.startActivity()</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.startActivity(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">if</span> (RePluginInternal.startActivityForResult(<span class="keyword">this</span>, intent, requestCode)) &#123;</div><div class="line">            <span class="comment">// 这个地方不需要回调startActivityAfter，因为Factory2最终还是会回调回来，最终还是要走super.startActivityForResult()</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，这样做的结果是之前插件中Activity代码中的startActivity和startActivityForResult()方法都修改为RePluginInternal.startActivity()和RePluginInternal.startActivityForResult()方法，而RePluginInternal其实只是做了封装，最终通过反射调用到replugin-host-library的startActivity()中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (C) 2005-2017 Qihoo 360 Inc.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not</span></div><div class="line"><span class="comment"> * use this file except in compliance with the License. You may obtain a copy of</span></div><div class="line"><span class="comment"> * the License at</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Unless required by applicable law or agreed To in writing, software</span></div><div class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT</span></div><div class="line"><span class="comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></div><div class="line"><span class="comment"> * License for the specific language governing permissions and limitations under</span></div><div class="line"><span class="comment"> * the License.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> com.qihoo360.i;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.app.Activity;</div><div class="line"><span class="keyword">import</span> android.app.Service;</div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.content.Intent;</div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.qihoo360.loader2.PluginLibraryInternalProxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.json.JSONArray;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * plugin-library中，通过“反射”调用的内部逻辑（如PluginActivity类的调用等）均在此处 &lt;p&gt;</span></div><div class="line"><span class="comment"> * 注意：务必要Keep住此类，否则插件调用将失败</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> RePlugin Team</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部框架使用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PluginLibraryInternalProxy sPLProxy;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Activity创建成功后通过此方法获取其base context</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> newBase</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 为Activity构造一个base Context</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Context <span class="title">createActivityContext</span><span class="params">(Activity activity, Context newBase)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.createActivityContext(activity, newBase);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Activity的onCreate调用前调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> savedInstanceState</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleActivityCreateBefore</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        sPLProxy.handleActivityCreateBefore(activity, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Activity的onCreate调用后调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> savedInstanceState</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleActivityCreate</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        sPLProxy.handleActivityCreate(activity, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Activity的onDestroy调用后调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleActivityDestroy</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">        sPLProxy.handleActivityDestroy(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Activity的onRestoreInstanceState调用后调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> savedInstanceState</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleRestoreInstanceState</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        sPLProxy.handleRestoreInstanceState(activity, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Service的onCreate调用后调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleServiceCreate</span><span class="params">(Service service)</span> </span>&#123;</div><div class="line">        sPLProxy.handleServiceCreate(service);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 插件的Service的onDestroy调用后调用此方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleServiceDestroy</span><span class="params">(Service service)</span> </span>&#123;</div><div class="line">        sPLProxy.handleServiceDestroy(service);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 启动一个插件中的activity</span></div><div class="line"><span class="comment">     * 通过Extra参数IPluginManager.KEY_COMPATIBLE，IPluginManager.KEY_PLUGIN，IPluginManager.KEY_ACTIVITY，IPluginManager.KEY_PROCESS控制</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> context Context上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.startActivity(context, intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 启动一个插件中的activity</span></div><div class="line"><span class="comment">     * 通过Extra参数IPluginManager.KEY_COMPATIBLE，IPluginManager.KEY_PLUGIN，IPluginManager.KEY_ACTIVITY，IPluginManager.KEY_PROCESS控制</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity Activity上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Activity activity, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.startActivity(activity, intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 启动一个插件中的activity，如果插件不存在会触发下载界面</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> context 应用上下文或者Activity上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity 待启动的activity类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> process 是否在指定进程中启动</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> download 下载</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent, String plugin, String activity, <span class="keyword">int</span> process, <span class="keyword">boolean</span> download)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.startActivity(context, intent, plugin, activity, process, download);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过 forResult 方式启动一个插件的 Activity</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity    源 Activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent      要打开 Activity 的 Intent，其中 ComponentName 的 Key 必须为插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode 请求码</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> options     附加的数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@see</span> #startActivityForResult(Activity, Intent, int, Bundle)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startActivityForResult</span><span class="params">(Activity activity, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.startActivityForResult(activity, intent, requestCode, options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 返回所有插件的json串，格式见plugins-builtin.json文件</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> name 插件名，传null或者空串表示获取全部</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JSONArray <span class="title">fetchPlugins</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.fetchPlugins(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 登记动态映射的类</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> className 壳类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 目标插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> type 目标类的类型: activity, service, provider</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">registerDynamicClass</span><span class="params">(String className, String plugin, String type, String target)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.registerDynamicClass(className, plugin, type, target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 登记动态映射的类</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> className 壳类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 目标插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">registerDynamicClass</span><span class="params">(String className, String plugin, String target, Class defClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.registerDynamicClass(className, plugin, target, defClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 查询动态映射的类</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> className 壳类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 目标插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDynamicClass</span><span class="params">(String plugin, String className)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.isDynamicClass(plugin, className);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unregisterDynamicClass</span><span class="params">(String source)</span> </span>&#123;</div><div class="line">        sPLProxy.unregisterDynamicClass(source);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架调用</span></div><div class="line"><span class="comment">     * 根据动态注册的类，反查此类对应的插件名称</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> className 动态类名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getPluginByDynamicClass</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sPLProxy.getPluginByDynamicClass(className);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而Factory2其实仍然还是起一个封装的作用，实际调用的是PluginLibraryInternalProxy中的startActivity()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">    * 启动一个插件中的activity</span></div><div class="line"><span class="comment">    * 通过Extra参数IPluginManager.KEY_COMPATIBLE，IPluginManager.KEY_PLUGIN，IPluginManager.KEY_ACTIVITY，IPluginManager.KEY_PROCESS控制</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> context Context上下文</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (LOG) &#123;</div><div class="line">           LogDebug.d(PLUGIN_TAG, <span class="string">"start context: intent="</span> + intent);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 兼容模式，直接使用标准方式启动</span></div><div class="line">       <span class="keyword">if</span> (intent.getBooleanExtra(IPluginManager.KEY_COMPATIBLE, <span class="keyword">false</span>)) &#123;</div><div class="line">           PmBase.cleanIntentPluginParams(intent);</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.d(PLUGIN_TAG, <span class="string">"start context: COMPATIBLE is true, direct start"</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 获取Activity的名字，有两种途径：</span></div><div class="line">       <span class="comment">// 1. 从Intent里取。通常是明确知道要打开的插件的Activity时会用</span></div><div class="line">       <span class="comment">// 2. 从Intent的ComponentName中获取</span></div><div class="line">       String name = intent.getStringExtra(IPluginManager.KEY_ACTIVITY);</div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</div><div class="line">           ComponentName cn = intent.getComponent();</div><div class="line">           <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</div><div class="line">               name = cn.getClassName();</div><div class="line">               <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                   LogDebug.d(PLUGIN_TAG, <span class="string">"start context: custom context="</span> + context);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 已经是标准坑了（例如N1ST1这样的），则无需再过“坑位分配”逻辑，直接使用标准方式启动</span></div><div class="line">       <span class="keyword">if</span> (mPluginMgr.isActivity(name)) &#123;</div><div class="line">           PmBase.cleanIntentPluginParams(intent);</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.d(PLUGIN_TAG, <span class="string">"start context: context is container, direct start"</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 获取插件名，有三种途径：</span></div><div class="line">       <span class="comment">// 1. 从Intent里取。通常是明确知道要打开的插件时会用</span></div><div class="line">       <span class="comment">// 2. 根据当前Activity的坑位名来“反查”其插件名。通常是插件内开启自己的Activity时用到</span></div><div class="line">       <span class="comment">// 3. 通过获得Context的类加载器来判断其插件名</span></div><div class="line">       String plugin = intent.getStringExtra(IPluginManager.KEY_PLUGIN);</div><div class="line"></div><div class="line">       <span class="comment">/* 检查是否是动态注册的类 */</span></div><div class="line">       <span class="comment">// 如果要启动的 Activity 是动态注册的类，则不使用坑位机制，而是直接动态类。</span></div><div class="line">       <span class="comment">// 原因：宿主的某些动态注册的类不能运行在坑位中（如'桌面'插件的入口Activity）</span></div><div class="line">       ComponentName componentName = intent.getComponent();</div><div class="line">       <span class="keyword">if</span> (componentName != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (LogDebug.LOG) &#123;</div><div class="line">            LogDebug.d(<span class="string">"loadClass"</span>, <span class="string">"isHookingClass("</span> + plugin + <span class="string">","</span> + componentName.getClassName() + <span class="string">") = "</span></div><div class="line">                    + isDynamicClass(plugin, componentName.getClassName()));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isDynamicClass(plugin, componentName.getClassName())) &#123;</div><div class="line">               intent.putExtra(IPluginManager.KEY_COMPATIBLE, <span class="keyword">true</span>);</div><div class="line">            intent.setComponent(<span class="keyword">new</span> ComponentName(IPC.getPackageName(), componentName.getClassName()));</div><div class="line">            context.startActivity(intent);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">           <span class="comment">// 看下Context是否为Activity，如是则直接从坑位中获取插件名（最准确）</span></div><div class="line">           <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</div><div class="line">               plugin = fetchPluginByPitActivity((Activity) context);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.d(PLUGIN_TAG, <span class="string">"start context: custom plugin is empty, query plugin="</span> + plugin);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 没拿到插件名？再从 ClassLoader 获取插件名称（兜底）</span></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">           plugin = RePlugin.fetchPluginNameByClassLoader(context.getClassLoader());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 仍然拿不到插件名？（例如从宿主中调用），则打开的Activity可能是宿主的。直接使用标准方式启动</span></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">           PmBase.cleanIntentPluginParams(intent);</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.d(PLUGIN_TAG, <span class="string">"start context: plugin and context is empty, direct start"</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 获取进程值，看目标Activity要打开哪个进程</span></div><div class="line">       <span class="keyword">int</span> process = intent.getIntExtra(IPluginManager.KEY_PROCESS, Integer.MIN_VALUE);</div><div class="line"></div><div class="line">       PmBase.cleanIntentPluginParams(intent);</div><div class="line"></div><div class="line">       <span class="comment">// 调用“特殊版”的startActivity，不让自动填写ComponentName，防止外界再用时出错</span></div><div class="line">       <span class="keyword">return</span> Factory.startActivityWithNoInjectCN(context, intent, plugin, name, process);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在分析这个方法之前，我们先分析一下除了Activity.startActivity()之外的另外一种startActivity()的调用，即Context.startActivity()这个调用，那我们将这个调用也替换掉呢？</p>
<p>其实很简单，不需要改动这部分代码，只需要在插件初始化时将其Context替换为特制的Context,即PluginContext:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">       <span class="comment">// HINT 只有插件Application才会走这里</span></div><div class="line">       <span class="comment">// 而Activity.startActivity系统最终会走startActivityForResult，不会走这儿</span></div><div class="line"></div><div class="line">       <span class="comment">// 这里会被调用两次：</span></div><div class="line">       <span class="comment">// 第一次：获取各种信息，最终确认坑位，并走startActivity，再次回到这里</span></div><div class="line">       <span class="comment">// 第二次：判断要打开的是“坑位Activity”，则返回False，直接走super，后面的事情你们都懂的</span></div><div class="line">       <span class="comment">// 当然，如果在获取坑位信息时遇到任何情况（例如要打开的是宿主的Activity），则直接返回false，走super</span></div><div class="line">       <span class="keyword">if</span> (!Factory2.startActivity(<span class="keyword">this</span>, intent)) &#123;</div><div class="line">           <span class="keyword">if</span> (mContextInjector != <span class="keyword">null</span>) &#123;</div><div class="line">               mContextInjector.startActivityBefore(intent);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">super</span>.startActivity(intent);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (mContextInjector != <span class="keyword">null</span>) &#123;</div><div class="line">               mContextInjector.startActivityAfter(intent);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到，PluginContext中的startActivity()方法其实也是调用 Factory2.startActivity()，到这里我们就把插件中所有startActivity()的调用都统一到Factory2.startActivity()的调用了，而至于插件中上下文的替换，是另外一个很大的话题，后面会专门写一篇文章来阐述。</p>
<h2 id="2-PluginLibraryInternalProxy"><a href="#2-PluginLibraryInternalProxy" class="headerlink" title="2.PluginLibraryInternalProxy"></a>2.PluginLibraryInternalProxy</h2><h3 id="2-1-首次进入插件时的startActivity-调用"><a href="#2-1-首次进入插件时的startActivity-调用" class="headerlink" title="2.1 首次进入插件时的startActivity()调用"></a>2.1 首次进入插件时的startActivity()调用</h3><p>此时涉及到坑位的分配，情况比较复杂。</p>
<p>从外部进入一个插件，通过调用RePlugin.startActivity(Context,Intent)实现，这个调用流程如下:</p>
<img src="/images/android/replugin/RePlugin_startActivity_flow.png">
<p>下面就逐步来分析。</p>
<h4 id="2-1-1-RePlugin-startActivity-Context-Intent"><a href="#2-1-1-RePlugin-startActivity-Context-Intent" class="headerlink" title="2.1.1 RePlugin.startActivity(Context,Intent)"></a>2.1.1 RePlugin.startActivity(Context,Intent)</h4><p>在看这个方法之前，先看一下这个Intent是如何来的，它跟一般的startActivity中的Intent不一样，它是特殊构造的，如下是一个调用示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RePlugin.startActivity(MainActivity.<span class="keyword">this</span>,RePlugin.createIntent(<span class="string">"demo1"</span>,<span class="string">"com.qihoo360.replugin.sample.demo1.MainActivity"</span>));</div></pre></td></tr></table></figure>
<p>而RePlugin.createIntent()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建一个用来定向到插件组件的Intent &lt;p&gt;</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 推荐用法： &lt;p&gt;</span></div><div class="line"><span class="comment">     * &lt;code&gt;</span></div><div class="line"><span class="comment">     * Intent in = RePlugin.createIntent("clean", "com.qihoo360.mobilesafe.clean.CleanActivity");</span></div><div class="line"><span class="comment">     * &lt;/code&gt; &lt;p&gt;</span></div><div class="line"><span class="comment">     * 当然，也可以用标准的Android创建方法： &lt;p&gt;</span></div><div class="line"><span class="comment">     * &lt;code&gt;</span></div><div class="line"><span class="comment">     * Intent in = new Intent(); &lt;p&gt;</span></div><div class="line"><span class="comment">     * in.setComponent(new ComponentName("clean", "com.qihoo360.mobilesafe.clean.CleanActivity"));</span></div><div class="line"><span class="comment">     * &lt;/code&gt;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName 插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> cls        目标全名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 可以被RePlugin识别的Intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@since</span> 1.0.0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">createIntent</span><span class="params">(String pluginName, String cls)</span> </span>&#123;</div><div class="line">        Intent in = <span class="keyword">new</span> Intent();</div><div class="line">        in.setComponent(createComponentName(pluginName, cls));</div><div class="line">        <span class="keyword">return</span> in;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，这个方法的作用是创建一个定向到插件中组件的Intent,所以”demo1”是插件名称，而”com.qihoo360.replugin.sample.demo1.MainActivity”是组件名。</p>
<p>下面看RePlugin.startActivity(Context,Intent)方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 开启一个插件的Activity &lt;p&gt;</span></div><div class="line"><span class="comment">    * 其中Intent的ComponentName的Key应为插件名（而不是包名），可使用createIntent方法来创建Intent对象</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> context Context对象</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent  要打开Activity的Intent，其中ComponentName的Key必须为插件名</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 插件Activity是否被成功打开？</span></div><div class="line"><span class="comment">    * FIXME 是否需要Exception来做？</span></div><div class="line"><span class="comment">    * <span class="doctag">@see</span> #createIntent(String, String)</span></div><div class="line"><span class="comment">    * <span class="doctag">@since</span> 1.0.0</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">       <span class="comment">// TODO 先用旧的开启Activity方案，以后再优化</span></div><div class="line">       ComponentName cn = intent.getComponent();</div><div class="line">       <span class="keyword">if</span> (cn == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">// TODO 需要支持Action方案</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       String plugin = cn.getPackageName();</div><div class="line">       String cls = cn.getClassName();</div><div class="line">       <span class="keyword">return</span> Factory.startActivityWithNoInjectCN(context, intent, plugin, cls, IPluginManager.PROCESS_AUTO);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实注释已经写得很完整了，就是开启一个插件的Activity,而plugin和cls刚刚在前面已经赋值，分别为”demo1”和”com.qihoo360.replugin.sample.demo1.MainActivity”. 其中IPluginManager.PROCESS_AUTO表示自动分配插件进程。</p>
<h4 id="2-1-2-Factory-startActivityWithNoInjectCN-Context-Intent-String-String-int"><a href="#2-1-2-Factory-startActivityWithNoInjectCN-Context-Intent-String-String-int" class="headerlink" title="2.1.2 Factory.startActivityWithNoInjectCN(Context, Intent, String, String, int)"></a>2.1.2 Factory.startActivityWithNoInjectCN(Context, Intent, String, String, int)</h4><p>  该方法代码如下:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 内部接口，仅为Factory2.startActivity(context, intent) 和 RePlugin.startActivity方法而使用</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> context  应用上下文或者Activity上下文</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent   Intent对象</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> plugin   插件名</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> activity 待启动的activity类名</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> process  是否在指定进程中启动</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 插件机制层，是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">    * Added by Jiongxuan Zhang</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startActivityWithNoInjectCN</span><span class="params">(Context context, Intent intent, String plugin, String activity, <span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> result = sPluginManager.startActivity(context, intent, plugin, activity, process);</div><div class="line"></div><div class="line">       RePlugin.getConfig().getEventCallbacks().onStartActivityCompleted(plugin, activity, result);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>  显然，该方法仅仅是起一个转发以及回调的作用。没什么好分析的，PluginCommImpl.startActivity(Context, Intent, String, String, int)类似，下面就直接进入PluginLibraryInternalProxy.startActivity()的分析。</p>
<p>####2.1.3 PluginLibraryInternalProxy.startActivity(Context, Intent, String, String, int, boolean)</p>
<p>该方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FIXME 建议去掉plugin和activity参数，直接用intent代替</span></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 启动一个插件中的activity，如果插件不存在会触发下载界面</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> context 应用上下文或者Activity上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> activity 待启动的activity类名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> process 是否在指定进程中启动</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> download 下载</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent, String plugin, String activity, <span class="keyword">int</span> process, <span class="keyword">boolean</span> download)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (LOG) &#123;</div><div class="line">            LogDebug.d(PLUGIN_TAG, <span class="string">"start activity: intent="</span> + intent + <span class="string">" plugin="</span> + plugin + <span class="string">" activity="</span> + activity + <span class="string">" process="</span> + process + <span class="string">" download="</span> + download);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 是否启动下载</span></div><div class="line">        <span class="comment">// 若插件不可用（不存在或版本不匹配），则直接弹出“下载插件”对话框</span></div><div class="line">        <span class="comment">// 因为已经打开UpdateActivity，故在这里返回True，告诉外界已经打开，无需处理</span></div><div class="line">        <span class="keyword">if</span> (download) &#123;</div><div class="line">            <span class="keyword">if</span> (PluginTable.getPluginInfo(plugin) == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                    LogDebug.d(PLUGIN_TAG, <span class="string">"plugin="</span> + plugin + <span class="string">" not found, start download ..."</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 如果用户在下载即将完成时突然点按“取消”，则有可能出现插件已下载成功，但没有及时加载进来的情况</span></div><div class="line">                <span class="comment">// 因此我们会判断这种情况，如果是，则重新加载一次即可，反之则提示用户下载</span></div><div class="line">                <span class="comment">// 原因：“取消”会触发Task.release方法，最终调用mDownloadTask.destroy，导致“下载服务”的Receiver被注销，即使文件下载了也没有回调回来</span></div><div class="line">                <span class="comment">// NOTE isNeedToDownload方法会调用pluginDownloaded再次尝试加载</span></div><div class="line">                <span class="keyword">if</span> (isNeedToDownload(context, plugin)) &#123;</div><div class="line">                    <span class="keyword">return</span> RePlugin.getConfig().getCallbacks().onPluginNotExistsForActivity(context, plugin, intent, process);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 检查是否是动态注册的类 */</span></div><div class="line">        <span class="comment">// 如果要启动的 Activity 是动态注册的类，则不使用坑位机制，而是直接动态类。</span></div><div class="line">        <span class="comment">// 原因：宿主的某些动态注册的类不能运行在坑位中（如'桌面'插件的入口Activity）</span></div><div class="line">        <span class="keyword">if</span> (LOG) &#123;</div><div class="line">            LogDebug.d(<span class="string">"loadClass"</span>, <span class="string">"isHookingClass("</span> + plugin + <span class="string">" , "</span> + activity + <span class="string">") = "</span></div><div class="line">                    + Factory2.isDynamicClass(plugin, activity));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (Factory2.isDynamicClass(plugin, activity)) &#123;</div><div class="line">            intent.putExtra(IPluginManager.KEY_COMPATIBLE, <span class="keyword">true</span>);</div><div class="line">            intent.setComponent(<span class="keyword">new</span> ComponentName(IPC.getPackageName(), activity));</div><div class="line">            context.startActivity(intent);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果插件状态出现问题，则每次弹此插件的Activity都应提示无法使用，或提示升级（如有新版）</span></div><div class="line">        <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">        <span class="keyword">if</span> (PluginStatusController.getStatus(plugin) &lt; PluginStatusController.STATUS_OK) &#123;</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"PluginLibraryInternalProxy.startActivity(): Plugin Disabled. pn="</span> + plugin);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> RePlugin.getConfig().getCallbacks().onPluginNotExistsForActivity(context, plugin, intent, process);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若为首次加载插件，且是“大插件”，则应异步加载，同时弹窗提示“加载中”</span></div><div class="line">        <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">        <span class="keyword">if</span> (!RePlugin.isPluginDexExtracted(plugin)) &#123;</div><div class="line">            PluginDesc pd = PluginDesc.get(plugin);</div><div class="line">            <span class="keyword">if</span> (pd != <span class="keyword">null</span> &amp;&amp; pd.isLarge()) &#123;</div><div class="line">                <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                    LogDebug.d(PLUGIN_TAG, <span class="string">"PM.startActivity(): Large Plugin! p="</span> + plugin);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> RePlugin.getConfig().getCallbacks().onLoadLargePluginForActivity(context, plugin, intent, process);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// WARNING：千万不要修改intent内容，尤其不要修改其ComponentName</span></div><div class="line">        <span class="comment">// 因为一旦分配坑位有误（或压根不是插件Activity），则外界还需要原封不动的startActivity到系统中</span></div><div class="line">        <span class="comment">// 可防止出现“本来要打开宿主，结果被改成插件”，进而无法打开宿主Activity的问题</span></div><div class="line"></div><div class="line">        <span class="comment">// 缓存打开前的Intent对象，里面将包括Action等内容</span></div><div class="line">        Intent from = <span class="keyword">new</span> Intent(intent);</div><div class="line"></div><div class="line">        <span class="comment">// 帮助填写打开前的Intent的ComponentName信息（如有。没有的情况如直接通过Action打开等）</span></div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(plugin) &amp;&amp; !TextUtils.isEmpty(activity)) &#123;</div><div class="line">            from.setComponent(<span class="keyword">new</span> ComponentName(plugin, activity));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ComponentName cn = mPluginMgr.mLocal.loadPluginActivity(intent, plugin, activity, process);</div><div class="line">        <span class="keyword">if</span> (cn == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"plugin cn not found: intent="</span> + intent + <span class="string">" plugin="</span> + plugin + <span class="string">" activity="</span> + activity + <span class="string">" process="</span> + process);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将Intent指向到“坑位”。这样：</span></div><div class="line">        <span class="comment">// from：插件原Intent</span></div><div class="line">        <span class="comment">// to：坑位Intent</span></div><div class="line">        intent.setComponent(cn);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (LOG) &#123;</div><div class="line">            LogDebug.d(PLUGIN_TAG, <span class="string">"start activity: real intent="</span> + intent);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        context.startActivity(intent);</div><div class="line"></div><div class="line">        <span class="comment">// 通知外界，已准备好要打开Activity了</span></div><div class="line">        <span class="comment">// 其中：from为要打开的插件的Intent，to为坑位Intent</span></div><div class="line">        RePlugin.getConfig().getEventCallbacks().onPrepareStartPitActivity(context, from, intent);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法是最长的一个，主要分如下几个部分来分析:</p>
<p>1)如果插件还未下载，则触发下载回调，让用户决定是否下载;</p>
<p>2)检查这个activity类是否为动态类，这里这个类并不是，所以进入下一个判断;</p>
<p>3)如果插件状态出现问题，则也弹出插件不存在的回调，让用户决定下一步如何做;</p>
<p>4)调用RePlugin.isPluginDexExtracted()来判断当前插件是否已经释放了Dex,Native库等，如果没有，则要提示用户正在加载中;</p>
<p>5)下面调用PluginCommImpl.loadPluginActivity(Intent, String, String, int)的方法，这个方法里面涉及到坑位的分配，这是整个RePlugin中非常核心的一部分，内容也非常多，所以单独在下个小节进行分析。</p>
<h2 id="3-Activity坑位的分配–PluginCommImpl分析"><a href="#3-Activity坑位的分配–PluginCommImpl分析" class="headerlink" title="3.Activity坑位的分配–PluginCommImpl分析"></a>3.Activity坑位的分配–PluginCommImpl分析</h2><p>PluginCommImpl.loadPluginActivity(Intent, String, String, int)方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 加载插件Activity，在startActivity之前调用</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> plugin 插件名</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> target 目标Service名，如果传null，则取获取到的第一个</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> process 是否在指定进程中启动</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ComponentName <span class="title">loadPluginActivity</span><span class="params">(Intent intent, String plugin, String activity, <span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line"></div><div class="line">       ActivityInfo ai = <span class="keyword">null</span>;</div><div class="line">       String container = <span class="keyword">null</span>;</div><div class="line">       PluginBinderInfo info = <span class="keyword">new</span> PluginBinderInfo(PluginBinderInfo.ACTIVITY_REQUEST);</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获取 ActivityInfo(可能是其它插件的 Activity，所以这里使用 pair 将 pluginName 也返回)</span></div><div class="line">           ai = getActivityInfo(plugin, activity, intent);</div><div class="line">           <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                   LogDebug.d(PLUGIN_TAG, <span class="string">"PACM: bindActivity: activity not found"</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 存储此 Activity 在插件 Manifest 中声明主题到 Intent</span></div><div class="line">           intent.putExtra(INTENT_KEY_THEME_ID, ai.theme);</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.d(<span class="string">"theme"</span>, String.format(<span class="string">"intent.putExtra(%s, %s);"</span>, ai.name, ai.theme));</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 根据 activity 的 processName，选择进程 ID 标识</span></div><div class="line">           <span class="keyword">if</span> (ai.processName != <span class="keyword">null</span>) &#123;</div><div class="line">               process = PluginClientHelper.getProcessInt(ai.processName);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 容器选择（启动目标进程）</span></div><div class="line">           IPluginClient client = MP.startPluginProcess(plugin, process, info);</div><div class="line">           <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 远程分配坑位</span></div><div class="line">           container = client.allocActivityContainer(plugin, process, ai.name, intent);</div><div class="line">           <span class="keyword">if</span> (LOG) &#123;</div><div class="line">               LogDebug.i(PLUGIN_TAG, <span class="string">"alloc success: container="</span> + container + <span class="string">" plugin="</span> + plugin + <span class="string">" activity="</span> + activity);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           <span class="keyword">if</span> (LOGR) &#123;</div><div class="line">               LogRelease.e(PLUGIN_TAG, <span class="string">"l.p.a spp|aac: "</span> + e.getMessage(), e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 分配失败</span></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(container)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       PmBase.cleanIntentPluginParams(intent);</div><div class="line"></div><div class="line">       PluginIntent ii = <span class="keyword">new</span> PluginIntent(intent);</div><div class="line">       ii.setPlugin(plugin);</div><div class="line">       ii.setActivity(ai.name);</div><div class="line">       ii.setProcess(IPluginManager.PROCESS_AUTO);</div><div class="line">       ii.setContainer(container);</div><div class="line">       ii.setCounter(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(IPC.getPackageName(), container);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法主要分为如下几个部分。</p>
<h3 id="3-1-Activity信息的获取"><a href="#3-1-Activity信息的获取" class="headerlink" title="3.1 Activity信息的获取"></a>3.1 Activity信息的获取</h3><p>PluginCommImpl.getActivityInfo(String,String,Intent)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 根据条件，查找 ActivityInfo 对象</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> plugin   插件名称</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> activity Activity 名称</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent   调用者传递过来的 Intent</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 插件中 Activity 的 ActivityInfo</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ActivityInfo <span class="title">getActivityInfo</span><span class="params">(String plugin, String activity, Intent intent)</span> </span>&#123;</div><div class="line">       <span class="comment">// 获取插件对象</span></div><div class="line">       Plugin p = mPluginMgr.loadAppPlugin(plugin);</div><div class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ActivityInfo ai = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       <span class="comment">// activity 不为空时，从插件声明的 Activity 集合中查找</span></div><div class="line">       <span class="keyword">if</span> (!TextUtils.isEmpty(activity)) &#123;</div><div class="line">           ai = p.mLoader.mComponents.getActivity(activity);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// activity 为空时，根据 Intent 匹配</span></div><div class="line">           ai = IntentMatcherHelper.getActivityInfo(mContext, plugin, intent);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> ai;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法的逻辑很简单，就是先加载插件，然后从插件的组件信息中获取ActivityInfo对象。可见，重点在于PmBase.loadAppPlugin(String)的调用, 从这个方法开始，涉及到插件的加载和安装的问题，请看<a href="http://blog.imallen.wang/2017/12/08/RePlugin%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">RePlugin解析之插件的安装与加载</a>。</p>
<p>在插件安装完成并加载到内存之后，这里分两种情况:</p>
<p>1)activity信息不为空，调用ComponentList.getActivity()方法来获取ActivityInfo,如果看了请看<a href="http://blog.imallen.wang/2017/12/08/RePlugin%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">RePlugin解析之插件的安装与加载</a>这篇文章的话，就会知道ComponentList中含有插件中所有四大组件的信息，所以要从ComponentList中获取;</p>
<p>2)<strong>activity信息为空，那自然就要根据intent-filter信息来进行匹配了</strong>。其中IntentMatchHelper.getActivityInfo()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityInfo <span class="title">getActivityInfo</span><span class="params">(Context context, String plugin, Intent intent)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (plugin == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String activity = doMatchIntent(context, intent, ManifestParser.INS.getActivityFilterMap(plugin));</div><div class="line">       <span class="keyword">return</span> Factory.queryActivityInfo(plugin, activity);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其中doMatchIntent()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doMatchIntent</span><span class="params">(Context context, Intent intent, Map&lt;String, List&lt;IntentFilter&gt;&gt; filtersMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (filtersMap == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> String action = intent.getAction();</div><div class="line">        <span class="keyword">final</span> String type = intent.resolveTypeIfNeeded(context.getContentResolver());</div><div class="line">        <span class="keyword">final</span> Uri data = intent.getData();</div><div class="line">        <span class="keyword">final</span> String scheme = intent.getScheme();</div><div class="line">        <span class="keyword">final</span> Set&lt;String&gt; categories = intent.getCategories();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;IntentFilter&gt;&gt; entry : filtersMap.entrySet()) &#123;</div><div class="line">            String pluginName = entry.getKey();</div><div class="line">            List&lt;IntentFilter&gt; filters = entry.getValue();</div><div class="line">            <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (IntentFilter filter : filters) &#123;</div><div class="line">                <span class="keyword">int</span> match = filter.match(action, type, scheme, data, categories, <span class="string">"ComponentList"</span>);</div><div class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    ...</div><div class="line">                    <span class="keyword">return</span> pluginName;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                        String reason;</div><div class="line">                        <span class="keyword">switch</span> (match) &#123;</div><div class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_ACTION:</div><div class="line">                                reason = <span class="string">"action"</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_CATEGORY:</div><div class="line">                                reason = <span class="string">"category"</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_DATA:</div><div class="line">                                reason = <span class="string">"data"</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_TYPE:</div><div class="line">                                reason = <span class="string">"type"</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            <span class="keyword">default</span>:</div><div class="line">                                reason = <span class="string">"unknown reason"</span>;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        LogDebug.d(TAG, <span class="string">"  Filter did not match: "</span> + reason);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意传递到doMatchIntent中的第有一个参数为ManifestParser.INS.getActivityFilterMap(),而在<a href="http://blog.imallen.wang/2017/12/08/RePlugin%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">RePlugin解析之插件的安装与加载</a>一文中已经分析过，ManifestParser这个类就是解析插件的Manifest文件，并且会收集所有组件的intent-filter信息，其中getActivityFilterMap()返回的就是对应插件中所有Activity的intent-filter信息。</p>
<p>之后首先解析出Intent的action, type, data, scheme, categories, 然后调用IntentFilter.match()方法进行匹配，如果匹配成功则返回组件名称。</p>
<p>这里值得吐槽的有两点:</p>
<ul>
<li>命名极不规范，pluginName其实应该命名为pluginComponentName,即插件中组件的名称</li>
<li>匹配效率太低，目前这样是要逐一遍历插件中所有对应组件(比如如果是Activity的话就要遍历所有Activity的intent-filter)的intent-filter信息，如果组件多的话效率会有点低</li>
</ul>
<h3 id="3-2-分配pid"><a href="#3-2-分配pid" class="headerlink" title="3.2 分配pid"></a>3.2 分配pid</h3><p>再回到PluginCommImpl.loadPluginActivity()方法中，在获取到ActivityInfo之后，主要有如下语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 存储此 Activity 在插件 Manifest 中声明主题到 Intent</span></div><div class="line">           intent.putExtra(INTENT_KEY_THEME_ID, ai.theme);</div><div class="line">           ...</div><div class="line">           <span class="comment">// 根据 activity 的 processName，选择进程 ID 标识,processName类似"com.qihoo360.replugin.sample.demo1"</span></div><div class="line">           <span class="keyword">if</span> (ai.processName != <span class="keyword">null</span>) &#123;</div><div class="line">               process = PluginClientHelper.getProcessInt(ai.processName);  <span class="comment">//process一般为-1,-1代表PROCESS_UI,即UI进程</span></div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>第一句是将ActivityInfo中的theme放入到Intent中，第二句是调用PluginClientHelper.getProcessInt()获取进程id。这里有两个地方需要解决，首先是ActivityInfo的processName是什么时候赋值的呢?</p>
<p>其实就是在ComponentList的构造方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComponentList</span><span class="params">(PackageInfo pi, String path, PluginInfo pli)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pi.activities != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (ActivityInfo ai : pi.activities) &#123;</div><div class="line">                ...</div><div class="line">                ai.applicationInfo.sourceDir = path;</div><div class="line">                <span class="comment">// todo extract to function</span></div><div class="line">                <span class="keyword">if</span> (ai.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ai.processName = ai.applicationInfo.processName;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (ai.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ai.processName = ai.packageName;</div><div class="line">                &#125;</div><div class="line">                mActivities.put(ai.name, ai);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pi.providers != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (ProviderInfo ppi : pi.providers) &#123;</div><div class="line">                ...</div><div class="line">                <span class="keyword">if</span> (ppi.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ppi.processName = ppi.applicationInfo.processName;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (ppi.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ppi.processName = ppi.packageName;</div><div class="line">                &#125;</div><div class="line">                mProvidersByName.put(ppi.name, ppi);</div><div class="line">                mProvidersByAuthority.put(ppi.authority, ppi);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pi.services != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (ServiceInfo si : pi.services) &#123;</div><div class="line">                ...</div><div class="line">                <span class="keyword">if</span> (si.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    si.processName = si.applicationInfo.processName;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (si.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    si.processName = si.packageName;</div><div class="line">                &#125;</div><div class="line">                mServices.put(si.name, si);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pi.receivers != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (ActivityInfo ri : pi.receivers) &#123;</div><div class="line">                ...</div><div class="line">                <span class="keyword">if</span> (ri.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ri.processName = ri.applicationInfo.processName;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (ri.processName == <span class="keyword">null</span>) &#123;</div><div class="line">                    ri.processName = ri.packageName;</div><div class="line">                &#125;</div><div class="line">                mReceivers.put(ri.name, ri);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然，对于在Manifest中没有process属性的组件，将其processName全部设置为插件的包名，比如“com.qihoo360.replugin.sample.demo1”这样的，然后看一下PluginClientHelper.getProcessInt()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据进程名称获取进程ID</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> processName 进程名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getProcessInt</span><span class="params">(String processName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(processName)) &#123;</div><div class="line">            <span class="comment">// 插件若想将组件定义成在"常驻进程"中运行，则可以在android:process中定义：</span></div><div class="line"></div><div class="line">            <span class="comment">// 1. （推荐）":GuardService"。这样无论宿主的常驻进程名是什么，都会定向到"常驻进程"</span></div><div class="line">            String pntl = processName.toLowerCase();</div><div class="line">            String ppdntl = HostConfigHelper.PERSISTENT_NAME.toLowerCase();</div><div class="line">            <span class="keyword">if</span> (pntl.contains(ppdntl)) &#123;</div><div class="line">                <span class="keyword">return</span> IPluginManager.PROCESS_PERSIST;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 2. 和宿主常驻进程名相同，这样也会定向到"常驻进程"，但若移植到其它宿主上则会出现问题</span></div><div class="line">            String ppntl = IPC.getPersistentProcessName().toLowerCase();</div><div class="line">            <span class="keyword">if</span> (TextUtils.equals(pntl, ppntl)) &#123;</div><div class="line">                <span class="keyword">return</span> IPluginManager.PROCESS_PERSIST;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 3. 用户自定义进程时，从 Map 中取数据</span></div><div class="line">            <span class="comment">// (根据冒号之后的名称来判断是否是自定义进程)</span></div><div class="line">            processName = PluginProcessHost.processTail(processName.toLowerCase());</div><div class="line">            <span class="keyword">if</span> (PROCESS_INT_MAP.containsKey(processName)) &#123;</div><div class="line">                <span class="keyword">return</span> PROCESS_INT_MAP.get(processName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> IPluginManager.PROCESS_UI;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码中的注释都写得很清楚了，对于进程名含有”:guardservice”或者和宿主常驻进程名(如”me.ele.repluginhostsample:guardservice”)相同的，分配的pid就是IPluginManager.PROCESS_PERSIST(值为-2)，对于用户自定义的进程，则从PROCESS_INT_MAP中分配，比如对于demo1这个插件，有如下映射关系:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"process_map"</span></span></div><div class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"[</span></span></div><div class="line"><span class="tag"><span class="string">            &#123;'from':'com.qihoo360.replugin.sample.demo1:bg','to':'$p0'&#125;</span></span></div><div class="line"><span class="tag"><span class="string">            ]"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>那么由于PROCESS_INT_MAP中含有”:p0”这样的key,那么给它分配的pid就是PROCESS_INIT+0,即-100+0.</p>
<p>需要注意的是，这里的pid并不是真正组件进程的pid !</p>
<p>至于这个分配的pid有什么用，在下一小节会分析。</p>
<h3 id="3-3-插件中组件进程启动"><a href="#3-3-插件中组件进程启动" class="headerlink" title="3.3 插件中组件进程启动"></a>3.3 插件中组件进程启动</h3><p>在获取到pid之后，调用MP.startPluginProcess()来启动插件进程，其实这里确切地说是启动插件中组件的进程，因为插件在之前启动时运行在宿主的UI进程中，这里其实是对于那些有自定义进程需求的组件服务的。MP.startPluginProcess()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IPluginClient <span class="title">startPluginProcess</span><span class="params">(String plugin, <span class="keyword">int</span> process, PluginBinderInfo info)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        <span class="keyword">return</span> PluginProcessMain.getPluginHost().startPluginProcess(plugin, process, info);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里startPluginProcess()是一个IPC调用，那么重点就在于PluginProcessMain.getPluginHost()这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IPluginHost <span class="title">getPluginHost</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sPluginHostLocal != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> sPluginHostLocal;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 可能是第一次，或者常驻进程退出了</span></div><div class="line">        <span class="keyword">if</span> (sPluginHostRemote == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (LogDebug.LOG) &#123;</div><div class="line">                <span class="keyword">if</span> (IPC.isPersistentProcess()) &#123;</div><div class="line">                    LogDebug.e(PLUGIN_TAG, <span class="string">"插件框架未正常初始化"</span>);</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"插件框架未正常初始化"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 再次唤起常驻进程</span></div><div class="line">            connectToHostSvc();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sPluginHostRemote;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>为了理解这个方法，我们需要先看一下sPluginHostLocal和sPluginHostRemote是怎么来的。</p>
<h4 id="3-3-1-sPluginHostLocal是什么"><a href="#3-3-1-sPluginHostLocal是什么" class="headerlink" title="3.3.1 sPluginHostLocal是什么"></a>3.3.1 sPluginHostLocal是什么</h4><p>sPluginHostLocal的赋值就只有一个地方，那就是PluginProcessMain.installHost()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installHost</span><span class="params">(IPluginHost host)</span> </span>&#123;</div><div class="line">        sPluginHostLocal = host;</div><div class="line">        <span class="comment">// 连接到插件化管理器的服务端</span></div><div class="line">        <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PluginManagerProxy.connectToServer(sPluginHostLocal);</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="comment">// 基本不太可能到这里，直接打出日志</span></div><div class="line">            <span class="keyword">if</span> (LOGR) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而这个方法的调用是在PmBase.initForServer()中，而<strong>initForServer()是在插件的常驻进程(对于HostConfigHelper.PERSISTENT_ENABLE为true,即允许常驻进程作为插件管理时)，或者UI进程(此时插件的管理就在UI进程中)</strong>。所以总结起来就是initForServer()是在插件的管理进程中被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initForServer</span><span class="params">()</span> </span>&#123;</div><div class="line">       ...</div><div class="line">       mHostSvc = <span class="keyword">new</span> PmHostSvc(mContext, <span class="keyword">this</span>);</div><div class="line">       PluginProcessMain.installHost(mHostSvc);</div><div class="line">       PluginProcessMain.schedulePluginProcessLoop(PluginProcessMain.CHECK_STAGE1_DELAY);</div><div class="line"></div><div class="line">       <span class="comment">// 兼容即将废弃的p-n方案 by Jiongxuan Zhang</span></div><div class="line">       mAll = <span class="keyword">new</span> Builder.PxAll();</div><div class="line">       Builder.builder(mContext, mAll);</div><div class="line">       refreshPluginMap(mAll.getPlugins());</div><div class="line"></div><div class="line">       <span class="comment">// [Newest!] 使用全新的RePlugin APK方案</span></div><div class="line">       <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           List&lt;PluginInfo&gt; l = PluginManagerProxy.load();</div><div class="line">           <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// 将"纯APK"插件信息并入总的插件信息表中，方便查询</span></div><div class="line">               <span class="comment">// 这里有可能会覆盖之前在p-n中加入的信息。本来我们就想这么干，以"纯APK"插件为准</span></div><div class="line">               refreshPluginMap(l);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到其实就是创建了一个PmHostSvc对象然后传递给PluginProcessMain.installHost()方法，那么PmHostSvc到底是什么呢?</p>
<p>看看它继承自什么就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PmHostSvc</span> <span class="keyword">extends</span> <span class="title">IPluginHost</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，PmHostSvc其实是实现了IPluginHost接口IPC调用的Server端的功能。</p>
<p>IPluginHost是一个非常重要的IPC接口，下面列一下它的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPluginHost</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installBinder</span><span class="params">(String name, in IBinder binder)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">IBinder <span class="title">fetchBinder</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fetchPersistentCookie</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">IPluginClient <span class="title">startPluginProcess</span><span class="params">(String plugin, <span class="keyword">int</span> process, inout PluginBinderInfo info)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">attachPluginProcess</span><span class="params">(String process, <span class="keyword">int</span> index, in IBinder binder, String def)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;PluginInfo&gt; <span class="title">listPlugins</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">regActivity</span><span class="params">(<span class="keyword">int</span> index, String plugin, String container, String activity)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregActivity</span><span class="params">(<span class="keyword">int</span> index, String plugin, String container, String activity)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">regService</span><span class="params">(<span class="keyword">int</span> index, String plugin, String service)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregService</span><span class="params">(<span class="keyword">int</span> index, String plugin, String service)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">regPluginBinder</span><span class="params">(in PluginBinderInfo info, IBinder binder)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregPluginBinder</span><span class="params">(in PluginBinderInfo info, IBinder binder)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 注册某插件下所有静态声明的的 receiver 到常驻进程</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">regReceiver</span><span class="params">(String plugin, in Map receiverFilterMap)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregReceiver</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 插件收到广播</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin 插件名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> receiver Receiver 名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> Intent 广播的 Intent 数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(String plugin, String receiver, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumBinders</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updatePluginInfo</span><span class="params">(in PluginInfo info)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">PluginInfo <span class="title">pluginDownloaded</span><span class="params">(String path)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">pluginUninstalled</span><span class="params">(in PluginInfo info)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">pluginExtracted</span><span class="params">(String path)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">sendIntent2Process</span><span class="params">(String target, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">sendIntent2Plugin</span><span class="params">(String target, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendIntent2ProcessSync</span><span class="params">(String target, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendIntent2PluginSync</span><span class="params">(String target, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isProcessAlive</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">IBinder <span class="title">queryPluginBinder</span><span class="params">(String plugin, String binder)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据 Inent 查询所有插件中的与之匹配的 Receivers</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List <span class="title">queryPluginsReceiverList</span><span class="params">(in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取“全新Service管理方案”在Server端的服务</span></div><div class="line"><span class="comment">     * Added by Jiongxuan Zhang</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">IPluginServiceServer <span class="title">fetchServiceServer</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取 IPluginManagerServer（纯APK方案使用）的插件服务</span></div><div class="line"><span class="comment">     * Added by Jiongxuan Zhang</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">IPluginManagerServer <span class="title">fetchManagerServer</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据 taskAffinity，判断应该取第几组 TaskAffinity</span></div><div class="line"><span class="comment">     * 由于 taskAffinity 是跨进程的属性，所以这里要将 taskAffinityGroup 的数据保存在常驻进程中</span></div><div class="line"><span class="comment">     * Added by hujunjie</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTaskAffinityGroupIndex</span><span class="params">(String taskAffinity)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过进程名来获取PID</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPidByProcessName</span><span class="params">(String processName)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过PID来获取进程名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getProcessNameByPid</span><span class="params">(<span class="keyword">int</span> pid)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * dump详细的运行时信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">dump</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，这些方法都是与插件管理有关的。</p>
<p><strong>需要注意的是:只有在插件管理进程中的PluginProcessMain对象(PluginProcessMain只是封装了一些跨进程操作，它会在常驻进程和其他进程中被用到)中sPluginHostLocal才不会为null, 对于在其他进程中的PluginProcessMain对象，其installHost()方法并不会被调用，从而sPluginHostLocal为null. 此时，就需要sPluginHostRemote出场了! </strong></p>
<h4 id="3-3-2-sPluginHostRemote的作用-以及ContentProvider的巧妙运用"><a href="#3-3-2-sPluginHostRemote的作用-以及ContentProvider的巧妙运用" class="headerlink" title="3.3.2 sPluginHostRemote的作用,以及ContentProvider的巧妙运用"></a>3.3.2 sPluginHostRemote的作用,以及ContentProvider的巧妙运用</h4><p>其实sPluginHostRemote是IPluginHost接口的代理，它是在connectToHostSvc()中被赋值的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 非常驻进程调用，获取常驻进程的 IPluginHost</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connectToHostSvc</span><span class="params">()</span> </span>&#123;</div><div class="line">        Context context = PMF.getApplicationContext();</div><div class="line">        <span class="comment">//</span></div><div class="line">        IBinder binder = PluginProviderStub.proxyFetchHostBinder(context);</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (binder == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 无法连接到常驻进程，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            binder.linkToDeath(<span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">                    ...</div><div class="line">                    <span class="comment">// 检测到常驻进程退出，插件进程自杀</span></div><div class="line">                    <span class="keyword">if</span> (PluginManager.isPluginProcess()) &#123;</div><div class="line">                        ...</div><div class="line">                        System.exit(<span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                    sPluginHostRemote = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="comment">// 断开和插件化管理器服务端的连接，因为已经失效</span></div><div class="line">                    PluginManagerProxy.disconnect();</div><div class="line">                &#125;</div><div class="line">            &#125;, <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="comment">// 无法连接到常驻进程，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        sPluginHostRemote = IPluginHost.Stub.asInterface(binder);</div><div class="line">        ... </div><div class="line"></div><div class="line">        <span class="comment">// 连接到插件化管理器的服务端</span></div><div class="line">        <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PluginManagerProxy.connectToServer(sPluginHostRemote);</div><div class="line"></div><div class="line">            <span class="comment">// 将当前进程的"正在运行"列表和常驻做同步</span></div><div class="line">            <span class="comment">// TODO 若常驻进程重启，则应在启动时发送广播，各存活着的进程调用该方法来同步</span></div><div class="line">            PluginManagerProxy.syncRunningPlugins();</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="comment">// 获取PluginManagerServer时出现问题，可能常驻进程突然挂掉等，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 注册该进程信息到“插件管理进程”中</span></div><div class="line">        PMF.sPluginMgr.attach();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法做了很多事情，主要分为如下几点:</p>
<ul>
<li>首先是PluginProviderStub.proxyFetchHostBinder()的作用。从后面IPluginHost.Stub.asInterface(binder)这个语句可知这里获取到的是与插件管理进程中IPluginHost的server通信的IBinder对象, 那么<strong>为什么它能同步获取到IBinder呢</strong>？一般不是都要通过bindService()这样的异步操作来获取吗？</li>
</ul>
<p>​       这里其实RePlugin采用了ContentProvider的一个特性，那就是ContentResolver().query()时返回Cursor,将IBinder包裹在Cursor中即可。见PluginProviderStub.proxyFetchHostBinder()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 此处uri对应的是packagename+".loader.p.main",如"me.ele.repluginhostsample.loader.p.main",对应的是com.qihoo360.replugin.component.process.ProcessPitProviderPersist</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> selection</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IBinder <span class="title">proxyFetchHostBinder</span><span class="params">(Context context, String selection)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        Cursor cursor = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Uri uri = ProcessPitProviderPersist.URI;</div><div class="line">            cursor = context.getContentResolver().query(uri, PROJECTION_MAIN, selection, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (cursor.moveToNext()) &#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">            IBinder binder = BinderCursor.getBinder(cursor);</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span> binder;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            CloseableUtils.closeQuietly(cursor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由于uri为ProcessPitProviderPersist.URI, 所以这个query()方法最终调用到ProcessPitProviderPersist中的query(),该ContentProvider子类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessPitProviderPersist</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ProcessPitProviderPersist"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY_PREFIX = IPC.getPackageName() + <span class="string">".loader.p.main"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri URI = Uri.parse(<span class="string">"content://"</span> + AUTHORITY_PREFIX + <span class="string">"/main"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sInvoked;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</div><div class="line">        sInvoked = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> PluginProviderStub.stubMain(uri, projection, selection, selectionArgs, sortOrder);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，对于query()回调，会调用PluginProviderStub.stubMain():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cursor <span class="title">stubMain</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (SELECTION_MAIN_BINDER.equals(selection)) &#123;</div><div class="line">            <span class="keyword">return</span> BinderCursor.queryBinder(PMF.sPluginMgr.getHostBinder());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SELECTION_MAIN_PREF.equals(selection)) &#123;</div><div class="line">            <span class="comment">// 需要枷锁否？</span></div><div class="line">            initPref();</div><div class="line">            <span class="keyword">return</span> BinderCursor.queryBinder(sPrefImpl);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此处我们的selection是SELECTION_MAIN_BINDER,所以返回的是BinderCursor.queryBinder(PMF.sPluginMgr.getHostBinder()), 该方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cursor <span class="title">queryBinder</span><span class="params">(IBinder binder)</span> </span>&#123;</div><div class="line">       ...</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> BinderCursor(PluginInfo.QUERY_COLUMNS, binder);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可见就是将IBinder传递进去，然后使用BinderCursor包裹，那这里的关键是PMF.sPluginMrg.getHostBinder()怎么就拿到了IPluginHost的server端的IBinder?</p>
<p><strong>其实答案很简单! 因为ProcessPitProviderPersist这个ContentProvider跟插件管理进程在同一个进程中，它是被gradle插件打入到Manifest文件中的</strong>，最终效果如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.qihoo360.replugin.component.process.ProcessPitProviderPersist"</span></span></div><div class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></div><div class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":GuardService"</span></span></div><div class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"me.ele.repluginhostsample.loader.p.main"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>而PMF.sPluginMrg.getHostBinder()会调用到PmBase.getHostBinder(), 而其中的mHostSvc的创建在前面已经提到过了，这里不再赘述了。</p>
<p>拿到IBinder之后，就可以调用IPluginHost.Stub.asInterface()拿到IPluginHost的代理了，之后调用PluginManagerProxy.connectToServer()其实就是通过这个代理对象拿到IPluginManagerServer的代理。我们看一下PmHostSvc中fetchManagerServer()的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IPluginManagerServer <span class="title">fetchManagerServer</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">       <span class="keyword">return</span> mManager.getService();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>只是调用PluginManagerServer.getService()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> IPluginManagerServer <span class="title">getService</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> mStub;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>而Stub对象mStub其实是实现了继承自IPluginManagerServer.Stub,代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">IPluginManagerServer</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> PluginInfo <span class="title">install</span><span class="params">(String path)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.installLocked(path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;PluginInfo&gt; <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.loadLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;PluginInfo&gt; <span class="title">updateAll</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.updateAllLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUsed</span><span class="params">(String pluginName, <span class="keyword">boolean</span> used)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                PluginManagerServer.<span class="keyword">this</span>.updateUsedLocked(pluginName, used);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uninstall</span><span class="params">(PluginInfo info)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.uninstallLocked(info);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> PluginRunningList <span class="title">getRunningPlugins</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.getRunningPluginsLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPluginRunning</span><span class="params">(String pluginName, String process)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.isPluginRunningLocked(pluginName, process);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncRunningPlugins</span><span class="params">(PluginRunningList list)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                PluginManagerServer.<span class="keyword">this</span>.syncRunningPluginsLocked(list);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToRunningPlugins</span><span class="params">(String processName, <span class="keyword">int</span> pid, String pluginName)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                PluginManagerServer.<span class="keyword">this</span>.addToRunningPluginsLocked(processName, pid, pluginName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> String[] getRunningProcessesByPlugin(String pluginName) <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">            <span class="keyword">synchronized</span> (LOCKER) &#123;</div><div class="line">                <span class="keyword">return</span> PluginManagerServer.<span class="keyword">this</span>.getRunningProcessesByPluginLocked(pluginName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>需要注意的是IPluginManagerServer与IPluginHost的区别:IPluginHost其实更多的是为了起一个通信支撑的作用，有了它之后才能使插件，宿主进行通信，但它本身几乎没有涉及到插件业务，而IPluginManagerServer则是真正地实现插件管理，利用它来控制插件的安装、卸载、获取等，它们的相同之处则在于server端都运行在常驻进程中。</p>
<p>其实从IPluginManagerServer的aidl接口定义也可见一斑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPluginManagerServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 安装一个插件</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 注意：若为旧插件（p-n开头），则应使用IPluginHost的pluginDownloaded方法</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 安装的插件的PluginInfo对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">PluginInfo <span class="title">install</span><span class="params">(String path)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 卸载一个插件</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 注意：只针对“纯APK”插件方案</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> info 插件信息</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功卸载插件？</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">uninstall</span><span class="params">(in PluginInfo info)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 加载插件列表，方便之后使用</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * TODO 这里只返回"新版插件"，供PmBase使用。将来会合并</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> PluginInfo的列表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;PluginInfo&gt; <span class="title">load</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 更新所有插件列表</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> PluginInfo的列表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;PluginInfo&gt; <span class="title">updateAll</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置isUsed状态，并通知所有进程更新</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName 插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> used 是否已经使用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUsed</span><span class="params">(String pluginName, <span class="keyword">boolean</span> used)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取正在运行的插件列表</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 正在运行的插件名列表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">PluginRunningList <span class="title">getRunningPlugins</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 插件是否正在运行？</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName 插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> process 指定进程名，如为Null则表示查所有</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在运行？</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPluginRunning</span><span class="params">(String pluginName, String process)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当进程启动时，同步正在运行的插件状态到Server端</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> list         正在运行的插件名列表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncRunningPlugins</span><span class="params">(in PluginRunningList list)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当进程启动时，同步正在运行的插件状态到Server端</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> processName  进程名</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName   正在运行的插件名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToRunningPlugins</span><span class="params">(String processName, <span class="keyword">int</span> pid, String pluginName)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取正在运行此插件的进程名列表</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName 要查询的插件名</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 正在运行此插件的进程名列表。一定不会为Null</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    String[] getRunningProcessesByPlugin(String pluginName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到IPluginManagerServer的功能非常强大，包括安装、卸载插件，加载插件列表，更新插件列表，获取正在运行的插件列表，判断插件是否在运行，同步插件状态，获取正在运行此插件的进程名列表等。</p>
<h4 id="3-3-3-进程分配"><a href="#3-3-3-进程分配" class="headerlink" title="3.3.3 进程分配"></a>3.3.3 进程分配</h4><p>再回到MP.startPluginProcess()方法，可知会通过IPluginHost的代理经过IPC最终调用到PmHostSvc中startPluginProcess()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> IPluginClient <span class="title">startPluginProcess</span><span class="params">(String plugin, <span class="keyword">int</span> process, PluginBinderInfo info)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           <span class="keyword">return</span> mPluginMgr.startPluginProcessLocked(plugin, process, info);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其中mPluginMgr是PmBase对象，PmBase.startPluginProcessLocked()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> IPluginClient <span class="title">startPluginProcessLocked</span><span class="params">(String plugin, <span class="keyword">int</span> process, PluginBinderInfo info)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 强制使用UI进程</span></div><div class="line">    <span class="keyword">if</span> (Constant.ENABLE_PLUGIN_ACTIVITY_AND_BINDER_RUN_IN_MAIN_UI_PROCESS) &#123;</div><div class="line">        <span class="keyword">if</span> (info.request == PluginBinderInfo.ACTIVITY_REQUEST) &#123;</div><div class="line">            <span class="keyword">if</span> (process == IPluginManager.PROCESS_AUTO) &#123;</div><div class="line">                process = IPluginManager.PROCESS_UI;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (info.request == PluginBinderInfo.BINDER_REQUEST) &#123;</div><div class="line">            <span class="keyword">if</span> (process == IPluginManager.PROCESS_AUTO) &#123;</div><div class="line">                process = IPluginManager.PROCESS_UI;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PluginProcessMain.schedulePluginProcessLoop(PluginProcessMain.CHECK_STAGE1_DELAY);</div><div class="line"></div><div class="line">    <span class="comment">// 获取</span></div><div class="line">    IPluginClient client = PluginProcessMain.probePluginClient(plugin, process, info);</div><div class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 分配</span></div><div class="line">    <span class="keyword">int</span> index = IPluginManager.PROCESS_AUTO;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        index = PluginProcessMain.allocProcess(plugin, process);</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 分配的坑位不属于UI、和自定义进程，就返回。</span></div><div class="line">    <span class="keyword">if</span> (!(index == IPluginManager.PROCESS_UI</div><div class="line">            || PluginProcessHost.isCustomPluginProcess(index)</div><div class="line">            || PluginManager.isPluginProcess(index))) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 启动 //KP 注意:在这里才真正地启动插件进程</span></div><div class="line">    <span class="keyword">boolean</span> rc = PluginProviderStub.proxyStartPluginProcess(mContext, index);</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (!rc) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 再次获取</span></div><div class="line">    client = PluginProcessMain.probePluginClient(plugin, process, info);</div><div class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> client;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法比较长，主要分为以下几个部分:</p>
<ul>
<li>首先是PluginBinderInfo对象是在PluginCommImpl中的loadPluginActivity()中创建的，并且只赋予了request的值为ACTIVITY_REQUEST, pid和index为默认值-1</li>
<li>由于Constant.ENABLE_PLUGIN_ACTIVITY_AND_BINDER_RUN_IN_MAIN_UI_PROCESS为true,而且我们这里info.request==PluginBinderInfo.ACTIVITY_REQUEST,不过我们这里process==IPluginManager.PROCESS_UI;如果是process==IPluginManager.PROCESS_AUTO,即自动分配进程的话，那么process也会被赋值IPluginManager.PROCESS_UI;</li>
<li><p>之后调用PluginProcessMain.schedulePluginProcessLoop()是为了循环检查各插件进程，如果发现插件中没有组件在运行了，就收回这个进程。负责检查的task如下:</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPluginProcessLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Constant.SIMPLE_QUIT_CONTROLLER) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">synchronized</span> (PROCESSES) &#123;</div><div class="line">                <span class="keyword">for</span> (ProcessRecord r : PROCESSES) &#123;</div><div class="line">                    <span class="keyword">if</span> (r.state != STATE_RUNNING) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (r.activities &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (r.services &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (r.binders &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    ...</div><div class="line">                    android.os.Process.killProcess(r.pid);</div><div class="line">                    waitKilled(r.pid);</div><div class="line">                    r.setStoped();</div><div class="line">                    <span class="comment">//</span></div><div class="line">                    schedulePluginProcessLoop(CHECK_STAGE3_DELAY);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>显然，这里就是遍历PROCESS，如果发现它不再运行，而且运行的组件和binder都为0了，就回收掉这个进程。需要注意的是这里的ProcessRecord是自定义的，不是android系统的那个ProcessRecord.</p>
<ul>
<li><p>之后调用PluginProcessMain.probePluginClient()方法来获取IPluginClient对象，该方法如下:</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> IPluginClient <span class="title">probePluginClient</span><span class="params">(String plugin, <span class="keyword">int</span> process, PluginBinderInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (PROCESSES) &#123;</div><div class="line">            <span class="keyword">for</span> (ProcessClientRecord r : ALL.values()) &#123;</div><div class="line">                <span class="keyword">if</span> (process == IPluginManager.PROCESS_UI) &#123;</div><div class="line">                    <span class="keyword">if</span> (!TextUtils.equals(r.plugin, Constant.PLUGIN_NAME_UI)) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                <span class="comment">/* 是否是用户自定义进程 */</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PluginProcessHost.isCustomPluginProcess(process)) &#123;</div><div class="line">                    <span class="keyword">if</span> (!TextUtils.equals(r.plugin, getProcessStringByIndex(process))) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!TextUtils.equals(r.plugin, plugin)) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!isBinderAlive(r)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!r.binder.pingBinder()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                info.pid = r.pid;</div><div class="line">                info.index = r.index;</div><div class="line">                <span class="keyword">return</span> r.client;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>这里就是分几种情况:</p>
<ul>
<li>如果process==IPluginManager.PROCESS_UI,那么遇到ProcessClientRecord.plugin与Constants.PLUGIN_NAME_UI相同的情况，就继续查找;</li>
<li>如果是用户自定义进程，并且ProcessClient.plugin和getProcessStringByIndex()不相同时，就继续查找</li>
<li>如果ProcessClientRecord.plugin与plugin相等，那么继续查找</li>
<li>如果发现相应该ProcessRecord的binder都没有活着了，就返回null</li>
<li>如果发现binder都ping不通，也返回null</li>
<li>走到最后的，说明这个插件进程还活着，所以给PluginBinderInfo对象赋值,并且返回ProcessRecord中的IPluginClient对象.</li>
</ul>
<p>而IPluginClient的作用是什么呢?</p>
<p>看下它的aidl定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPluginClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 参数 plugin, process 可能有冗余，目前临时使用，后续可能优化</span></div><div class="line">    <span class="function">String <span class="title">allocActivityContainer</span><span class="params">(String plugin, <span class="keyword">int</span> process, String target, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 参数 plugin 用来处理多插件单进程情况</span></div><div class="line">    <span class="function">IBinder <span class="title">queryBinder</span><span class="params">(String plugin, String binder)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseBinder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">oneway <span class="keyword">void</span> <span class="title">sendIntent</span><span class="params">(in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendIntentSync</span><span class="params">(in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumActivities</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">IPluginServiceServer <span class="title">fetchServiceServer</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 插件收到广播</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> plugin   插件名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> receiver Receiver 名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> Intent   广播的 Intent 数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(String plugin, String receiver, in Intent intent)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * dump通过插件化框架启动起来的Service信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">dumpServices</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * dump插件化框架中存储的详细Activity坑位映射表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">dumpActivities</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到也是用于插件进程与插件管理进程通信的，包括分配容器，接收广播等。这个接口到后面再详细分析。</p>
<p>再回到PmBase.startPluginProcessLocked()方法，如果返回的client不为空就说明<strong>所要求的进程已经启动（比如要发现要启动的进程是UI进程，而宿主UI进程已经启动，所以可直接返回)</strong>，此时当然就没必要再启动进程了。如果返回的client为null, 说明插件还没启动，此时需要先分配进程pid,会调用到PluginProcessMain.allocProcess()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">allocProcess</span><span class="params">(String plugin, <span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (Constant.PLUGIN_NAME_UI.equals(plugin) || process == IPluginManager.PROCESS_UI) &#123;</div><div class="line">          <span class="keyword">return</span> IPluginManager.PROCESS_UI;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (PluginProcessHost.isCustomPluginProcess(process)) &#123;</div><div class="line">          <span class="keyword">return</span> process;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      PluginInfo info = PluginTable.getPluginInfo(plugin);</div><div class="line">      <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line">          ...</div><div class="line">          <span class="keyword">return</span> IPluginManager.PROCESS_AUTO;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">synchronized</span> (PROCESSES) &#123;</div><div class="line">          <span class="keyword">return</span> allocProcessLocked(plugin);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在这里，如果要启动的是UI进程，那么返回IPluginManager.PROCESS_UI;如果是自定义进程(process值在[-100,-100+3)之间)，那么就还是返回process.</p>
<p>下面就到了真正启动插件中组件自定义进程的时刻。</p>
<h4 id="3-3-4-组件自定义进程启动"><a href="#3-3-4-组件自定义进程启动" class="headerlink" title="3.3.4 组件自定义进程启动"></a>3.3.4 组件自定义进程启动</h4><p>回到PmBase.startPluginProcessLocked(), 在调用allocProcess()方法之后，获得了分配的pid,然后调用PluginProviderStub.proxyStartPluginProcess()启动插件中组件的自定义进程(目前写死了自定义进程最多只能有2个)，该方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">proxyStartPluginProcess</span><span class="params">(Context context, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">        values.put(KEY_METHOD, METHOD_START_PROCESS);</div><div class="line">        values.put(KEY_COOKIE, PMF.sPluginMgr.mLocalCookie);</div><div class="line">        Uri uri = context.getContentResolver().insert(ProcessPitProviderBase.buildUri(index), values);</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可见，在这里就是通过调用ContentResolver的insert()方法，最终调用到相应的ContentProvider,然后启动对应的进程。</p>
<p><strong>那么这种映射关系是如何建立的呢？ContentProvider又是何时新建并插入到Manifest文件中的呢？</strong></p>
<p>首先说映射关系，在<a href="http://blog.imallen.wang/2017/12/08/RePlugin%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">RePlugin解析之插件的安装与加载</a>一文中已经提到了这种映射关系是可以由插件自行指定的，比如demo1中有如下映射关系:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"process_map"</span></span></div><div class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"[</span></span></div><div class="line"><span class="tag"><span class="string">            &#123;'from':'com.qihoo360.replugin.sample.demo1:bg','to':'$p0'&#125;</span></span></div><div class="line"><span class="tag"><span class="string">            ]"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>这就意味着com.qihoo360.replugin.sample.demo:bg这个进程要映射到hostpkg:p0这个进程，在编译过程中通过gradle插件会往Manifest中打入进程名为hostpkg:p0的ContentProvider,如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.qihoo360.replugin.component.process.ProcessPitProviderP0"</span></span></div><div class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"false"</span></span></div><div class="line"><span class="tag">          <span class="attr">android:process</span>=<span class="string">":p0"</span></span></div><div class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"me.ele.repluginhostsample.loader.p.mainN100"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>从PluginProviderStub.proxyStartPluginProcess()方法中调用的ProcessPitProviderBase.buildUri()方法也可以看出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri <span class="title">buildUri</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        String str = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">            str += <span class="string">"N"</span>;</div><div class="line">            index *= -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        str += index;</div><div class="line">        Uri uri = Uri.parse(<span class="string">"content://"</span> + AUTHORITY_PREFIX + str + <span class="string">"/main"</span>);</div><div class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</div><div class="line">            Log.d(TAG, <span class="string">"buildUri: uri="</span> + uri);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> uri;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>比如在这里index==-100,所以最终构造出来的uri就是”content://hostpkg.loader.p.mainN100/main”,当hostpkg为”me.ele.repluginhostsample”时就是”content://me.ele.repluginhostsample.loader.p.mainN100/main”,而这恰好就对应刚刚ProcessPitProviderP0的authorities.</strong></p>
<p>到这里，就真正完成了插件中组件自定义进程的启动。</p>
<h4 id="3-3-5-attachProcess"><a href="#3-3-5-attachProcess" class="headerlink" title="3.3.5 attachProcess()"></a>3.3.5 attachProcess()</h4><p>前面提到，启动插件中组件的自定义进程时会调用到ProcessPitProviderBase中的insert()方法，然后调用到PluginProviderStub.stubPlugin()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri <span class="title">stubPlugin</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">      ...</div><div class="line">      String method = values.getAsString(KEY_METHOD);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (TextUtils.equals(method, METHOD_START_PROCESS)) &#123;</div><div class="line">          <span class="comment">//</span></div><div class="line">          Uri rc = <span class="keyword">new</span> Uri.Builder().scheme(<span class="string">"content"</span>).authority(<span class="string">"process"</span>).encodedPath(<span class="string">"status"</span>).encodedQuery(URL_PARAM_KEY_LOADED + <span class="string">"="</span> + <span class="number">1</span>).build();</div><div class="line">          ...</div><div class="line">          <span class="keyword">long</span> cookie = values.getAsLong(KEY_COOKIE);</div><div class="line"></div><div class="line">          <span class="comment">// 首次</span></div><div class="line">          <span class="keyword">if</span> (PMF.sPluginMgr.mLocalCookie == <span class="number">0L</span>) &#123;</div><div class="line">              ...</div><div class="line">              PMF.sPluginMgr.mLocalCookie = cookie;</div><div class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">//只要常驻进程启动了，就会走到这个分支</span></div><div class="line">              <span class="comment">// 常驻进程重新启动了.</span></div><div class="line">              <span class="keyword">if</span> (PMF.sPluginMgr.mLocalCookie != cookie) &#123;</div><div class="line">                  <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                      LogDebug.d(PLUGIN_TAG, <span class="string">"reset cookie: "</span> + cookie);</div><div class="line">                  &#125;</div><div class="line">                  <span class="comment">//</span></div><div class="line">                  PMF.sPluginMgr.mLocalCookie = cookie;</div><div class="line">                  <span class="comment">//</span></div><div class="line">                  PluginProcessMain.connectToHostSvc(); <span class="comment">//这里是向插件管理进程报告自己的进程信息，最终会调用到attachProcess(),然后PluginProcessMain中的ALL就会增加一项ProcessClientRecord记录。</span></div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">return</span> rc;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注释里面已经写得很清楚了，最终会调用到PluginProcessMain.connectToHostSvc()方法，</p>
<p>而PluginProcessMain.connectToHostSvc()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connectToHostSvc</span><span class="params">()</span> </span>&#123;</div><div class="line">        Context context = PMF.getApplicationContext();</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        IBinder binder = PluginProviderStub.proxyFetchHostBinder(context);</div><div class="line">        <span class="keyword">if</span> (LOG) &#123;</div><div class="line">            LogDebug.d(PLUGIN_TAG, <span class="string">"host binder = "</span> + binder);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (binder == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 无法连接到常驻进程，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            binder.linkToDeath(<span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (LOGR) &#123;</div><div class="line">                        LogRelease.i(PLUGIN_TAG, <span class="string">"p.p d, p.h s n"</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 检测到常驻进程退出，插件进程自杀</span></div><div class="line">                    <span class="keyword">if</span> (PluginManager.isPluginProcess()) &#123;</div><div class="line">                        ...</div><div class="line">                        System.exit(<span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                    sPluginHostRemote = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="comment">// 断开和插件化管理器服务端的连接，因为已经失效</span></div><div class="line">                    PluginManagerProxy.disconnect();</div><div class="line">                &#125;</div><div class="line">            &#125;, <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="comment">// 无法连接到常驻进程，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        sPluginHostRemote = IPluginHost.Stub.asInterface(binder);</div><div class="line">        ....</div><div class="line"></div><div class="line">        <span class="comment">// 连接到插件化管理器的服务端</span></div><div class="line">        <span class="comment">// Added by Jiongxuan Zhang</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PluginManagerProxy.connectToServer(sPluginHostRemote);</div><div class="line"></div><div class="line">            <span class="comment">// 将当前进程的"正在运行"列表和常驻做同步</span></div><div class="line">            <span class="comment">// TODO 若常驻进程重启，则应在启动时发送广播，各存活着的进程调用该方法来同步</span></div><div class="line">            PluginManagerProxy.syncRunningPlugins();</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="comment">// 获取PluginManagerServer时出现问题，可能常驻进程突然挂掉等，当前进程自杀</span></div><div class="line">            ...</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 注册该进程信息到“插件管理进程”中</span></div><div class="line">        PMF.sPluginMgr.attach();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法在<a href="http://blog.imallen.wang/2017/12/08/RePlugin%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD/#more" target="_blank" rel="external">RePlugin解析之插件的安装与加载</a>一文中已经分析过了，这里不再赘述。注意最后一个语句，它的作用就是注册该进程到插件管理进程中。</p>
<p>而PmBase.attach()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           mDefaultPluginName = PluginProcessMain.getPluginHost().attachPluginProcess(IPC.getCurrentProcessName(), PluginManager.sPluginProcessIndex, mClient, mDefaultPluginName);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">          ...</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里是通过IPluginHost接口的代理进行IPC，最终调用到插件管理进程的PmHostSvc.attachPluginProcess()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">attachPluginProcess</span><span class="params">(String process, <span class="keyword">int</span> index, IBinder binder, String def)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">       <span class="keyword">int</span> pid = Binder.getCallingPid();</div><div class="line">       IPluginClient client = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           client = IPluginClient.Stub.asInterface(binder); <span class="comment">//可见，对于IPluginClient来说，server端在插件和插件组件中的自定义进程中，而client端在插件管理进程中，所以IPluginClient.Stub的实现PluginProcessPer对象的创建也是在插件进程中</span></div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> PluginProcessMain.attachProcess(pid, process, index, binder, client, def, mManager);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法很简单，就是先获取IPluginClient的代理，然后调用PluginProcessMain.attachProcess()以记录插件进程(确切地说是插件中组件的进程)的信息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">attachProcess</span><span class="params">(<span class="keyword">int</span> pid, String process, <span class="keyword">int</span> index, IBinder binder, IPluginClient client, String def, PluginManagerServer pms)</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (PROCESSES) &#123;</div><div class="line">            String plugin = attachProcessLocked(pid, process, index, binder, client, def);</div><div class="line"></div><div class="line">            ProcessClientRecord pr = <span class="keyword">new</span> ProcessClientRecord(pms);</div><div class="line">            pr.name = process;</div><div class="line">            pr.plugin = plugin;</div><div class="line">            pr.pid = pid;</div><div class="line">            pr.index = index;</div><div class="line">            pr.binder = binder;</div><div class="line">            pr.client = client;</div><div class="line">            ALL.put(process, pr);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                pr.binder.linkToDeath(pr, <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> plugin;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，这个方法很简单，就是先记录插件进程名称，pid, IPluginClient的代理client等，最后将ProcessClientRecord对象放入ALL这个缓存中。</p>
<h3 id="3-4-分配坑位"><a href="#3-4-分配坑位" class="headerlink" title="3.4 分配坑位"></a>3.4 分配坑位</h3><p>到3.3为止，终于完成插件中组件进程的启动了。下面要进行坑位的选择, 会调用IPluginClient.allocActivityContainer()方法进行坑位的选择，注意这里通过IPluginClient的IPC最终会调用到刚刚启动的那个进程(而不是插件管理进程), allocActivityContainer()的真正实现在PluginProcessPer中，方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">allocActivityContainer</span><span class="params">(String plugin, <span class="keyword">int</span> process, String target, Intent intent)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">       <span class="comment">// 一旦有分配，则进入监控状态（一是避免不退出的情况，二也是最重要的是避免现在就退出的情况）</span></div><div class="line">       RePlugin.getConfig().getEventCallbacks().onPrepareAllocPitActivity(intent);</div><div class="line"></div><div class="line">       String loadPlugin = <span class="keyword">null</span>;</div><div class="line">       <span class="comment">// 如果UI进程启用，尝试使用传过来的插件，强制用UI进程</span></div><div class="line">       <span class="keyword">if</span> (Constant.ENABLE_PLUGIN_ACTIVITY_AND_BINDER_RUN_IN_MAIN_UI_PROCESS) &#123;</div><div class="line">           <span class="keyword">if</span> (IPC.isUIProcess()) &#123;</div><div class="line">               loadPlugin = plugin;</div><div class="line">               process = IPluginManager.PROCESS_UI;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               loadPlugin = plugin;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 如果不成，则再次尝试使用默认插件</span></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(loadPlugin)) &#123;</div><div class="line">           <span class="keyword">if</span> (mDefaultPlugin == <span class="keyword">null</span>) &#123;</div><div class="line">               ...</div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line">           loadPlugin = mDefaultPlugin.mInfo.getName();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//</span></div><div class="line">       String container = bindActivity(loadPlugin, process, target, intent);</div><div class="line">       ...</div><div class="line">       <span class="keyword">return</span> container;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法很简单，先是对于 process和loadPlugin参数进行一些处理，然后调用bindActivity()获取到container：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * 加载插件；找到目标Activity；搜索匹配容器；加载目标Activity类；建立临时映射；返回容器</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> plugin   插件名称,类似"demo1"</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> process  进程,默认值为-1</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> activity Activity 名称，类似"com.qihoo360.replugin.sample.demo1.MainActivity"</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> intent   调用者传入的 Intent</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 坑位</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">final</span> String <span class="title">bindActivity</span><span class="params">(String plugin, <span class="keyword">int</span> process, String activity, Intent intent)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="comment">/* 获取插件对象 */</span></div><div class="line">       Plugin p = mPluginMgr.loadAppPlugin(plugin);</div><div class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* 获取 ActivityInfo */</span></div><div class="line">       ActivityInfo ai = p.mLoader.mComponents.getActivity(activity);</div><div class="line">       <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (ai.processName == <span class="keyword">null</span>) &#123;</div><div class="line">           ai.processName = ai.applicationInfo.processName;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (ai.processName == <span class="keyword">null</span>) &#123;</div><div class="line">           ai.processName = ai.packageName;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* 获取 Container */</span></div><div class="line">       String container;</div><div class="line"></div><div class="line">       <span class="comment">// 自定义进程,如果带有":p"的就是自定义进程</span></div><div class="line">       <span class="keyword">if</span> (ai.processName.contains(PluginProcessHost.PROCESS_PLUGIN_SUFFIX2)) &#123;</div><div class="line">           String processTail = PluginProcessHost.processTail(ai.processName);</div><div class="line">           container = mACM.alloc2(ai, plugin, activity, process, intent, processTail);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           container = mACM.alloc(ai, plugin, activity, process, intent);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(container)) &#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       ... </div><div class="line">       <span class="comment">/* 检查 activity 是否存在 */</span></div><div class="line">       Class&lt;?&gt; c = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           c = p.mLoader.mClassLoader.loadClass(activity);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           ...</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">           ...</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> container;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>前面获取Plugin对象和ActivityInfo对象就不说了，就说最关键的部分，如果ActivityInfo中的进程名称包含”:p”，那么就意味着是自定义进程，就调用PluginContainers.alloc2()方法(吐槽一下这个方法命名真垃圾),否则调用PluginContainers.alloc()方法。</p>
<p>先来看PluginContainers.alloc2()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">alloc2</span><span class="params">(ActivityInfo ai, String plugin, String activity, <span class="keyword">int</span> process, Intent intent, String processTail)</span> </span>&#123;</div><div class="line">       <span class="comment">// 根据进程名称，取得该进程对应的 PluginContainerStates</span></div><div class="line">       ProcessStates states = mProcessStatesMap.get(processTail);</div><div class="line"></div><div class="line">       ActivityState state;</div><div class="line"></div><div class="line">       String defaultPluginTaskAffinity = ai.applicationInfo.packageName;</div><div class="line">       ...</div><div class="line">       <span class="comment">/* SingleInstance */</span></div><div class="line">       <span class="keyword">if</span> (ai.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">               state = allocLocked(ai, states.mLaunchModeStates.getStates(ai.launchMode, ai.theme), plugin, activity, intent);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* TaskAffinity */</span></div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!defaultPluginTaskAffinity.equals(ai.taskAffinity)) &#123; <span class="comment">// 非默认 taskAffinity</span></div><div class="line">           <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">               state = allocLocked(ai, states.mTaskAffinityStates.getStates(ai), plugin, activity, intent);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* other mode */</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">               state = allocLocked(ai, states.mLaunchModeStates.getStates(ai.launchMode, ai.theme), plugin, activity, intent);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> state.container;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到会分三种情况，一种是launchMode是LAUNCH_SINGLE_INSTANCE, 还有一种是带有taskAffinity, 最后一种是其他。</p>
<p>这三种情况都是调用allocLocked()方法进行坑位的分配，唯一的不同就是第2个参数。</p>
<ul>
<li>第一种情况是states.mLaunchModeStates.getStates(ai.launchMode, ai.theme)</li>
<li>第二种情况是states.mTaskAffinityStates.getStates(ai)</li>
<li>第三种是states.mLaunchModeStates.getStates(ai.launchMode, ai.theme), 这其实是最普遍的情形</li>
</ul>
<p>为了分析清楚是如何分配的，我们需要先看一下ProcessStates, TaskAffinityStates以及LaunchModeStates是什么，以及它们是如何被初始化的。</p>
<h4 id="3-4-1-ProcessStates的定义"><a href="#3-4-1-ProcessStates的定义" class="headerlink" title="3.4.1 ProcessStates的定义"></a>3.4.1 ProcessStates的定义</h4><p>ProcessStates的定义很简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 保存自定义进程中，每个进程里的坑位信息</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> RePlugin Team</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessStates</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 保存非默认 TaskAffinity 下，坑位的状态信息。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TaskAffinityStates mTaskAffinityStates = <span class="keyword">new</span> TaskAffinityStates();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 保存默认 TaskAffinity 下，坑位的状态信息。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    LaunchModeStates mLaunchModeStates = <span class="keyword">new</span> LaunchModeStates();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-4-2-LaunchModeStates"><a href="#3-4-2-LaunchModeStates" class="headerlink" title="3.4.2 LaunchModeStates"></a>3.4.2 LaunchModeStates</h4><p>LaunchModeStates的定义其实也很简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaunchModeStates</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"launchMode"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 目前的策略是，针对每一种 launchMode 分配两种坑位（透明主题(TS)和不透明主题(NTS)）</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 例：透明主题</span></div><div class="line"><span class="comment">     * 　　　　　　　&lt;N1NRTS0, ActivityState&gt;</span></div><div class="line"><span class="comment">     * NR + TS  - &gt; &lt;N1NRTS1, ActivityState&gt;</span></div><div class="line"><span class="comment">     * 　　　　　　　&lt;N1NRTS2, ActivityState&gt;</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 例：不透明主题</span></div><div class="line"><span class="comment">     * 　　　　　　　&lt;N1NRNTS0, ActivityState&gt;</span></div><div class="line"><span class="comment">     * NR + NTS - &gt; &lt;N1NRNTS1, ActivityState&gt;</span></div><div class="line"><span class="comment">     * 　　　　　　　&lt;N1NRNTS2, ActivityState&gt;</span></div><div class="line"><span class="comment">     * &lt;p&gt;</span></div><div class="line"><span class="comment">     * 其中：N1 表示当前为 UI 进程，NR 表示 launchMode 为 Standard，NTS 表示坑的 theme 为 Not Translucent。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, HashMap&lt;String, ActivityState&gt;&gt; mStates = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化 LaunchMode 和 Theme 对应的坑位</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> containers  保存所有 activity 坑位的引用</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> prefix      坑位前缀</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> launchMode  launchMode</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> translucent 是否是透明的坑</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> count       坑位数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStates</span><span class="params">(Map&lt;String, ActivityState&gt; allStates, HashSet&lt;String&gt; containers, String prefix, <span class="keyword">int</span> launchMode, <span class="keyword">boolean</span> translucent, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        String infix = getInfix(launchMode, translucent);</div><div class="line">        HashMap&lt;String, ActivityState&gt; states = mStates.get(infix);</div><div class="line">        <span class="keyword">if</span> (states == <span class="keyword">null</span>) &#123;</div><div class="line">            states = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            mStates.put(infix, states);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            String key = prefix + infix + i;</div><div class="line"></div><div class="line">            <span class="comment">// 只有开启“详细日志”时才输出每一个坑位的信息，防止刷屏</span></div><div class="line">            <span class="keyword">if</span> (RePlugin.getConfig().isPrintDetailLog()) &#123;</div><div class="line">                LogDebug.d(TAG, <span class="string">"LaunchModeStates.add("</span> + key + <span class="string">")"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ActivityState state = <span class="keyword">new</span> ActivityState(key);</div><div class="line">            states.put(key, state);</div><div class="line">            allStates.put(key, state);</div><div class="line">            containers.add(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据 launchMode 和 theme 获取对应的坑位集合,launchMode类似0,theme类似0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">HashMap&lt;String, ActivityState&gt; <span class="title">getStates</span><span class="params">(<span class="keyword">int</span> launchMode, <span class="keyword">int</span> theme)</span> </span>&#123;</div><div class="line">        String infix = getInfix(launchMode, isTranslucentTheme(theme));</div><div class="line">        <span class="keyword">return</span> mStates.get(infix); <span class="comment">//infix类似"NRNTS"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据 launchMode 和 '是否透明' 获取中缀符</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是透明主题，返回 'launchMode'_TS_，否则返回 'launchMode'_NOT_TS_</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getInfix</span><span class="params">(<span class="keyword">int</span> launchMode, <span class="keyword">boolean</span> translucent)</span> </span>&#123;</div><div class="line">        String launchModeInfix = getLaunchModeInfix(launchMode);</div><div class="line">        <span class="keyword">return</span> translucent ? launchModeInfix + <span class="string">"TS"</span> : launchModeInfix + <span class="string">"NTS"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 手动判断主题是否是透明主题</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTranslucentTheme</span><span class="params">(<span class="keyword">int</span> theme)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> theme == android.R.style.Theme_Translucent</div><div class="line">                || theme == android.R.style.Theme_Dialog</div><div class="line">                || theme == android.R.style.Theme_Translucent_NoTitleBar</div><div class="line">                || theme == android.R.style.Theme_Translucent_NoTitleBar_Fullscreen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取 launchMode 对应的前缀</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getLaunchModeInfix</span><span class="params">(<span class="keyword">int</span> launchMode)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (launchMode) &#123;</div><div class="line">            <span class="keyword">case</span> ActivityInfo.LAUNCH_SINGLE_TOP:</div><div class="line">                <span class="keyword">return</span> <span class="string">"STP"</span>;</div><div class="line">            <span class="keyword">case</span> ActivityInfo.LAUNCH_SINGLE_TASK:</div><div class="line">                <span class="keyword">return</span> <span class="string">"ST"</span>;</div><div class="line">            <span class="keyword">case</span> ActivityInfo.LAUNCH_SINGLE_INSTANCE:</div><div class="line">                <span class="keyword">return</span> <span class="string">"SI"</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">"NR"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LaunchModeStates的成员非常简单，就是一个Map<string, hashmap<string,="" activitystate="">&gt;对象，其中<strong>key为launchMode和主题的组合缩写，比如”NRTS”由NR+TS构成，launchMode总结起来有如下情形: </strong></string,></p>
<ul>
<li>NR表示 launMode为Standard</li>
<li>SI表示launchMode为singleInstance</li>
<li>ST表示launchMode为singleTask</li>
<li>STP表示launchMode为singleTop</li>
</ul>
<p>而主题只有两种，一种是透明(TS,translucent缩写)，另一种是不透明(NTS).</p>
<p>LaunchModeStates的方法都很好理解，就不赘述了。</p>
<h4 id="3-4-3-TaskAffinityStates"><a href="#3-4-3-TaskAffinityStates" class="headerlink" title="3.4.3 TaskAffinityStates"></a>3.4.3 TaskAffinityStates</h4><p>TaskAffinityStates的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskAffinityStates</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"task-affinity"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TaskAffinity 的组数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GROUP_COUNT = HostConfigHelper.ACTIVITY_PIT_COUNT_TASK;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     *第二个元素和第一个完全对应，所有Activity的名字只有一个地方不同，就是"TA0"改成了"TA1",其中"TA0"对应taskAffinity为":t0","TA1"对应taskAffinity为":t1"</span></div><div class="line"><span class="comment">     * 比如"NRTS",value为"appId.loader.a.ActivityN1TA1NRTS0","appId.loader.a.ActivityN1TA1NRTS1"</span></div><div class="line"><span class="comment">     * 保存所有 taskAffinity 的坑位的状态，数组索引为 TaskAffinity 索引。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> LaunchModeStates[] mLaunchModeStates = <span class="keyword">new</span> LaunchModeStates[GROUP_COUNT];</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化 TaskAffinity 的坑位数据</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> prefix     &#123;applicationID&#125;.loader.a.Activity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> suffix     [N1, P0, P1]</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> allStates  存储在 PluginContainer 中的所有的坑位的状态</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> containers 所有坑位名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String prefix, String suffix, HashMap&lt;String, PluginContainers.ActivityState&gt; allStates,</span></span></div><div class="line"><span class="function"><span class="params">                     HashSet&lt;String&gt; containers)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 外层循环为组数，内层循环为每组的坑的数量</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GROUP_COUNT; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (mLaunchModeStates[i] == <span class="keyword">null</span>) &#123;</div><div class="line">                mLaunchModeStates[i] = <span class="keyword">new</span> LaunchModeStates();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LaunchModeStates states = mLaunchModeStates[i];</div><div class="line">            <span class="comment">/* Standard */</span></div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_MULTIPLE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_STANDARD);</div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_MULTIPLE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_STANDARD);</div><div class="line"></div><div class="line">            <span class="comment">/* SingleTop */</span></div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_TOP, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TOP);</div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_TOP, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TOP);</div><div class="line"></div><div class="line">            <span class="comment">/* SingleTask */</span></div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_TASK, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TASK);</div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_TASK, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TASK);</div><div class="line"></div><div class="line">            <span class="comment">/* SingleInstance */</span></div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_INSTANCE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_INSTANCE);</div><div class="line">            states.addStates(allStates, containers, prefix + suffix + <span class="string">"TA"</span> + i, LAUNCH_SINGLE_INSTANCE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_INSTANCE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据插件 Activity 的信息，找到宿主对应的坑位集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    HashMap&lt;String, PluginContainers.ActivityState&gt; getStates(ActivityInfo ai) &#123;</div><div class="line">        <span class="keyword">if</span> (ai != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 找到应该取第几个 TaskAffinity 中的坑</span></div><div class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                index = MP.getTaskAffinityGroupIndex(ai.taskAffinity);</div><div class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LaunchModeStates states = mLaunchModeStates[index];</div><div class="line">            <span class="keyword">if</span> (states != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> states.getStates(ai.launchMode, ai.theme);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见TaskAffinityStates其实就是LaunchModeStates的组合，它里面有一个LaunchModeStates数组，在初始化时会将各种launchMode的占位activity添加到LaunchModeStates中。</p>
<p>而TaskAffinityStates的init()被调用的地方有两个，一个是在PluginContainers中的init()方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> process, HashSet&lt;String&gt; containers)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (process != IPluginManager.PROCESS_UI</div><div class="line">                &amp;&amp; !PluginProcessHost.isCustomPluginProcess(process)</div><div class="line">                &amp;&amp; !PluginManager.isPluginProcess()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String prefix = IPC.getPackageName() + CONTAINER_ACTIVITY_PART;</div><div class="line"></div><div class="line">        <span class="comment">// 因为自定义进程可能也会唤起使用 UI 进程的坑，所以这里使用'或'条件</span></div><div class="line">        <span class="keyword">if</span> (process == IPluginManager.PROCESS_UI || PluginProcessHost.isCustomPluginProcess(process)) &#123;</div><div class="line"></div><div class="line">            <span class="comment">/* UI 进程标识为 N1 */</span></div><div class="line">            String suffix = <span class="string">"N1"</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Standard</span></div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_MULTIPLE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_STANDARD);</div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_MULTIPLE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_STANDARD);</div><div class="line"></div><div class="line">            <span class="comment">// SingleTop</span></div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TOP, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TOP);</div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TOP, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TOP);</div><div class="line"></div><div class="line">            <span class="comment">// SingleTask</span></div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TASK, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TASK);</div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TASK, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TASK);</div><div class="line"></div><div class="line">            <span class="comment">// SingleInstance</span></div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_INSTANCE);</div><div class="line">            mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_INSTANCE);</div><div class="line"></div><div class="line">            <span class="comment">// taskAffinity</span></div><div class="line">            mTaskAffinityStates.init(prefix, suffix, mStates, containers);</div><div class="line"></div><div class="line">            <span class="comment">// 因为有可能会在 UI 进程启动自定义进程的 Activity，所以此处也要初始化自定义进程的坑位数据</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PluginProcessHost.PROCESS_COUNT; i++) &#123;</div><div class="line">                ProcessStates processStates = <span class="keyword">new</span> ProcessStates();</div><div class="line">                <span class="comment">// [":p1": state("P1"), ":p2": state("P2")]</span></div><div class="line">                mProcessStatesMap.put(PluginProcessHost.PROCESS_PLUGIN_SUFFIX2 + i, processStates);</div><div class="line">                init2(prefix, containers, processStates, PluginProcessHost.PROCESS_PLUGIN_SUFFIX + i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 从内存中加载</span></div><div class="line">            loadFromPref();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其实这个方法的逻辑很简单，就是分别添加UI进程和自定义进程的坑位Activity, 其中对于UI进程的坑位Activity分别添加Standard,SingleTop, SingleTask, SingleInstance的坑位Activity,然后调用TaskAffinityStates.init()方法添加这些占坑Activity带上taskAffinity的Activity.</p>
<p>而对于需要在自定义进程中运行的占坑Activity,其实就是轮询3个进程(目前PluginProcessHost.PROCESS_COUNT值为3)，然后调用init2()将占坑Activity添加到ProcessStates对象中。</p>
<p>PluginContainers的init2()方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init2</span><span class="params">(String prefix, HashSet&lt;String&gt; containers, ProcessStates states, String suffix)</span> </span>&#123;</div><div class="line">       suffix = suffix.toUpperCase();</div><div class="line"></div><div class="line">       <span class="comment">// Standard</span></div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_MULTIPLE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_STANDARD);</div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_MULTIPLE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_STANDARD);</div><div class="line"></div><div class="line">       <span class="comment">// SingleTop</span></div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TOP, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TOP);</div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TOP, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TOP);</div><div class="line"></div><div class="line">       <span class="comment">// SingleTask</span></div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TASK, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_TASK);</div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_TASK, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_TASK);</div><div class="line"></div><div class="line">       <span class="comment">// SingleInstance</span></div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_INSTANCE);</div><div class="line">       states.mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_INSTANCE);</div><div class="line"></div><div class="line">       <span class="comment">// taskAffinity</span></div><div class="line">       states.mTaskAffinityStates.init(prefix, suffix, mStates, containers);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>显然，这里做的事情其实跟init1()很类似，就是将4种模式并且带有进程信息(比如:p0)的占坑Activity添加到LaunchModeStates中，然后再通过TaskAffinityStates的init()在些基础上再加上taskAffinity,然后再添加到TaskAffinityStates中。</p>
<p><strong>需要注意的是，目前RePlugin对于插件进程的限制为3个，对于taskAffinity的限制为2种。</strong></p>
<p>最后LaunchModeStates的值类似下面这种:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * debug发现mStates的key如下:</span></div><div class="line"><span class="comment">    * "NRTS":launchMode为Standard, TS表示透明.对应的value为"appId.loader.a.ActivityN1NRTS0","appId.loader.a.ActivityN1NRTS1"</span></div><div class="line"><span class="comment">    * "NRNTS":launchMode为Standard,NTS表示不透明,对应的value为"appId.loader.a.ActivityN1NRNTS0",...,"appId.loader.a.ActivityN1NRNTS5"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * "SITS":launchMode为singleInstance,TS表示透明，对应的value为"appId.loader.a.ActivityN1SITS0","appId.loader.a.ActivityN1SITS1","appId.loader.a.ActivityN1SITS2"</span></div><div class="line"><span class="comment">    *"SINTS":launchMode为singleInstance,NTS表示不透明,对应的value为"appId.loader.a.ActivityN1SINTS0","appId.loader.a.ActivitySINTS1"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * "STTS":launchMode为singleTask,TS表示透明，对应的value为"appId.loader.a.ActivityN1STTS0","appId.loader.a.ActivityN1STTS0"</span></div><div class="line"><span class="comment">    * "STNTS":launchMode为singleTask,NTS表示不透明，对应的value为"appId.loader.a.ActivityN1STNTS0",...,"appId.loader.a.ActivityN1STNTS2"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * "STPTS":launchMode为singleTop,TS表示透明,对应的value为"appId.loader.a.ActivityN1STPTS0","appId.loader.a.ActivityN1STPTS1"</span></div><div class="line"><span class="comment">    * "STPNTS":launchMode为singleTop,NTS表示不透明，对应的value为"appId.loader.a.ActivityN1STPNTS0","appId.loader.a.ActivityN1STPNTS1"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * 目前的策略是，针对每一种 launchMode 分配两种坑位（透明主题(TS)和不透明主题(NTS)）</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * 例：透明主题</span></div><div class="line"><span class="comment">    * 　　　　　　　&lt;N1NRTS0, ActivityState&gt;</span></div><div class="line"><span class="comment">    * NR + TS  - &gt; &lt;N1NRTS1, ActivityState&gt;</span></div><div class="line"><span class="comment">    * 　　　　　　　&lt;N1NRTS2, ActivityState&gt;</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * 例：不透明主题</span></div><div class="line"><span class="comment">    * 　　　　　　　&lt;N1NRNTS0, ActivityState&gt;</span></div><div class="line"><span class="comment">    * NR + NTS - &gt; &lt;N1NRNTS1, ActivityState&gt;</span></div><div class="line"><span class="comment">    * 　　　　　　　&lt;N1NRNTS2, ActivityState&gt;</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * 其中：N1 表示当前为 UI 进程，NR 表示 launchMode 为 Standard，NTS 表示坑的 theme 为 Not Translucent。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> Map&lt;String, HashMap&lt;String, ActivityState&gt;&gt; mStates = <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>而TaskAffinityStates的值类似下面这种:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * debug发现mLaunchModeStates这个数组长度为2</span></div><div class="line"><span class="comment">    * 其中第一个元素为里面长度为8的map,各元素如下:</span></div><div class="line"><span class="comment">    *    "NRTS":NR表示lanchMode为Standard,TS表示透明,value为"appId.loader.a.ActivityN1TA0NRTS0","appId.loader.a.ActivityN1TA0NRTS1"</span></div><div class="line"><span class="comment">    *    "SINTS":SIN表示launchMode为singleInstance,TS表示透明,value为"appId.loader.a.ActivityN1TA0SINTS0","appId.loader.a.ActivityN1TA0SINTS1"</span></div><div class="line"><span class="comment">    *    "STTS":ST表示singleTask,TS表示透明,value为"appId.loader.a.ActivityN1TA0STTS0","appId.loader.a.ActivityN1TA0STTS0"</span></div><div class="line"><span class="comment">    *    "NRNTS":NR表示lanchMode为Standard,value为"appId.loader.a.ActivityN1TA0NRNTS0",...,"appId.loader.a.ActivityN1TA0NRTS5",一共6个值</span></div><div class="line"><span class="comment">    *    "STPTS":STP表示singleTop,value为"appId.loader.a.ActivityN1TA0STPTS0","appId.loader.a.ActivityN1TA0STPTS1"</span></div><div class="line"><span class="comment">    *    "STNTS":ST表示singleTask,NTS表示不透明，value为"appId.loader.a.ActivityN1TA0STNTS0",...,"appId.loader.a.ActivityN1TA0STNTS2"</span></div><div class="line"><span class="comment">    *    "STPNTS":STP表示singleTop,NTS表示不透明，value为"appId.loader.a.ActivityN1TA0STPNTS0","appId.loader.a.ActivityN1TA0STPNTS1"</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    *第二个元素和第一个完全对应，所有Activity的名字只有一个地方不同，就是"TA0"改成了"TA1",其中"TA0"对应taskAffinity为":t0","TA1"对应taskAffinity为":t1"</span></div><div class="line"><span class="comment">    * 比如"NRTS",value为"appId.loader.a.ActivityN1TA1NRTS0","appId.loader.a.ActivityN1TA1NRTS1"</span></div><div class="line"><span class="comment">    * 保存所有 taskAffinity 的坑位的状态，数组索引为 TaskAffinity 索引。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> LaunchModeStates[] mLaunchModeStates = <span class="keyword">new</span> LaunchModeStates[GROUP_COUNT];</div></pre></td></tr></table></figure>
<h4 id="3-4-4-真正分配坑位"><a href="#3-4-4-真正分配坑位" class="headerlink" title="3.4.4 真正分配坑位"></a>3.4.4 真正分配坑位</h4><p>再回到PluginContainers.alloc2()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">alloc2</span><span class="params">(ActivityInfo ai, String plugin, String activity, <span class="keyword">int</span> process, Intent intent, String processTail)</span> </span>&#123;</div><div class="line">        <span class="comment">// 根据进程名称，取得该进程对应的 PluginContainerStates</span></div><div class="line">        ProcessStates states = mProcessStatesMap.get(processTail);</div><div class="line"></div><div class="line">        ActivityState state;</div><div class="line"></div><div class="line">        String defaultPluginTaskAffinity = ai.applicationInfo.packageName;</div><div class="line">        ...</div><div class="line">        <span class="comment">/* SingleInstance */</span></div><div class="line">        <span class="keyword">if</span> (ai.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                state = allocLocked(ai, states.mLaunchModeStates.getStates(ai.launchMode, ai.theme), plugin, activity, intent);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* TaskAffinity */</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!defaultPluginTaskAffinity.equals(ai.taskAffinity)) &#123; <span class="comment">// 非默认 taskAffinity</span></div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                state = allocLocked(ai, states.mTaskAffinityStates.getStates(ai), plugin, activity, intent);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* other mode */</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">                state = allocLocked(ai, states.mLaunchModeStates.getStates(ai.launchMode, ai.theme), plugin, activity, intent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> state.container;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>比如，如果是LAUNCH_SINGLE_INSTANCE, 由于ProcessStates中的mLaunchModeStates中已经在前面进行了如下添加操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SingleInstance</span></div><div class="line">           mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">true</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_TS_SINGLE_INSTANCE);</div><div class="line">           mLaunchModeStates.addStates(mStates, containers, prefix + suffix, LAUNCH_SINGLE_INSTANCE, <span class="keyword">false</span>, HostConfigHelper.ACTIVITY_PIT_COUNT_NTS_SINGLE_INSTANCE);</div></pre></td></tr></table></figure>
<ul>
<li>如果是透明主题，会返回一个类似”me.ele.repluginhostsample.loader.a.ActivityN1SINTS0”这样的坑位。</li>
<li>如果是Stanadrd launchMode,并且使用默认的taskAffinity, 主题为不透明，那么会返回一个类似”me.ele.repluginhostsample.loader.a.ActivityN1NRNTS0”这样的坑位,其中NTS表示不透明。</li>
<li>如果该Activity是自定义进程，由于RePlugin目前限制一个插件中最多有3个自定义进程，所以肯定是:p0,:p1,:p2中的一个,比如为:p0则是返回类似”me.ele.repluginhostsample.loader.a.ActivityP0NRNTS0”这样的坑位 。</li>
</ul>
<h2 id="4-进入插件后的startActivity-调用"><a href="#4-进入插件后的startActivity-调用" class="headerlink" title="4. 进入插件后的startActivity()调用"></a>4. 进入插件后的startActivity()调用</h2><p>Factory2也只是起一个封装作用，即它只是调用PluginLibraryInternalProxy中相应的方法来完成操作，Factory2中的startActivity(Context,Intent)方法就是调用了PluginLibraryInternalProxy的startActivity(Context,Intent)方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span> 内部方法，插件框架使用</span></div><div class="line"><span class="comment">     * 启动一个插件中的activity</span></div><div class="line"><span class="comment">     * 通过Extra参数IPluginManager.KEY_COMPATIBLE，IPluginManager.KEY_PLUGIN，IPluginManager.KEY_ACTIVITY，IPluginManager.KEY_PROCESS控制</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> context Context上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 插件机制层是否成功，例如没有插件存在、没有合适的Activity坑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivity</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// 兼容模式，直接使用标准方式启动</span></div><div class="line">        <span class="keyword">if</span> (intent.getBooleanExtra(IPluginManager.KEY_COMPATIBLE, <span class="keyword">false</span>)) &#123;</div><div class="line">            PmBase.cleanIntentPluginParams(intent);</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"start context: COMPATIBLE is true, direct start"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取Activity的名字，有两种途径：</span></div><div class="line">        <span class="comment">// 1. 从Intent里取。通常是明确知道要打开的插件的Activity时会用</span></div><div class="line">        <span class="comment">// 2. 从Intent的ComponentName中获取</span></div><div class="line">        String name = intent.getStringExtra(IPluginManager.KEY_ACTIVITY);</div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</div><div class="line">            ComponentName cn = intent.getComponent();</div><div class="line">            <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</div><div class="line">                name = cn.getClassName();</div><div class="line">                <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                    LogDebug.d(PLUGIN_TAG, <span class="string">"start context: custom context="</span> + context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 已经是标准坑了（例如N1ST1这样的），则无需再过“坑位分配”逻辑，直接使用标准方式启动</span></div><div class="line">        <span class="keyword">if</span> (mPluginMgr.isActivity(name)) &#123;</div><div class="line">            PmBase.cleanIntentPluginParams(intent);</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"start context: context is container, direct start"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取插件名，有三种途径：</span></div><div class="line">        <span class="comment">// 1. 从Intent里取。通常是明确知道要打开的插件时会用</span></div><div class="line">        <span class="comment">// 2. 根据当前Activity的坑位名来“反查”其插件名。通常是插件内开启自己的Activity时用到</span></div><div class="line">        <span class="comment">// 3. 通过获得Context的类加载器来判断其插件名</span></div><div class="line">        String plugin = intent.getStringExtra(IPluginManager.KEY_PLUGIN);</div><div class="line"></div><div class="line">        <span class="comment">/* 检查是否是动态注册的类 */</span></div><div class="line">        <span class="comment">// 如果要启动的 Activity 是动态注册的类，则不使用坑位机制，而是直接动态类。</span></div><div class="line">        <span class="comment">// 原因：宿主的某些动态注册的类不能运行在坑位中（如'桌面'插件的入口Activity）</span></div><div class="line">        ComponentName componentName = intent.getComponent();</div><div class="line">        <span class="keyword">if</span> (componentName != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">	        <span class="keyword">if</span> (LogDebug.LOG) &#123;</div><div class="line">	            LogDebug.d(<span class="string">"loadClass"</span>, <span class="string">"isHookingClass("</span> + plugin + <span class="string">","</span> + componentName.getClassName() + <span class="string">") = "</span></div><div class="line">	                    + isDynamicClass(plugin, componentName.getClassName()));</div><div class="line">	        &#125;</div><div class="line">	        <span class="keyword">if</span> (isDynamicClass(plugin, componentName.getClassName())) &#123;</div><div class="line">                intent.putExtra(IPluginManager.KEY_COMPATIBLE, <span class="keyword">true</span>);</div><div class="line">	            intent.setComponent(<span class="keyword">new</span> ComponentName(IPC.getPackageName(), componentName.getClassName()));</div><div class="line">	            context.startActivity(intent);</div><div class="line">	            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	        &#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">            <span class="comment">// 看下Context是否为Activity，如是则直接从坑位中获取插件名（最准确）</span></div><div class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</div><div class="line">                plugin = fetchPluginByPitActivity((Activity) context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"start context: custom plugin is empty, query plugin="</span> + plugin);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 没拿到插件名？再从 ClassLoader 获取插件名称（兜底）</span></div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">            plugin = RePlugin.fetchPluginNameByClassLoader(context.getClassLoader());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 仍然拿不到插件名？（例如从宿主中调用），则打开的Activity可能是宿主的。直接使用标准方式启动</span></div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(plugin)) &#123;</div><div class="line">            PmBase.cleanIntentPluginParams(intent);</div><div class="line">            <span class="keyword">if</span> (LOG) &#123;</div><div class="line">                LogDebug.d(PLUGIN_TAG, <span class="string">"start context: plugin and context is empty, direct start"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取进程值，看目标Activity要打开哪个进程</span></div><div class="line">        <span class="keyword">int</span> process = intent.getIntExtra(IPluginManager.KEY_PROCESS, Integer.MIN_VALUE);</div><div class="line"></div><div class="line">        PmBase.cleanIntentPluginParams(intent);</div><div class="line"></div><div class="line">        <span class="comment">// 调用“特殊版”的startActivity，不让自动填写ComponentName，防止外界再用时出错</span></div><div class="line">        <span class="keyword">return</span> Factory.startActivityWithNoInjectCN(context, intent, plugin, name, process);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android-plugin/" rel="tag"># android_plugin</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/04/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/08/RePlugin解析之插件的安装与加载/" rel="prev" title="RePlugin解析之插件的安装与加载">
                RePlugin解析之插件的安装与加载 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">150</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-编译时代码替换"><span class="nav-number">1.</span> <span class="nav-text">1.编译时代码替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-PluginLibraryInternalProxy"><span class="nav-number">2.</span> <span class="nav-text">2.PluginLibraryInternalProxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-首次进入插件时的startActivity-调用"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 首次进入插件时的startActivity()调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-RePlugin-startActivity-Context-Intent"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 RePlugin.startActivity(Context,Intent)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-Factory-startActivityWithNoInjectCN-Context-Intent-String-String-int"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 Factory.startActivityWithNoInjectCN(Context, Intent, String, String, int)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Activity坑位的分配–PluginCommImpl分析"><span class="nav-number">3.</span> <span class="nav-text">3.Activity坑位的分配–PluginCommImpl分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Activity信息的获取"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Activity信息的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-分配pid"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 分配pid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-插件中组件进程启动"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 插件中组件进程启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-sPluginHostLocal是什么"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 sPluginHostLocal是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-sPluginHostRemote的作用-以及ContentProvider的巧妙运用"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 sPluginHostRemote的作用,以及ContentProvider的巧妙运用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-进程分配"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 进程分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-组件自定义进程启动"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 组件自定义进程启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-attachProcess"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 attachProcess()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-分配坑位"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 分配坑位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-ProcessStates的定义"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 ProcessStates的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-LaunchModeStates"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 LaunchModeStates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-TaskAffinityStates"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 TaskAffinityStates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-真正分配坑位"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4 真正分配坑位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-进入插件后的startActivity-调用"><span class="nav-number">4.</span> <span class="nav-text">4. 进入插件后的startActivity()调用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
