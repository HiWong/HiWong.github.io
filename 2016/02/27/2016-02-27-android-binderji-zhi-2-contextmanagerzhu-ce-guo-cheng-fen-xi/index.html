<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="引言Context Manager对应的进程为servicemanager,它先于Service Server与服务客户端运行，首先进入接收IPC数据的状态，处理来自Service Server或服务客户端的请求。在init.rc脚本文件中也可以看到Context Manager在mediaserver与system_server之前运行了。   每当Service Server注册服务时，Con">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Binder机制(2) ContextManager注册过程分析">
<meta property="og:url" content="http://yoursite.com/2016/02/27/2016-02-27-android-binderji-zhi-2-contextmanagerzhu-ce-guo-cheng-fen-xi/index.html">
<meta property="og:site_name" content="AllenWang的个人博客">
<meta property="og:description" content="引言Context Manager对应的进程为servicemanager,它先于Service Server与服务客户端运行，首先进入接收IPC数据的状态，处理来自Service Server或服务客户端的请求。在init.rc脚本文件中也可以看到Context Manager在mediaserver与system_server之前运行了。   每当Service Server注册服务时，Con">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/service_list.png">
<meta property="og:updated_time" content="2017-12-03T20:21:03.335Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Binder机制(2) ContextManager注册过程分析">
<meta name="twitter:description" content="引言Context Manager对应的进程为servicemanager,它先于Service Server与服务客户端运行，首先进入接收IPC数据的状态，处理来自Service Server或服务客户端的请求。在init.rc脚本文件中也可以看到Context Manager在mediaserver与system_server之前运行了。   每当Service Server注册服务时，Con">
<meta name="twitter:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/service_list.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/02/27/2016-02-27-android-binderji-zhi-2-contextmanagerzhu-ce-guo-cheng-fen-xi/"/>





  <title>Android Binder机制(2) ContextManager注册过程分析 | AllenWang的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AllenWang的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小楼一夜听春雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/27/2016-02-27-android-binderji-zhi-2-contextmanagerzhu-ce-guo-cheng-fen-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AllenWang的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android Binder机制(2) ContextManager注册过程分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-27T00:15:06+08:00">
                2016-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android-deep-analysis/" itemprop="url" rel="index">
                    <span itemprop="name">android_deep_analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Context Manager对应的进程为servicemanager,它先于Service Server与服务客户端运行，首先进入接收IPC数据的状态，处理来自Service Server或服务客户端的请求。在init.rc脚本文件中也可以看到Context Manager在mediaserver与system_server之前运行了。  </p>
<p>每当Service Server注册服务时，Context Manager都会把服务的名称与Binder节点编号注册到自身的服务目录中，该服务目录通过根文件系统下的/system/service程序即可查看。<br>下图即为在华为某型号手机上使用service list命令查看到的服务列表<a id="more"></a>：  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/service_list.png" alt="service_list"></p>
<p>可以看到MediaPlayer Service以及Camera Service等。</p>
<h2 id="1-启动运行Context-Manager的main-函数"><a href="#1-启动运行Context-Manager的main-函数" class="headerlink" title="1.启动运行Context Manager的main()函数"></a>1.启动运行Context Manager的main()函数</h2><p>Context Manager与其他Android服务不同，它采用C语言编写，以便使其与Binder Driver紧密衔接。Context Manager的源码在/frameworks/base/cmds/servicemanager目录下的service_manager.c中。main()函数如下所示：<br><figure class="highlight c"><figcaption><span>service_manager.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></div><div class="line">    <span class="keyword">void</span> *svcmgr=BINDER_SERVICE_MANAGER;</div><div class="line"></div><div class="line">    bs=binder_open(<span class="number">128</span>*<span class="number">1024</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(binder_become_context_manager(bs))&#123;</div><div class="line">        LOGE(<span class="string">"cannot become context manager (%s)\n"</span>,strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    svcmgr_handle=svcmgr;</div><div class="line">    binder_loop(bs,svcmgr_handler);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码按功能可以分为以下3部分：  </p>
<ul>
<li><p>调用binder_open()函数，将引起open()与mmap()函数调用，调用open()函数打开Binder Driver，而调用mmap()函数则生成接收IPC数据的Buffer. Context Manager使用大小为128KB的Buffer来接收IPC数据;</p>
</li>
<li><p>与Service Server和服务客户端不同，这是Context Manager特有的语句，用于访问Binder Driver,并将自身的Binder节点设置为0号节点。在binder_become_context_manager()中，仅有一条调用ioctl()函数的语句，如下所示：</p>
<figure class="highlight c"><figcaption><span>binder_become_context_manager()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state*bs)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd,BINDER_SET_CONTEXT_MGR,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Context Manager将自身的Binder节点设置好后，就进入循环，不断等待接收IPC数据，那就是binder_loop()的作用。 </p>
</li>
</ul>
<p>下面将详细讲解这3个部分。  </p>
<h2 id="2-binder-open-函数分析"><a href="#2-binder-open-函数分析" class="headerlink" title="2.binder_open()函数分析"></a>2.binder_open()函数分析</h2><h3 id="2-1-驱动函数注册"><a href="#2-1-驱动函数注册" class="headerlink" title="2.1 驱动函数注册"></a>2.1 驱动函数注册</h3><p>在分析binder_open()方法之前，我们先了解一下驱动函数是如何被调用的，我们先看一下下面的代码：<br><figure class="highlight c"><figcaption><span>binder.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span>=&#123;</span></div><div class="line">    .owner=THIS_MODULE,</div><div class="line">    .poll=binder_poll,</div><div class="line">    .unlocked_ioctl=binder_ioctl,</div><div class="line">    .mmap=binder_mmap,</div><div class="line">    .open=binder_open,</div><div class="line">    .flush=binder_flush,</div><div class="line">    .release=binder_release,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span>=&#123;</span></div><div class="line">    .minor=MISC_DYNAMIC_MINOR,</div><div class="line">    .name=<span class="string">"binder"</span>,</div><div class="line">    .fops=&amp;binder_fops,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init binder_init(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    ret=misc_register(&amp;binder_miscdev);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">device_initcall(binder_init);</div></pre></td></tr></table></figure></p>
<p>上面的代码在drivers/staging/android/binder.c中。我们知道，Android是基于Linux 2.6内核开发的，所以驱动的注册和Linux中也一样。  </p>
<ul>
<li><p>device_initcall(binder_init)的作用是将binder_init()函数注册到kernel的初始化函数列表中。当kernel启动后，会按照一定的次序调用初始化函数列表，也就会执行binder_init()函数，执行binder_init()时便会加载Binder驱动;</p>
</li>
<li><p>binder_init()函数中会通过misc_register(&amp;binder_miscdev)将Binder驱动注册到文件节点/dev/binder上。在Linux中，一切都是文件。将Binder驱动注册到文件节点上之后，就可以通过操作文件节点进而对Binder驱动进行操作。而该文件节点/dev/binder的设备信息是binder_miscdev这个结构体对象。</p>
</li>
<li><p>binder_miscdev变量是struct miscdevice类型。minor是次设备号，这个我们不关心;name是Binder驱动对应在/dev虚拟文件系统下的设备节点名称，也就是/dev/binder中的”binder”;fops是该设备节点的文件操作对象，它是我们需要重点关注的.</p>
</li>
<li><p>binder_fops变量是struct file_operations类型。其中owner标明了该文件操作变量的拥有者，就是该驱动;poll则指定了poll函数指针，当我们对/dev/binder文件节点执行poll操作时，实际上调用的就是binder_poll()函数;同理，mmap()对应binder_mmap()，open()对应binder_open(),ioctl()对应binder_ioctl</p>
</li>
</ul>
<h3 id="2-2-binder-open"><a href="#2-2-binder-open" class="headerlink" title="2.2 binder_open()"></a>2.2 binder_open()</h3><p>binder_open()方法的主要代码如下：<br><figure class="highlight c"><figcaption><span>binder_open()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></div><div class="line"></div><div class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    bs-&gt;mapsize = mapsize;</div><div class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> bs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该代码在/frameworks/base/cmds/servicemanager/binder.c中.</p>
<h4 id="2-2-1-驱动中的binder-oepn"><a href="#2-2-1-驱动中的binder-oepn" class="headerlink" title="2.2.1 驱动中的binder_oepn()"></a>2.2.1 驱动中的binder_oepn()</h4><p>通过2.1的分析，我们知道open(“/dev/binder”,O_RDWR);其实就是调用Binder驱动中的binder_open(),其代码如下：<br><figure class="highlight c"><figcaption><span>binder_open()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></div><div class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">"binder_open: %d:%d\n"</span>,</div><div class="line">             current-&gt;group_leader-&gt;pid, current-&gt;pid);</div><div class="line">    <span class="comment">//为proc分配内存</span></div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    get_task_struct(current);</div><div class="line">    <span class="comment">//将proc-&gt;tsk指向当前线程</span></div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    <span class="comment">//初始化proc的待处理事务列表</span></div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</div><div class="line">    <span class="comment">//初始化proc的待处理事务列表</span></div><div class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</div><div class="line">    <span class="comment">//设置proc的进程优先级设置为当前线程的优先级</span></div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    <span class="comment">//将该进程上下文信息proc保存到binder_procs中</span></div><div class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</div><div class="line">    <span class="comment">//设置进程id</span></div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</div><div class="line">    <span class="comment">//将proc设置为flip的私有数据中,从而 使mmap(),ioctl()等函数都可以通过私有数据获取到proc,即该进程的context信息</span></div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tips: 结构体binder_proc用于记录进程上下文信息。它的详细介绍可参考博客<a href="http://blog.imallen.wang/" target="_blank" rel="external">Android Binder机制中的数据结构分析</a>.   </p>
<p>结合注释，很容易发现该函数的主要伤脑筋其实就是新建了一个binder_proc指针，并为其分配内存，再设置其属性(如tsk,todo,default_priority等),最后将其赋值给flip的private_data属性，这样以后就可以通过flip-&gt;private_data访问到进程上下方信息了。  </p>
<h4 id="2-2-2-mmap-分析"><a href="#2-2-2-mmap-分析" class="headerlink" title="2.2.2 mmap()分析"></a>2.2.2 mmap()分析</h4><p>mmap()函数对应Binder驱动中的binder_mmap()函数，其主要代码如下：<br><figure class="highlight c"><figcaption><span>binder_mmap()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></div><div class="line">    <span class="comment">//有效性检查，确保映射的内存不能大于4M</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取空闲的内核空间地址</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    </div><div class="line">    ...</div><div class="line">    <span class="comment">//将内核地址空间地址赋值给proc-&gt;buffer,即保存到进程上下文中</span></div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    <span class="comment">//计算进程虚拟地址(vma-&gt;vm_start)和内核空间地址(proc-&gt;buffer)的偏移值</span></div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</div><div class="line">  </div><div class="line">    ...</div><div class="line">    <span class="comment">//为proc-&gt;pages分配内存</span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">   </div><div class="line">    ...</div><div class="line">    <span class="comment">//内核空间的内存大小=进程虚拟地址区域(用户空间)的内存大小</span></div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</div><div class="line">    <span class="comment">//将proc赋值给vma私有数值</span></div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line">    <span class="comment">//通过调用binder_update_page_range()来分配物理页面。即物理内存映射到内核空间和用户空间</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    &#125;</div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</div><div class="line">    <span class="comment">//将物理内存添加到proc-&gt;buffers链表中进行管理</span></div><div class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    <span class="comment">//将用户空间地址信息保存到proc中</span></div><div class="line">    proc-&gt;vma = vma;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>函数首先通过flip-&gt;private_data得到在打开设备文件/dev/binder时创建的struct binder_proc结构体</p>
</li>
<li><p>内存映射信息放在vma中。读者可能注意到了vma类型是struct vm_area_struct,它表示一块连续的虚拟地址空间区域。而函数中的area类型是struct vm_struct,它表示的也是一块连续的虚拟地址空间。那么它们的区别是什么呢？<br>在Linux中，struct vm_aream_struct表示的虚拟地址是给进程使用的，而struct vm_struct表示的虚拟地址是给内核使用的，它们对应的物理页面都可以是不连续的。</p>
</li>
</ul>
<h4 id="2-2-3-binder-update-page-range"><a href="#2-2-3-binder-update-page-range" class="headerlink" title="2.2.3 binder_update_page_range()"></a>2.2.3 binder_update_page_range()</h4><p>其源码如下：<br><figure class="highlight c"><figcaption><span>binder_update_page_range()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_proc *proc, <span class="keyword">int</span> allocate,</span></span></div><div class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span></span></div><div class="line"><span class="function"><span class="params">                struct vm_area_struct *vma)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> *page_addr;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> <span class="title">tmp_area</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page_array_ptr</span>;</span></div><div class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</div><div class="line">        BUG_ON(*page);</div><div class="line">        *page = alloc_page(GFP_KERNEL | __GFP_ZERO);</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        tmp_area.addr = page_addr;</div><div class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</div><div class="line">        page_array_ptr = page;</div><div class="line">        ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</div><div class="line">       </div><div class="line">        ...</div><div class="line"></div><div class="line">        user_page_addr =</div><div class="line">            (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</div><div class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tips: binder_update_range()既可用于分配物理页面，也可用于释放物理页面，这取决于allocate的值。这里先只讨论分配物理页面的情形。</p>
<ul>
<li><p>page用于指向物理页面，tmp_area用于描述内核空间，user_page_addr则代表相应的进程虚拟空间地址，由于在binder_mmap()函数中已经计算出了内核虚拟空间地址和进程虚拟空间地址的偏差值，所以这里只要用页面地址加上相应的偏差值即可;</p>
</li>
<li><p>在for循环中，每分配一个物理页面都会先通过map_vm_are()将该物理页面映射到内核虚拟地址中，然后再将该物理页面插入到进程虚拟地址空间。 </p>
</li>
</ul>
<p><strong>至此，binder_open()函数就分析完了，总结起来它的作用就是打开/dev/binder，然后使进程虚拟空间和内核虚拟空间映射到同一块物理内存中，同时新建并初始化了binder_proc对象，保存了进程上下文信息。</strong>  </p>
<h2 id="3-binder-become-context-manager"><a href="#3-binder-become-context-manager" class="headerlink" title="3.binder_become_context_manager()"></a>3.binder_become_context_manager()</h2><p>这个方法的代码非常简单：<br><figure class="highlight c"><figcaption><span>binder_become_context_manager()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state*bs)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd,BINDER_SET_CONTEXT_MGR,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面说过，ioctl()对应Binder Driver中的binder_ioctl()方法，下面是其主要代码：<br><figure class="highlight c"><figcaption><span>binder_ioctl()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">//由于我们只里只涉及到BINDER_SET_CONTEXT_MGR这种情形，所以将其它几种情况的代码省略了。</span></div><div class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            binder_context_mgr_uid = current-&gt;cred-&gt;euid;</div><div class="line">        binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</div><div class="line">            ret = -ENOMEM;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        binder_context_mgr_node-&gt;local_weak_refs++;</div><div class="line">        binder_context_mgr_node-&gt;local_strong_refs++;</div><div class="line">        binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</div><div class="line">        binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    </div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    ret = <span class="number">0</span>;</div><div class="line">err:</div><div class="line">    <span class="keyword">if</span> (thread)</div><div class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tip:为了更好地分析代码逻辑，将debug输出，异常处理以及其他几种case情况的代码省略了。  </p>
<p>在分析这个函数之前，先看下下struct binder_thread和struct binder_node这两个结构体类型。  </p>
<h3 id="3-1-struct-binder-thread分析"><a href="#3-1-struct-binder-thread分析" class="headerlink" title="3.1 struct binder_thread分析"></a>3.1 struct binder_thread分析</h3><figure class="highlight c"><figcaption><span>struct binder_thread</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span>&#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span>*<span class="title">proc</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">int</span> looper;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span>*<span class="title">transaction_stack</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></div><div class="line">    <span class="comment">/*Write failed,return error code in read buf*/</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error;</div><div class="line">    <span class="comment">/*Write failed,return error code in read buffer.Used when sending a reply to a dead process that we are also waiting on*/</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error2;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>proc代表这个线程所属的进程，实际上，struct binder_proc有一个成员变量threads，它的类型是rb_root，即利用红黑树将这个进程的所有线程都组织起来。struct binder_thread的成员变量rb_node就是用来放入这棵红黑树的节点。</p>
</li>
<li><p>looper成员变量表示线程的状态。它是一个枚举值，枚举定义如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span>&#123;</div><div class="line">    BINDER_LOOPER_STATE_REGISTERED=<span class="number">0x01</span>;</div><div class="line">    BINDER_LOOPER_STATE_ENTERED=<span class="number">0x02</span>;</div><div class="line">    BINDER_LOOPER_STATE_EXITED=<span class="number">0x04</span>;</div><div class="line">    BINDER_LOOPER_STATE_INVALID=<span class="number">0x08</span>;</div><div class="line">    BINDER_LOOPER_STATE_WAITING=<span class="number">0x10</span>;</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN=<span class="number">0x20</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>transaction_stack表示线程正在处理的事务</p>
</li>
<li><p>todo表示发往该线程的数据列表</p>
</li>
<li><p>return_error和return_error2用于存放操作结果返回码</p>
</li>
<li><p>wait用来阻塞线程等待某个事件的发生</p>
</li>
<li><p>stats用来保存一些统计信息</p>
</li>
</ul>
<h3 id="3-2-struct-binder-node分析"><a href="#3-2-struct-binder-node分析" class="headerlink" title="3.2 struct binder_node分析"></a>3.2 struct binder_node分析</h3><p>struct binder_node代表一个binder实体，所有Service Server都会有一个对应的binder_node. 其定义如下：<br><figure class="highlight c"><figcaption><span>struct binder_node</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">dead_node</span>;</span></div><div class="line">    &#125;;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">refs</span>;</span></div><div class="line">    <span class="keyword">int</span> internal_strong_refs;</div><div class="line">    <span class="keyword">int</span> local_weak_refs;</div><div class="line">    <span class="keyword">int</span> local_strong_refs;</div><div class="line">    <span class="keyword">void</span> __user *ptr;</div><div class="line">    <span class="keyword">void</span> __user *cookie;</div><div class="line">    <span class="keyword">unsigned</span> has_strong_ref:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> pending_strong_ref:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> has_weak_ref:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> pending_weak_ref:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> has_async_transaction:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> accept_fds:<span class="number">1</span>;</div><div class="line">    <span class="keyword">unsigned</span> min_priority:<span class="number">8</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_todo</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>rb_node和dead_node组成一个联合体，如果这个Binder实体还在正常使用，则使用rb_node来连入proc-&gt;nodes所表示的红黑树的节点，这棵红黑树用来组织属于这个进程的所有Binder实体;如果这个Binder实体所属的进程已经被销毁，而这个Binder实体又被其他进程所使用，则它通过dead_node进入到一个哈希表中去存放。</p>
</li>
<li><p>proc当然是指这个Binder实体所属的进程了</p>
</li>
<li><p>refs成员变量则是所有引用了该Binder实体的Binder引用构成的链表</p>
</li>
<li><p>internal_strong_refs,local_weak_refs,local_strong_refs表示这个Binder实体的引用计数</p>
</li>
<li><p>ptr和cookie分别表示这个Binder实体在用户空间的地址和附加数据</p>
</li>
</ul>
<p>剩下的成员变量比较简单，等用到的时候再进行说明。  </p>
<h3 id="3-3-binder-ioctl-逻辑分析"><a href="#3-3-binder-ioctl-逻辑分析" class="headerlink" title="3.3 binder_ioctl()逻辑分析"></a>3.3 binder_ioctl()逻辑分析</h3><h4 id="3-3-1-binder-get-thread-方法"><a href="#3-3-1-binder-get-thread-方法" class="headerlink" title="3.3.1 binder_get_thread()方法"></a>3.3.1 binder_get_thread()方法</h4><p>回到binder_ioctl()函数中，首先是通过flip-&gt;private_data获得proc变量，然后通过调用binder_get_thread()函数获得线程信息，该方法的代码如下：<br><figure class="highlight c"><figcaption><span>binder_get_thread()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        parent = *p;</div><div class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</div><div class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</div><div class="line">            p = &amp;(*p)-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</div><div class="line">            p = &amp;(*p)-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*p == <span class="literal">NULL</span>) &#123;</div><div class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        binder_stats_created(BINDER_STAT_THREAD);</div><div class="line">        thread-&gt;proc = proc;</div><div class="line">        thread-&gt;pid = current-&gt;pid;</div><div class="line">        init_waitqueue_head(&amp;thread-&gt;wait);</div><div class="line">        INIT_LIST_HEAD(&amp;thread-&gt;todo);</div><div class="line">        rb_link_node(&amp;thread-&gt;rb_node, parent, p);</div><div class="line">        rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</div><div class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">        thread-&gt;return_error = BR_OK;</div><div class="line">        thread-&gt;return_error2 = BR_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码很好理解，由于当前线程是第一次进入这里，所以*p==NULL成立，从而为当前线程创建一个线程上下文信息结构binder_thread,并初始化各成员变量，并插入到proc-&gt;threads所代表的红黑树中。另外，注意这里的thread-&gt;looper=BINDER_LOOPER_STATE_NEED_RETURN.  </p>
<h4 id="3-3-2-binder-new-node-方法"><a href="#3-3-2-binder-new-node-方法" class="headerlink" title="3.3.2 binder_new_node()方法"></a>3.3.2 binder_new_node()方法</h4><p>回到binder_ioctl()函数，继续往下看可以看到两个全局变量，它们的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">uid_t</span> binder_context_mgr_uid=<span class="number">-1</span>;</div></pre></td></tr></table></figure></p>
<p>其中binder_context_mgr_node代表Context Manager实体，binder_context_mgr_uid代表Context Manager守护进程的uid.由于是首次进入binder_ioctl()，所以将binder_context_mgr_uid赋值为current-&gt;cred-&gt;euid，这样，当前线程就成为Binder机制的守护进程了;然后调用binder_new_node()函数为Context Manager创建新的Binder实体，该方法的代码如下：<br><figure class="highlight c"><figcaption><span>binder_new_node()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> __user *ptr,</span></span></div><div class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> __user *cookie)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">nodes</span>.<span class="title">rb_node</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></div><div class="line">    <span class="comment">//根据ptr在红黑树中查找是否已经存在相应的binder节点，如果已经存在则返回NULL,否则最终跳出循环并新建节点</span></div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        parent = *p;</div><div class="line">        node = rb_entry(parent, struct binder_node, rb_node);</div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</div><div class="line">            p = &amp;(*p)-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</div><div class="line">            p = &amp;(*p)-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    binder_stats_created(BINDER_STAT_NODE);</div><div class="line">    rb_link_node(&amp;node-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</div><div class="line">    node-&gt;debug_id = ++binder_last_id;</div><div class="line">    node-&gt;proc = proc;</div><div class="line">    node-&gt;ptr = ptr;</div><div class="line">    node-&gt;cookie = cookie;</div><div class="line">    node-&gt;work.type = BINDER_WORK_NODE;</div><div class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</div><div class="line">    INIT_LIST_HEAD(&amp;node-&gt;async_todo);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>注意到传入的参数ptr和cookie均为NULL，所以在遍历红黑树查找不到binder节点，然后新建binder节点。kzalloc()方法的作用是分配内存并初始化，其效果等同于先调用kmalloc()然后调用memset()进行初始化。  </p>
</li>
<li><p>创建好节点之后，对其属性进行初始化，然后返回。</p>
</li>
</ul>
<p>**至此，binder_become_context_manager()方法就基本分析完了，总结起来，它主要是完成了以下几件事:  </p>
<ul>
<li>1)告诉kernel驱动，当前进程即Binder上下文管理者  </li>
<li>2)新建binder_thread对象并将其插入到binder_proc的threads红黑树中;  </li>
<li>3)新建对应于Context Manager的binder_node;**  </li>
</ul>
<h2 id="4-binder-loop-分析"><a href="#4-binder-loop-分析" class="headerlink" title="4. binder_loop()分析"></a>4. binder_loop()分析</h2><p>下面分析servicer_manager.c中的main()函数中的第三部分:binder_loop()，该方法的代码如下：<br><figure class="highlight c"><figcaption><span>binder_loop()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</div><div class="line"></div><div class="line">    bwr.write_size = <span class="number">0</span>;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</div><div class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</div><div class="line">        bwr.read_consumed = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</div><div class="line"></div><div class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</div><div class="line">            LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</div><div class="line">            LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</div><div class="line">            LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4-1-binder-write-分析"><a href="#4-1-binder-write-分析" class="headerlink" title="4.1 binder_write()分析"></a>4.1 binder_write()分析</h3><p>首先通过binder_write()函数执行BC_ENTER_LOOPER命令告诉Binder Driver，Context Manager要进入循环了。binder_write()的代码如下：<br><figure class="highlight c"><figcaption><span>binder_write()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">    bwr.write_size = len;</div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</div><div class="line">    bwr.read_size = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</div><div class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</div><div class="line">                strerror(errno));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中结构体binder_write_read的定义如下：<br><figure class="highlight c"><figcaption><span>struct binder_write_read</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span>&#123;</span></div><div class="line">    <span class="comment">//bytes to write</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; </div><div class="line">    <span class="comment">//bytes consumed by driver</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> write_buffer;</div><div class="line">    <span class="comment">//bytes to read</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;</div><div class="line">    <span class="comment">//bytes consumed by driver</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> read_buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-1-1-binder-ioctl-分析"><a href="#4-1-1-binder-ioctl-分析" class="headerlink" title="4.1.1 binder_ioctl()分析"></a>4.1.1 binder_ioctl()分析</h4><p>再回到binder_write()中，代码很简单，就是新建一个binder_write_read变量并且初始化，重点在于ioctl，由于此处传入的命令参数是BINDER_WRITE_READ，所以此时对应的binder_ioctl()主要代码如下：<br><figure class="highlight c"><figcaption><span>binder_ioctl()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                bwr.read_consumed = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    ret = <span class="number">0</span>;</div><div class="line">err:</div><div class="line">    <span class="keyword">if</span> (thread)</div><div class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>1)switch前面的代码在之前已经解释过了，同前面是一样的，只不过这里调用binder_get_thread函数能够获取到之前创建的binder_thread，所以不需要再创建一个新的了  </p>
</li>
<li><p>2)通过copy_from_user(&amp;bwr,ubuf,sizeof(bwr))将用户传递过来的参数会的成struct binder_write_read结构体变量并保存在bwr中  </p>
</li>
<li><p>3)由于bwr.write_size为4,故进入binder_thread_write()函数中，其主要代码如下：   </p>
<figure class="highlight c"><figcaption><span>binder_thread_write()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">         </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</div><div class="line">           </div><div class="line">           ...</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></div><div class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            &#125;</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>吐槽一下：这个方法的完整代码有300多行，其实是十分不优雅的，很不利于阅读。<br>由于之前在binder_get_thread()函数中创建的binder_thread的looper值为0，所以这里的代码就异常简单了，就是改变thread的looper属性成员的值，使其变为BINDER_LOOPER_STATE_ENTERED;  </p>
<ul>
<li>4)再回到binder_ioctl()函数，由于bwr_read_size==0,所以函数不会再向下执行了。</li>
</ul>
<h3 id="4-2-binder-loop-中的for循环分析"><a href="#4-2-binder-loop-中的for循环分析" class="headerlink" title="4.2 binder_loop()中的for循环分析"></a>4.2 binder_loop()中的for循环分析</h3><p>回到binder_loop()函数，进入for循环，调用ioctl()之前的代码都很简单，就是给bwr的成员赋值。注意经过赋值之后bwr的各成员的值如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bwr.write_size=<span class="number">0</span>;</div><div class="line">bwr.write_consumed=<span class="number">0</span>;</div><div class="line">bwr.write_buffer=<span class="number">0</span>;</div><div class="line">readbuf[<span class="number">0</span>]=BC_ENTER_LOOPER;</div><div class="line">bwr.read_size=<span class="keyword">sizeof</span>(readbuf);</div><div class="line">bwr.read_consumed=<span class="number">0</span>;</div><div class="line">bwr.read_buffer=(<span class="keyword">unsigned</span>)readbuf;</div></pre></td></tr></table></figure></p>
<p>再次进入binder_ioctl()函数中：<br><figure class="highlight c"><figcaption><span>binder_ioctl()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                bwr.read_consumed = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    ret = <span class="number">0</span>;</div><div class="line">err:</div><div class="line">    <span class="keyword">if</span> (thread)</div><div class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟上一次调用相比，其他的都相同，只是这次bwr.write_size等于0同时bwr.read_size等于32，所以这次不调用binder_thread_write()函数而是进入binder_thread_read()函数(其实就是上次写入了自己的状态，然后就开始读取驱动中的数据了),binder_thread_read()方法如下:<br><figure class="highlight c"><figcaption><span>binder_thread_read()</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">              struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">              <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></div><div class="line"><span class="function"><span class="params">              <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line">    <span class="comment">//若*consumed==0,则写入BR_NOOP到用户传进来的bwr.read_buffer缓冲区</span></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        <span class="comment">//修改指针位置</span></div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    &#125;</div><div class="line">retry:</div><div class="line">    <span class="comment">//等待proc进程的事务标记</span></div><div class="line">    <span class="comment">//当线程的事务栈为空，待处理事务列表为空时，该标记为true</span></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</div><div class="line">                list_empty(&amp;thread-&gt;todo);</div><div class="line">   ...</div><div class="line">    <span class="comment">//设置线程状态为等待</span></div><div class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads++;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">       </div><div class="line">        ...</div><div class="line">        <span class="comment">//设置当前线程的优先级为进程的默认优先级</span></div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) &#123;</div><div class="line">            <span class="comment">//非阻塞式的读取，通过binder_has_proc_work()读取proc的事务;若没有则直接返回。</span></div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (non_block) &#123;</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    &#125;</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line">    </div><div class="line">       ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>由于传入的参数*consumed==0,所以写入一个值BR_NOOP到ptr指向的缓冲区(即用户传入的bwr_read_buffer缓冲区)中</p>
</li>
<li><p>由于thread-&gt;transaction_stack==NULL，而且thread-&gt;todo列表也为空，所以wait_for_proc_work为true,表示要去查看proc是否有未处理的事务 </p>
</li>
<li><p>当前thread-&gt;return_error==BR_OK,这是前面创建binder_thread时设置的，所以继续往下执行，设置thread的状态为BINDER_LOOPER_STATE_WAITING，表示线程处于等待状态 </p>
</li>
<li><p>调用binder_set_nice()函数设置当前线程的优先级与当前进程的默认优先级，这是因为thread要去处理属于proc的事务，因此要将thread的优先级设置得和proc一样</p>
</li>
<li><p>在当前场景中，proc没有事务需要处理，即binder_has_proc_work(proc,thread)为false. 如果文件打开模式为非阻塞式，即non_block为true,那么函数就直接返回-EAGAIN,要求用户重新执行ioctl();否则当前线程就通过wait_event_interruptible_exclusive()函数进入休眠状态，等待请求到来再被唤醒</p>
</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此，我们就分析完了Context Manager(也可以称为Service Manager)是如何将自身注册到Binder Driver中并且成为守护进程的。总结起来主要是分为以下几步：  </p>
<ul>
<li><p>1)打开/dev/binder文件:open(“/dev/binder”,O_RDWR);  </p>
</li>
<li><p>2)建立128K内存映射: mmap(NULL,mapsize,PORT_READ_MAP_PRIVATE,bs-&gt;fd,0);  </p>
</li>
<li><p>3)通知Binder Driver它是上下文管理者：binder_become_context_manager(bs);  </p>
</li>
<li><p>4)进入循环状态等待请求的到来: binder_loop(bs,svcmgr_handler);  </p>
</li>
</ul>
<p>在这个过程中，在Binder Driver中新建了一个struct binder_proc对象、一个struct binder_thread对象和一个struct binder_node对象。下一篇博客将讲解获取服务的过程。 </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/24/2016-02-24-android-binderji-zhi-1-binderjia-gou-fen-xi/" rel="next" title="Android Binder机制(1):Binder架构分析">
                <i class="fa fa-chevron-left"></i> Android Binder机制(1):Binder架构分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/02/27/2016-02-27-android-binderji-zhi-3-ben-di-fu-wu-zhu-ce-guo-cheng/" rel="prev" title="Android Binder机制(3) 本地服务注册过程">
                Android Binder机制(3) 本地服务注册过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">147</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-启动运行Context-Manager的main-函数"><span class="nav-number">2.</span> <span class="nav-text">1.启动运行Context Manager的main()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-binder-open-函数分析"><span class="nav-number">3.</span> <span class="nav-text">2.binder_open()函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-驱动函数注册"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 驱动函数注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-binder-open"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 binder_open()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-驱动中的binder-oepn"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 驱动中的binder_oepn()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-mmap-分析"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 mmap()分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-binder-update-page-range"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 binder_update_page_range()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-binder-become-context-manager"><span class="nav-number">4.</span> <span class="nav-text">3.binder_become_context_manager()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-struct-binder-thread分析"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 struct binder_thread分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-struct-binder-node分析"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 struct binder_node分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-binder-ioctl-逻辑分析"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 binder_ioctl()逻辑分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-binder-get-thread-方法"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.3.1 binder_get_thread()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-binder-new-node-方法"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.3.2 binder_new_node()方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-binder-loop-分析"><span class="nav-number">5.</span> <span class="nav-text">4. binder_loop()分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-binder-write-分析"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 binder_write()分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-binder-ioctl-分析"><span class="nav-number">5.1.1.</span> <span class="nav-text">4.1.1 binder_ioctl()分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-binder-loop-中的for循环分析"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 binder_loop()中的for循环分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-总结"><span class="nav-number">6.</span> <span class="nav-text">5.总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
