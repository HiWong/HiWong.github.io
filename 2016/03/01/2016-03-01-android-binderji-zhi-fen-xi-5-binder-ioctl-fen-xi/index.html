<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="引言在博客Android Binder机制(3)本地服务注册过程这篇博客中我们详细讲解了本地服务的注册过程，除了一个地方之外，那就是IPCThreadState::waitForResponse()方法中的talkWithDriver()，而在talkWithDriver()中调用了binder_ioctl()，由于内容太多，所以专门写一篇博客进行分析。   实际上，不只是在服务注册过程中会调用到">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Binder机制分析(5) binder_ioctl()分析">
<meta property="og:url" content="http://yoursite.com/2016/03/01/2016-03-01-android-binderji-zhi-fen-xi-5-binder-ioctl-fen-xi/index.html">
<meta property="og:site_name" content="AllenWang的个人博客">
<meta property="og:description" content="引言在博客Android Binder机制(3)本地服务注册过程这篇博客中我们详细讲解了本地服务的注册过程，除了一个地方之外，那就是IPCThreadState::waitForResponse()方法中的talkWithDriver()，而在talkWithDriver()中调用了binder_ioctl()，由于内容太多，所以专门写一篇博客进行分析。   实际上，不只是在服务注册过程中会调用到">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/binder_flow.png">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/binder_transaction_data_ipc.png">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/binder_write_read_vs_transaction_data.png">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/service_register.png">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/binder_flow_stage2.png">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/register_ipc.png">
<meta property="og:updated_time" content="2017-12-03T20:21:03.331Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Binder机制分析(5) binder_ioctl()分析">
<meta name="twitter:description" content="引言在博客Android Binder机制(3)本地服务注册过程这篇博客中我们详细讲解了本地服务的注册过程，除了一个地方之外，那就是IPCThreadState::waitForResponse()方法中的talkWithDriver()，而在talkWithDriver()中调用了binder_ioctl()，由于内容太多，所以专门写一篇博客进行分析。   实际上，不只是在服务注册过程中会调用到">
<meta name="twitter:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/binder_flow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/03/01/2016-03-01-android-binderji-zhi-fen-xi-5-binder-ioctl-fen-xi/"/>





  <title>Android Binder机制分析(5) binder_ioctl()分析 | AllenWang的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AllenWang的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小楼一夜听春雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ad">
          <a href="/ad/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            menu.ad
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/01/2016-03-01-android-binderji-zhi-fen-xi-5-binder-ioctl-fen-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AllenWang的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android Binder机制分析(5) binder_ioctl()分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-01T10:11:50+08:00">
                2016-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android-deep-analysis/" itemprop="url" rel="index">
                    <span itemprop="name">android_deep_analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在博客<a href="http://blog.imallen.wang/blog/2016/02/27/android-binderji-zhi-3-ben-di-fu-wu-zhu-ce-guo-cheng/" target="_blank" rel="external">Android Binder机制(3)本地服务注册过程</a>这篇博客中我们详细讲解了本地服务的注册过程，除了一个地方之外，那就是IPCThreadState::waitForResponse()方法中的talkWithDriver()，而在talkWithDriver()中调用了binder_ioctl()，由于内容太多，所以专门写一篇博客进行分析。  </p>
<p>实际上，不只是在服务注册过程中会调用到Binder Driver中的binder_ioctl()，在服务检索、服务使用阶段都会调用到binder_ioctl()，所以这篇博客将分这3个阶段详细讲解binder_ioctl()方法。  </p>
<p>并且，这3个阶段均可按Binder数据的传递划分为6个阶段，如下所示<a id="more"></a>：  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/binder_flow.png" alt="binder_flow"></p>
<p>本文中对于服务注册、服务检索、服务使用都分这6个阶段进行讲解。  </p>
<p>另外，由于在博客<a href="http://blog.imallen.wang/blog/2016/02/27/android-binderji-zhi-2-contextmanagerzhu-ce-guo-cheng-fen-xi/" target="_blank" rel="external">Android Binder机制(2) ContextManager注册过程分析</a>中详细分析过binder_open和binder_mmap()函数，这里就不再讲解了，不了解的小伙伴可以移步到那篇Blog中。  </p>
<p>在开始之前，我们先补充一些基础知识。  </p>
<ul>
<li><p>1) ioctl的BINDER_WRITE_READ命令用来请求Binder Driver发送或接收IPC数据以及IPC应答数据  </p>
</li>
<li><p>2) binder_ioctl()函数负责在两个进程间收发IPC数据以及IPC应答数据。因此，在分析binder_ioctl()函数时，必然要涉及到发送IPC数据和接收IPC数据的两个进程。  </p>
</li>
<li><p>3) binder_write_read结构体的定义如下：  </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span>&#123;</span></div><div class="line">    <span class="comment">//bytes to write</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; </div><div class="line">    <span class="comment">//bytes consumed by driver</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> write_buffer;</div><div class="line">    <span class="comment">//bytes to read</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;</div><div class="line">    <span class="comment">//bytes consumed by driver</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> read_buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>write_buffer成员变量用于发送IPC数据或IPC应答数据。而read_buffer成员变量用来接收来自Binder Driver的数据，即Binder Driver在接收IPC数据或IPC应答数据后，将它们保存到read_buffer中，而后再传递到用户空间中。</li>
<li>write_size与read_size分别用来指定write_buffer与read_buffer的数据大小</li>
<li>write_consumed与read_consumed分别用来设定write_buffer与read_buffer中被处理的数据大小</li>
<li>在前面的学习中，我们知道IPC数据与IPC应答数据由Handle、RPC代码、RPC数据、Binder协议构成。其中Handle、RPC代码、RPC数据保存在名称为binder_transaction_data的结构体中。如下图所示：  </li>
</ul>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/binder_transaction_data_ipc.png" alt="binder_transaction_data_ipc"></p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/binder_write_read_vs_transaction_data.png" alt="binder_write_read_vs_binder_transaction_data"></p>
<ul>
<li><p>如上图所示，binder_write_read的write_buffer指向含有Binder协议和binder_transaction_data的内存区域，在Binder Driver处理IPC数据时它们被作为一个处理单元。通常这种处理单元能被连续加载到write_buffer中，但为了说明的方便，只考虑有一个IPC数据的情形。同样，read_buffer指向由Binder协议与binder_transaction_data指向的内存区域</p>
</li>
<li><p>binder_write_read结构体中包含着用户空间中生成的IPC数据，Binder Driver也拥有一个相同的结构体。用户空间设置完binder_write_read结构体的数据后，调用ioctl()函数传递给Binder Driver，Binder Driver调用copy_from_user()函数将用户空间中的数据拷贝到自身的binder_write_read结构体中。相反，在传递IPC应答数据时，Binder Driver将调用copy_to_user()函数，将自身binder_write_read结构体中的数据拷贝到用户空间。</p>
</li>
</ul>
<h2 id="1-服务注册"><a href="#1-服务注册" class="headerlink" title="1.服务注册"></a>1.服务注册</h2><h3 id="1-1-过程概览"><a href="#1-1-过程概览" class="headerlink" title="1.1 过程概览"></a>1.1 过程概览</h3><p>服务注册过程的示意图如下所示：  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/service_register.png" alt="service_register"></p>
<p>通过前面的博客我们知道，Context Manager先于其他所有Service Server进行，它最先使用Binder Driver，进入待机状态，之后等待Service Server的服务注册请求或者Client的服务检索请求。<br>上图所示过程如下：  </p>
<ul>
<li><p>1)Context Manager通过open()函数调用binder_open()函数，Binder Driver使用该函数为Context Manager生成并初始化binder_proc结构体;  </p>
</li>
<li><p>2)Context Manager在内核空间中开辟一块Buffer，用于接收IPC数据。Context Manager通过mmap()函数调用Binder Driver的binder_mmap()函数。Binder Driver使用binder_mmap()函数在内核空间中分配一块用于接收IPC数据的Buffer，其大小为调用mmap()函数时指定的大小，并被保存到binder_buffer结构体中。而后binder_buffer变量被注册到binder_proc结构体中;  </p>
</li>
<li><p>3)Context Manager通过ioctl()调用Binder Driver的binder_ioctl()函数。在binder_ioctl()函数中，Context Manager将处于待机状态，直到另一个进程（在服务注册阶段是指Service Server)向共发送IPC数据;  </p>
</li>
<li><p>4)Service Server通过open()调用Binder Driver的binder_open()函数，Binder Driver为Service Server生成binder_proc结构体，并将其初始化;  </p>
</li>
<li><p>5)Service Server通过mmap()调用Binder Driver的binder_mmap()函数.Binder Driver开辟一块用于接收IPC应答数据的Buffer，并将其保存到binder_buffer结构体中。而后Service Server生成IPC数据，用来调用Context Manager的服务注册函数;  </p>
</li>
<li><p>6)为了注册服务，Service Server将IPC数据传递给Binder Driver。Binder Driver将根据IPC数据中的Handle查找到Context Manager的binder_node结构体，以及binder_proc结构体;  </p>
</li>
<li><p>7)为Service Server要注册的服务生成binder_node结构体。Binder Driver将binder_node分别注册到Service Server的binder_proc结构体以及Context Manager的binder_proc结构体中;  </p>
</li>
<li><p>8)Binder Driver将在6)中查找到的Context Manager的binder_proc结构体中查找注册在binder_buffer结构体中的Buffer，并传递IPC数据;  </p>
</li>
<li><p>9)Binder Driver会记下IPC数据发送进程(Service Server)的binder_proc结构体，以便在Context Manager向Service Server发送应答数据时查找Serivce Server的binder_proc结构体;  </p>
</li>
<li><p>10)Binder Driver让Service Server处于待机状态，并将Context Manager从待机状态中唤醒，传递IPC数据。从待机状态中唤醒的Context Manager经由Binder Driver接收来自Service Server的IPC数据。Context Manager根据接收的IPC数据注册指定的服务，而后生成IPC应答数据(通知服务注册完成),并将其传递给Binder Driver;  </p>
</li>
<li><p>11)Binder Driver会在9)中的Service Server的binder_proc结构体中查找注册在binder_buffer结构体中的Buffer，并传送IPC应答数据，唤醒接收端的Service Server。Service Server被唤醒后，接收IPC应答数据，并根据接收的IPC应答数据进行相应处理。  </p>
</li>
</ul>
<h3 id="1-2-传递Binder数据的阶段1"><a href="#1-2-传递Binder数据的阶段1" class="headerlink" title="1.2 传递Binder数据的阶段1"></a>1.2 传递Binder数据的阶段1</h3><p>Context Manager调用binder_open()与binder_mmap()函数，初始化binder_proc结构体，创建用于接收IPC数据的binder_buffer结构体。  </p>
<p>在用户空间中生成一块Buffer，将read_buffer注册到binder_write_read结构体中，而后调用ioctl()函数，此时，binder_write_read结构体的read_size指的是用户空间的Buffer的大小。此时binder_ioctl()中调用的主要代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file*flip,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span>*<span class="title">proc</span>=<span class="title">flip</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="keyword">void</span> __user*ubuf=(<span class="keyword">void</span> __user*)arg;</div><div class="line">    thread=binder_get_thread(proc);</div><div class="line">    <span class="keyword">switch</span>(cmd)&#123;</div><div class="line">        <span class="keyword">case</span> BINDER_WRITE_READ:</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">            <span class="keyword">if</span>(copy_from_user(&amp;bwr,ubuf,<span class="keyword">sizeof</span>(bwr)))</div><div class="line">            <span class="keyword">if</span>(bwr.write_size&gt;<span class="number">0</span>)&#123;</div><div class="line">                ret=binder_thread_write(proc,thread,</div><div class="line">                    (<span class="keyword">void</span> __user*)bwr.write_buffer,bwr.write_size,</div><div class="line">                    &amp;bwr.write_consumed);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(bwr.read_size&gt;<span class="number">0</span>)&#123;</div><div class="line">                ret=binder_thread_read(proc,thread,</div><div class="line">                    (<span class="keyword">void</span> __user*)bwr.read_buffer,bwr.read_size,&amp;bwr.read_consumed,</div><div class="line">                    flip-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>binder_ioctl()函数的第二个参数cmd是ioctl()的命令，第三个参数arg是binder_write_read结构体，它是调用ioctl()函数时使用的参数。  </p>
<ul>
<li>flip-&gt;private_data是在binder_open()函数中创建的binder_proc结构体</li>
<li>由于proc的线程红黑树中还没有新建相应的线程，故在binder_get_thread()函数中新建一个binder_thread结构体</li>
<li>分析ioctl()命令，前面已经说过，此时传递的命令是BINDER_WRITE_READ</li>
<li>调用copy_from_user()方法将Context Manager持有的用户空间的binder_write_read结构体复制到内核空间中。而后根据read_size与write_size变量判断是发送IPC数据，还是接收IPC应答数据。Context Manager在接收IPC数据时，将生成相应的read_buffer，并且read_size的值将大于0</li>
<li>由于read_size&gt;0，故调用binder_thread_read()函数</li>
</ul>
<h4 id="1-2-1-binder-thread-read-分析"><a href="#1-2-1-binder-thread-read-分析" class="headerlink" title="1.2.1 binder_thread_read()分析"></a>1.2.1 binder_thread_read()分析</h4><p>binder_thread_read()中调用到的代码如下所示：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">    struct binder_thread *thread,<span class="keyword">void</span> __user*buffer,<span class="keyword">int</span> size,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">signed</span> <span class="keyword">long</span> *consumed,<span class="keyword">int</span> non_block)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ...</div><div class="line">    ret=wait_event_interruptible_exclusive(proc-&gt;wait,</div><div class="line">        binder_has_proc_work(proc,thread));</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Context Manager在binder_thread_read()函数中调用wait_event_interruptible_exclusive()函数。wait_event_interruptible_exclusive()函数通过当前进程的binder_proc结构体的wait变量将当前任务注册到待机队列中。而后将task_struct结构体内的state变量由TASK_RUNNING更改为TASK_INTERRUPTIBLE，再调用schedule()函数。当Context Manager的任务阙云太为TASK_INTERRUPTIBLE时，Context Manager就不再继续运行，它将进入待机状态，直至接收到IPC数据。  </p>
<h3 id="1-3-传递Binder数据的阶段2"><a href="#1-3-传递Binder数据的阶段2" class="headerlink" title="1.3 传递Binder数据的阶段2"></a>1.3 传递Binder数据的阶段2</h3><p>这个阶段其实对应的是诸如MediaPlayerService::instantiate();这样的过程，只不过我们这里只从Binder Driver的角度考虑问题，所以只讨论ioctl()函数。  </p>
<p>这个阶段的示意图如下：  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/binder_flow_stage2.png" alt="binder_flow_stage2"></p>
<p>Service Server也会生成binder_write_read结构体，包含write_buffer与read_buffer两个成员变量。其中，read_buffer变量用于接收IPC应答数据，write_buffer变量用于发送IPC数据。binder_write_read结构体内容如下图所示：  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/register_ipc.png" alt="binder_ipc"></p>
<p>此时binder_ioctl()函数中执行的主要代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file*filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span>*<span class="title">proc</span>=<span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="keyword">void</span> __user *ubuf=(<span class="keyword">void</span> __user*)arg;</div><div class="line">    thread=binder_get_thread(proc);</div><div class="line">    <span class="keyword">switch</span>(cmd)&#123;</div><div class="line">        <span class="keyword">case</span> BINDER_WRITE_READ:&#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">            <span class="keyword">if</span>(copy_from_user(&amp;bwr,ubuf,<span class="keyword">sizeof</span>(bwr)))&#123;</div><div class="line">                ret=-EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(bwr.write_size&gt;<span class="number">0</span>)&#123;</div><div class="line">                ret=binder_write(proc,thread,(<span class="keyword">void</span> __user*)bwr.write_buffer,bwr.write_size,&amp;bwr.write_consumed);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(bwr.read_size&gt;<span class="number">0</span>)</div><div class="line">                ret=binder_thread_read(proc,thread,(<span class="keyword">void</span> __user*)bwr.read_buffer,bwr.read_size,&amp;bwr.read_consumed);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Service Server调用binder_get_thread()函数生成binder_thread对象</li>
<li>调用copy_from_user()函数，将调用空间的binder_write_read结构体拷贝至内核空间中。为了传递IPC数据，Service Server保存了binder_write_read结构体的write_buffer数据，故write_size&gt;0</li>
<li>由于write_size&gt;0,故调用binder_thread_write()函数</li>
</ul>
<p>binder_thread_write()函数的主要代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> cmd;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">       </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>buffer+*consumed指向的是当前write_buffer中要处理的数据;buffer+size则指向缓冲区的末尾</li>
<li>调用get_user()函数的目的是将IPC数据中的Binder协议拷贝至内核空间中。在服务注册时，所使用的Binder协议是BC_TRANSACTION</li>
<li>调用copy_from_user()函数，将IPC数据中不包含Binder协议的binder_transaction_data结构体复制到内核空间中</li>
<li>调用binder_transaction()函数，binder_transaction)函数使用binder_transaction_data结构体中的数据来执行Binder寻址、复制Binder IPC数据、生成及检索Binder节点等操作</li>
</ul>
<p>binder_transaction()方法的主要代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">               struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">               struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></div><div class="line">    <span class="keyword">size_t</span> *offp, *off_end;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error;</div><div class="line">    e = binder_transaction_log_add(&amp;binder_transaction_log);</div><div class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</div><div class="line">    e-&gt;from_proc = proc-&gt;pid;</div><div class="line">    e-&gt;from_thread = thread-&gt;pid;</div><div class="line">    e-&gt;target_handle = tr-&gt;target.handle;</div><div class="line">    e-&gt;data_size = tr-&gt;data_size;</div><div class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        in_reply_to = thread-&gt;transaction_stack;</div><div class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</div><div class="line">            </div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</div><div class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">goto</span> err_bad_call_stack;</div><div class="line">        &#125;</div><div class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</div><div class="line">        target_thread = in_reply_to-&gt;from;</div><div class="line">       </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            in_reply_to = <span class="literal">NULL</span>;</div><div class="line">            target_thread = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">goto</span> err_dead_binder;</div><div class="line">        &#125;</div><div class="line">        target_proc = target_thread-&gt;proc;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</div><div class="line">            struct binder_ref *ref;</div><div class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">            target_node = ref-&gt;node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">            </div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        e-&gt;to_node = target_node-&gt;debug_id;</div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (target_proc == <span class="literal">NULL</span>) &#123;</div><div class="line">            return_error = BR_DEAD_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_dead_binder;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></div><div class="line">            tmp = thread-&gt;transaction_stack;</div><div class="line">          </div><div class="line">            ...</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (tmp) &#123;</div><div class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</div><div class="line">                    target_thread = tmp-&gt;from;</div><div class="line">                tmp = tmp-&gt;from_parent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (target_thread) &#123;</div><div class="line">        e-&gt;to_thread = target_thread-&gt;pid;</div><div class="line">        target_list = &amp;target_thread-&gt;todo;</div><div class="line">        target_wait = &amp;target_thread-&gt;wait;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        target_list = &amp;target_proc-&gt;todo;</div><div class="line">        target_wait = &amp;target_proc-&gt;wait;</div><div class="line">    &#125;</div><div class="line">    e-&gt;to_proc = target_proc-&gt;pid;</div><div class="line">    <span class="comment">/* <span class="doctag">TODO:</span> reuse incoming transaction for reply */</span></div><div class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</div><div class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line">    t-&gt;debug_id = ++binder_last_id;</div><div class="line">    e-&gt;debug_id = t-&gt;debug_id;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</div><div class="line">        t-&gt;from = thread;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t-&gt;from = <span class="literal">NULL</span>;</div><div class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</div><div class="line">    t-&gt;to_proc = target_proc;</div><div class="line">    t-&gt;to_thread = target_thread;</div><div class="line">    t-&gt;code = tr-&gt;code;</div><div class="line">    t-&gt;flags = tr-&gt;flags;</div><div class="line">    t-&gt;priority = task_nice(current);</div><div class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</div><div class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</div><div class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</div><div class="line">    t-&gt;buffer-&gt;transaction = t;</div><div class="line">    t-&gt;buffer-&gt;target_node = target_node;</div><div class="line">    <span class="keyword">if</span> (target_node)</div><div class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</div><div class="line">       </div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>))) &#123;</div><div class="line">       </div><div class="line">        ...</div><div class="line"></div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_bad_offset;</div><div class="line">    &#125;</div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></div><div class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</div><div class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</div><div class="line">                <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</div><div class="line">                &#125;</div><div class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</div><div class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</div><div class="line">            &#125;</div><div class="line">         </div><div class="line">            ...</div><div class="line"></div><div class="line">            ref = binder_get_ref_for_node(target_proc, node);</div><div class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</div><div class="line">                return_error = BR_FAILED_REPLY;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</div><div class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</div><div class="line">            fp-&gt;handle = ref-&gt;desc;</div><div class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</div><div class="line">                       &amp;thread-&gt;todo);</div><div class="line">           </div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        ...</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        binder_pop_transaction(target_thread, in_reply_to);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</div><div class="line">        t-&gt;need_reply = <span class="number">1</span>;</div><div class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</div><div class="line">        thread-&gt;transaction_stack = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        BUG_ON(target_node == <span class="literal">NULL</span>);</div><div class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) &#123;</div><div class="line">            target_list = &amp;target_node-&gt;async_todo;</div><div class="line">            target_wait = <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先，由于tr-&gt;target.handle为0，故执行另一个分支，从而target_node=binder_context_mgr_node;即为Context Manager对应的binder_node，从而target_proc对应的是Context Manager的proc</p>
</li>
<li><p>由于target_thread为NULL，故执行else中的内容，从而将binder_proc数据结构中的todo变量赋给target_list，以指定要执行的任务;同时将target_proc的等待队列赋给target_wait;</p>
</li>
<li><p>变量t是一个指向binder_transactoin结构体的指针</p>
</li>
</ul>
<p>IPC数据发送端与接收端通过struct binder_transaction来收发IPC数据，该结构体的定义如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</div><div class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">long</span>    priority;</div><div class="line">    <span class="keyword">long</span>    saved_priority;</div><div class="line">    <span class="keyword">uid_t</span>   sender_euid;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>t-&gt;from=thread;中的目的是查找发送IPC数据的进程，以便发送IPC应答数据，在收发Binder数据的第5个阶段中会用到</p>
</li>
<li><p>t-&gt;code=tr-&gt;code;目的是将IPC数据的RPC代码赋给binder_transaction结构体的code变量</p>
</li>
<li><p>binder_alloc_buf()函数的作用是分配一块空间，用于从接收端的IPC数据接收缓冲区中复制IPC数据。该接收缓冲空间由接收端在binder_mmap()函数中确定，binder_proc结构体的free_buffers指向该区域</p>
</li>
<li><p>copy_from_user(t-&gt;buffer-&gt;data,tr-&gt;data.ptr.buffer,tr-&gt;data_size);的作用是拷贝RPC数据到binder_buffer结构体的data变量中</p>
</li>
</ul>
<p><strong>至此，Binder数据发送端设置binder_transaction结构体的过程结束了。接下来，接收端将从待机状态中苏醒。并从该结构体中获取数据。</strong></p>
<ul>
<li><p>调用binder_get_node()函数，在注册至binder_proc结构体中的Binder节点中，确认当前的Binder节点是否已经存在。由于首次注册，故不存在，从而新建节点。</p>
</li>
<li><p>调用binder_new_node()函数不仅会创建新的binder_node，新生成的节点还会被注册到当前进程的binder_proc结构体中</p>
</li>
<li><p>调用binder_get_ref_for_node()函数，检查指定的Binder节点是否已经存在于指定的binder_proc结构体中。若存在，则返回Binder节点所在的binder_ref结构体，否则新建binder_ref结构体并将指定的Binder节点注册其中，而后将其返回。另外,binder_get_ref_for_node()函数也将binder_ref结构体注册到binder_proc中的refs_by_node中</p>
</li>
<li><p>接下来将BINDER_WORK_TRANSACTION赋值给t-&gt;work.type，这个值在第4个阶段会用到。当将type设置为BINDER_WORK_TRANSACTION时，Context Manager从binder_transaction结构体中获取Service Server传递而来的IPC数据，在第4阶段会详细讲解</p>
</li>
<li><p>调用wake_up_interruptible()函数，并使用之前赋值过的target_wait作为参数，将Context Manager从待机状态中唤醒。在接下来的进程调度中，Context Manager将执行第4阶段的相应任务。</p>
</li>
</ul>
<h3 id="1-4-传递Binder数据的阶段3"><a href="#1-4-传递Binder数据的阶段3" class="headerlink" title="1.4 传递Binder数据的阶段3"></a>1.4 传递Binder数据的阶段3</h3><p>在传递Binder数据的第1个阶段中，Context Manager通过binder_write_read结构体的read_buffer进入到待机状态中。类似地，Service Server完成写入数据后，在binder_thread_read()中进入待机状态。Service Server将在收发Binder数据的第6个阶段中苏醒，接收IPC应答数据。  </p>
<h3 id="1-5-传递Binder数据的阶段4"><a href="#1-5-传递Binder数据的阶段4" class="headerlink" title="1.5 传递Binder数据的阶段4"></a>1.5 传递Binder数据的阶段4</h3><p>Context Manager被唤醒后，将执行binder_thread_read()中接下来的动作。如下所示：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">uint32_t</span> cmd;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transacton_data</span> <span class="title">tr</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>=<span class="title">NULL</span>;</span></div><div class="line">    <span class="keyword">if</span>(!list_empty(&amp;proc-&gt;todo)&amp;&amp;wait_for_proc_work)</div><div class="line">        w=list_first_entry(&amp;proc-&gt;todo,struct binder_work,entry);</div><div class="line">    <span class="keyword">switch</span>(w-&gt;type)&#123;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION:&#123;</div><div class="line">            t=container_of(w,struct binder_transaction,work);</div><div class="line">        &#125;<span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用list_first_entry()函数，查找Service Server在前面代码中注册的binder_work结构体，并将查找到的binder_work结构体返回。list_first_entry()函数是container_of()函数的引用函数，container_of()函数将根据首个参数查找到包含该参数的结构体的首地址。</p>
</li>
<li><p>若binder_work结构体的type成员变量值为BINDER_WORK_TRANSACTION，则继续调用container_of()函数，查找持有binder_work结构体的binder_transaction结构体</p>
</li>
</ul>
<p>之后，Context Manager通过Service Server创建的binder_transaction结构体获取IPC数据，并将IPC数据保存到binder_transaction_data结构体，以便将IPC数据传递到用户空间中，代码如下所示：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tr.code=t-&gt;code;</div><div class="line">tr.data_size=t-&gt;buffer-&gt;data_size;</div><div class="line"><span class="comment">//code_1</span></div><div class="line">tr.data.ptr.buffer=(<span class="keyword">void</span>*)t-&gt;buffer-&gt;data+proc-&gt;user_buffer_offset;</div></pre></td></tr></table></figure>
<p>前面的代码都很好理解，关键是code_1处。内核空间接收Buffer的地址为t-&gt;buffer-&gt;data,而proc-&gt;user_buffer_offset则指用户空间的接收Buffer与内核空间的接收Buffer间的地址偏移。因此tr.data.ptr.buffer保存的是用户空间中接收Buffer的地址。binder_write_read结构体存在于用户空间中，read_buffer是binder_write_read结构体的成员变量，它可以引用保存在tr.data.ptr.buffer所指的用户空间中的IPC数据。在向接收端传递数据时,Binder IPC也采用相同的方法，将内核空间中的数据传递到用户空间中，而不需要调用copy_to_user()函数。通过这种方式，可以避免在内核空间与用户空间之间拷贝数据，从而提升IPC动作的效率。  </p>
<p>接下来，就要将binder_transaction_data中的数据传递到用户空间中。从该阶段开始，数据将被保存到Context Manager的read_buffer中，相应的代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">cmd=BR_TRANSACTION;</div><div class="line"><span class="keyword">if</span>(put_user(cmd,(<span class="keyword">uint32_t</span> __user*)ptr))</div><div class="line">    <span class="keyword">return</span> -EFAULT;</div><div class="line">ptr+=<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);\</div><div class="line"><span class="keyword">if</span>(copy_to_user(ptr,&amp;tr,<span class="keyword">sizeof</span>(tr)))</div><div class="line">    <span class="keyword">return</span> -EFAULT;</div><div class="line"><span class="keyword">if</span>(cmd==BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY))&#123;</div><div class="line">    t-&gt;to_parent=thread-&gt;transaction_stack;</div><div class="line">    t-&gt;to_thread=thread;</div><div class="line">    thread-&gt;transaction_stack=t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先设置Binder协议为BR_TRANSACTION,准备处理Context Manager的IPC数据</p>
</li>
<li><p>*ptr指向binder_write_read结构体的read_buffer成员变量，在传递Binder数据的第1个阶段中，Context Manager在进入待机状态前调用ioctl()函数时，它作为一个参数被传入函数中</p>
</li>
<li><p>*ptr指向binder_write_read结构体的read_buffer成员变量</p>
</li>
<li><p>利用copy_to_user()将之前生成的binder_transaction_data结构体拷贝到read_buffer中</p>
</li>
<li><p>thread-&gt;transaction_stack=t;的目的是将当前的binder_transaction结构体注册到binder_thread结构体的transaction_stack中。binder_transaction结构体在传递Binder IPC数据的第5个阶段中用于查找IPC应答数据的接收端</p>
</li>
</ul>
<p>1.6 传递Binder数据的阶段5  </p>
<p>在此阶段中，Context Manager将处理接收到的IPC数据，而后向Service Server发送IPC数据，告知处理已经完成。该阶段 数据传递过程与传递Binder数据的第2个阶段类似，涉及到的Binder协议分别是BC_REPLY(Contxt Manager–&gt;Binder Driver)和BR_REPLY(Binder Driver–&gt;Context Manager).  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(reply)&#123;</div><div class="line">    in_reply_to=thread-&gt;transaction_stack;</div><div class="line">    thread-&gt;transaction_stack=in_reply_to-&gt;to_parent;</div><div class="line">    target_thread=in_reply_to-&gt;from;</div><div class="line">    target_proc=target_thread-&gt;proc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首先由thread-&gt;transaction_stack获取前面刚刚讲解过的注册的binder_transaction结构体</p>
</li>
<li><p>之后由in_reply_to-&gt;from获取Service Server的binder_thread结构体</p>
</li>
<li><p>由binder_thread即可获取Service Server的binder_proc，从而可以获得Service Server的接收端Buffer.之后将IPC应答数据保存到binder_transaction中。然后Service Server从待机状态中苏醒，查找相应的结构体，将IPC应答数据传递到用户空间中。由于该吉祥平安福且贵与传递Binder数据的阶段2类似，故不再赘述。</p>
</li>
</ul>
<h3 id="1-7-传递Binder数据的阶段6"><a href="#1-7-传递Binder数据的阶段6" class="headerlink" title="1.7 传递Binder数据的阶段6"></a>1.7 传递Binder数据的阶段6</h3><p>Service Server从待机状态中苏醒后，其行为动作与传递Binder数据第4个阶段类似，不同的是所使用的Binder协议为BR_REPLY.Service Server接收完IPC应答数据后将在用户空间中进行一系列与IPC应答数据相关的动作。</p>
<h2 id="2-服务检索阶段"><a href="#2-服务检索阶段" class="headerlink" title="2.服务检索阶段"></a>2.服务检索阶段</h2><p>在服务检索阶段，调用binder_ioctl()函数，将服务客户端的IPC数据发送到Context Manager，并将Context Manager的IPC应答数据发送到客户端。  </p>
<h3 id="2-1-传递Binder数据的阶段1"><a href="#2-1-传递Binder数据的阶段1" class="headerlink" title="2.1 传递Binder数据的阶段1"></a>2.1 传递Binder数据的阶段1</h3><p>该阶段类似注册服务时传递Binder数据的第1个阶段，Context Manager进入待机状态，等待接收IPC数据。  </p>
<h3 id="2-2-传递Binder数据的阶段2"><a href="#2-2-传递Binder数据的阶段2" class="headerlink" title="2.2 传递Binder数据的阶段2"></a>2.2 传递Binder数据的阶段2</h3><p>在该阶段中Binder Driver的行为动作类似于注册服务时传递Binder数据的第2个阶段。但是发送IPC数据的进程不是Service Server，而是服务客户端。<br>服务客户端并不注册服务，所以在其RPC数据中不会存在flat_binder_object结构体。在服务客户端生成的IPC数据中包含Context Manager的Handle(0),RPC代码(服务检索函数)以及请求的服务名称。<br>需要注意的是，由于IPC数据中不包含flag_binder_object对象，所以不会创建binder_node对象。其他动作与服务注册传递Binder的阶段2是一样的。  </p>
<h3 id="2-3-传递Binder数据的阶段3"><a href="#2-3-传递Binder数据的阶段3" class="headerlink" title="2.3 传递Binder数据的阶段3"></a>2.3 传递Binder数据的阶段3</h3><p>与Service Server类似，服务客户端既发送IPC数据，又接收IPC应答数据，它会使用binder_write_read结构体的write_buffer与read_buffer两个成员变量。同服务注册阶段的传递IPC数据的第3个阶段一样，服务客户端将进入待机状态中，等待接收IPC应答数据。  </p>
<h3 id="2-4-传递Bindder数据的阶段4"><a href="#2-4-传递Bindder数据的阶段4" class="headerlink" title="2.4 传递Bindder数据的阶段4"></a>2.4 传递Bindder数据的阶段4</h3><p>该阶段与服务注册阶段的阶段4类似。Context Manager接收IPC数据后，会在服务目录中生成binder_object结构体，该结构体中包含着与服务名称相对应的服务目录编号。并且，将结构体中的type变量设置为BINDER_TYPE_HANDLE，生成IPC应答数据。binder_object会被复制到Binder Driver的flat_binder_object中，用来查找Binder节点。在下一个阶段中，通过binder_object数据，将Binder节点传递给服务客户端。  </p>
<h3 id="2-5-传递Binder数据的阶段5"><a href="#2-5-传递Binder数据的阶段5" class="headerlink" title="2.5 传递Binder数据的阶段5"></a>2.5 传递Binder数据的阶段5</h3><p>在该阶段中，服务客户端将获取所用服务的Binder节点。在服务注册阶段,flat_binder_object结构体的type变量为BINDER_TYPE_BINDER，继而生成Binder节点。但是在服务检索阶段，type为BINDER_TYPE_HANDLE，Binder节点被传递给服务客户端，主要代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fp=(struct flat_binder_object*)(t-&gt;buffer-&gt;data+*offp);</div><div class="line"><span class="keyword">switch</span>(fp-&gt;type)&#123;</div><div class="line">    <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">    <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE:</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span>*<span class="title">ref</span>=<span class="title">binder_get_ref</span>(<span class="title">proc</span>,<span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></div><div class="line">        <span class="keyword">if</span>(ref-&gt;node-&gt;proc==target_proc)&#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            struct binder_ref*new_ref;</div><div class="line">            new_ref=binder_get_ref_for_node(target_proc,ref-&gt;node);</div><div class="line">            fp-&gt;handle=new_ref-&gt;desc;</div><div class="line">        &#125;<span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用binder_get_ref()函数，其第一个参数proc为Context Manager的binder_proc，第二个参数fp-&gt;handle是服务客户端要使用的服务编号。服务编号即binder_ref结构体中desc变量的值。将desc的值传入binder_get_ref()函数后，即可获得与服务编号相对应的binder_ref结构体，此结构体由Context Manager持有</p>
</li>
<li><p>调用binder_get_ref_for_node()函数，其中第一个参数target_proc是服务客户端的binder_proc结构体，第二个参数ref-&gt;node是ref对应的binder_node对象。在该函数内部，将为接收的binder_node结构体创建新的binder_ref结构体，并将其指向binder_node结构体</p>
</li>
<li><p>修改RPC数据中flat_binder_object结构体内的服务编号，将其设置为当前binder_ref结构体的desc编号。而后在下一个阶段中，将包含修改后的RPC数据的IPC应答数据发送到服务客户端</p>
</li>
</ul>
<h3 id="2-6-传递Binder数据的阶段6"><a href="#2-6-传递Binder数据的阶段6" class="headerlink" title="2.6 传递Binder数据的阶段6"></a>2.6 传递Binder数据的阶段6</h3><p>该阶段与服务注册阶段的第6个阶段类似。服务客户端使用IPC应答数据中的Binder节点编号，进入服务使用阶段。  </p>
<h2 id="3-服务使用阶段"><a href="#3-服务使用阶段" class="headerlink" title="3.服务使用阶段"></a>3.服务使用阶段</h2><p>在服务使用阶段，服务客户端与拥有服务的Service Server进行IPC通信。通过在服务检索阶段获得的Binder节点编号，向Service Server发送IPC数据。在服务使用阶段中，发送IPC数据的进程是服务客户端，而接收端是Service Server.  </p>
<h3 id="3-1-传递Binder数据的阶段1"><a href="#3-1-传递Binder数据的阶段1" class="headerlink" title="3.1 传递Binder数据的阶段1"></a>3.1 传递Binder数据的阶段1</h3><p>在服务使用阶段，Service Server进入待机状态，等待接收IPC数据。  </p>
<h3 id="3-2-传递Binder数据的阶段2"><a href="#3-2-传递Binder数据的阶段2" class="headerlink" title="3.2 传递Binder数据的阶段2"></a>3.2 传递Binder数据的阶段2</h3><p>在服务使用阶段中，IPC数据包含与所用服务函数相关的RPC代码与RPC数据。在服务检索传递的Binder数据的第6个阶段中已经获取了服务的Binder节点编号，IPC数据中的Handle即是该Binder节点编号。  </p>
<p>该阶段与服务注册的传递Binder数据的第2个阶段类似，但是与binder_transaction()函数查找接收端binder_proc结构体的过程有所不同。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(tr-&gt;target.handle)&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span>*<span class="title">ref</span>;</span></div><div class="line">    ref=binder_get_ref(proc,tr-&gt;target.handle);</div><div class="line">    target_node=ref-&gt;node;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    target_node=binder_context_mgr_node;</div><div class="line">&#125;</div><div class="line">target_proc=target_node-&gt;proc;</div></pre></td></tr></table></figure>
<p>在服务注册阶段，Handle值为0，查找到的是Context Manager的binder_proc结构体;而在服务使用阶段则使用target.handle,查找对应进程的binder_proc结构体。  </p>
<ul>
<li><p>调用binder_get_ref()函数，查找desc值为指定Handle的binder_ref结构体。查找到指定的结构体后，将binder_ref结构体的node指向Service Server的binder_node结构体</p>
</li>
<li><p>binder_node结构体的proc指向Service Server的binder_proc结构体，即接收IPC数据的进程</p>
</li>
</ul>
<h3 id="3-3-传递Binder数据的阶段3"><a href="#3-3-传递Binder数据的阶段3" class="headerlink" title="3.3 传递Binder数据的阶段3"></a>3.3 传递Binder数据的阶段3</h3><p>该阶段与服务注册阶段类似，但接收IPC数据的不是Context Manager，而是Service Server. Service Server调用IPC数据中RPC代码所指的函数，并将RPC数据作为参数传入该函数中。此后的过程与Binder服务注册的传递Binder数据的第4，5，6阶段相同，不再赘述。  </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/27/2016-02-27-android-binderji-zhi-fen-xi-4-parcellei-fen-xi/" rel="next" title="Android Binder机制分析(4) Parcel类分析">
                <i class="fa fa-chevron-left"></i> Android Binder机制分析(4) Parcel类分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/01/2016-03-01-android-binderji-zhi-6-bian-xie-zi-ji-de-ben-di-fu-wu/" rel="prev" title="Android Binder机制(6) 编写自己的本地服务">
                Android Binder机制(6) 编写自己的本地服务 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-服务注册"><span class="nav-number">2.</span> <span class="nav-text">1.服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-过程概览"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 过程概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-传递Binder数据的阶段1"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 传递Binder数据的阶段1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-binder-thread-read-分析"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 binder_thread_read()分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-传递Binder数据的阶段2"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 传递Binder数据的阶段2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-传递Binder数据的阶段3"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 传递Binder数据的阶段3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-传递Binder数据的阶段4"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 传递Binder数据的阶段4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-传递Binder数据的阶段6"><span class="nav-number">2.6.</span> <span class="nav-text">1.7 传递Binder数据的阶段6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-服务检索阶段"><span class="nav-number">3.</span> <span class="nav-text">2.服务检索阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-传递Binder数据的阶段1"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 传递Binder数据的阶段1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-传递Binder数据的阶段2"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 传递Binder数据的阶段2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-传递Binder数据的阶段3"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 传递Binder数据的阶段3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-传递Bindder数据的阶段4"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 传递Bindder数据的阶段4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-传递Binder数据的阶段5"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 传递Binder数据的阶段5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-传递Binder数据的阶段6"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 传递Binder数据的阶段6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-服务使用阶段"><span class="nav-number">4.</span> <span class="nav-text">3.服务使用阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-传递Binder数据的阶段1"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 传递Binder数据的阶段1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-传递Binder数据的阶段2"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 传递Binder数据的阶段2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-传递Binder数据的阶段3"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 传递Binder数据的阶段3</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
