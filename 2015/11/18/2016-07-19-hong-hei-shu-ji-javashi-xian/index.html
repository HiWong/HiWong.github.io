<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="引言红黑树（Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logN)时间">
<meta property="og:type" content="article">
<meta property="og:title" content="红黑树及Java实现">
<meta property="og:url" content="http://yoursite.com/2015/11/18/2016-07-19-hong-hei-shu-ji-javashi-xian/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="引言红黑树（Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logN)时间">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/red_black_sample.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/insert_case3.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/insert_case4.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/insert_case5.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/remove_case2.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/remove_case4.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/remove_case5.png">
<meta property="og:image" content="http://yoursite.com/images/btree/red_black/remove_case6.png">
<meta property="og:updated_time" content="2017-08-05T11:49:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="红黑树及Java实现">
<meta name="twitter:description" content="引言红黑树（Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logN)时间">
<meta name="twitter:image" content="http://yoursite.com/images/btree/red_black/red_black_sample.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2015/11/18/2016-07-19-hong-hei-shu-ji-javashi-xian/"/>





  <title>红黑树及Java实现 | Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Accueil
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/18/2016-07-19-hong-hei-shu-ji-javashi-xian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">红黑树及Java实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-18T01:19:17+08:00">
                2015-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure/" itemprop="url" rel="index">
                    <span itemprop="name">data_structure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>红黑树（Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(logN)时间内做查找，插入和删除.  </p>
<p>有人可能觉得奇怪，已经有了AVL这种查找，插入和删除都严格为O(logN)复杂度的平衡二叉树，为什么还需要红黑树呢？<a id="more"></a>  </p>
<p>其实是由于AVL为了保持严格的平衡，在插入和删除节点时需要进行大量的旋转（旋转较耗时)，从而使它不适合用于需要频繁插入和删除的场合。当然，如果建立后基本只有查找，而没有插入和删除的话，则AVL的性能是最好的。  </p>
<p>红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。由于红黑树实际上只是保持局部平衡，从而在插入和删除时不需要或者只需要进行少量的旋转即可，从而使它在实际工程中得到了大量的使用，从Linux的任务调度，到Android的Binder机制，都有红黑树的身影。本文我们就一起来揭开它的神秘面纱吧!</p>
<h3 id="1-基本性质"><a href="#1-基本性质" class="headerlink" title="1.基本性质"></a>1.基本性质</h3><p>红黑树是每个节点都带有颜色的二叉查找树，颜色为红色或黑色。红黑树需要满足以下性质:  </p>
<ul>
<li>1).节点是红色或黑色  </li>
<li>2).根是黑色  </li>
<li>3).所有叶子都是黑色（叶子是NIL节点）  </li>
<li>4)每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>5)从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。  </li>
</ul>
<p>如下是一棵典型的红黑树：  </p>
<img src="/images/btree/red_black/red_black_sample.png">
<p>这些约束确保了红黑树的关键特性:从根到叶子的最长的可能路径不多于最短路径的两倍。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。  </p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。  </p>
<p>在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”null叶子”或”空（null）叶子”，如上图所示.  </p>
<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h3><p>为了保持它的基本性质，红黑树在插入时需要考虑它和父节点的颜色，故节点定义如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED=<span class="keyword">false</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK=<span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> color;</div><div class="line">    <span class="keyword">public</span> T key;</div><div class="line">    <span class="keyword">public</span> RBNode&lt;T&gt;left;</div><div class="line">    <span class="keyword">public</span> RBNode&lt;T&gt;right;</div><div class="line">    <span class="keyword">public</span> RBNode&lt;T&gt;parent;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBNode</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBNode</span><span class="params">(T key,<span class="keyword">boolean</span> color,RBNode&lt;T&gt;left,RBNode&lt;T&gt;right,RBNode&lt;T&gt;parent)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.key=key;</div><div class="line">        <span class="keyword">this</span>.color=color;</div><div class="line">        <span class="keyword">this</span>.left=left;</div><div class="line">        <span class="keyword">this</span>.right=right;</div><div class="line">        <span class="keyword">this</span>.parent=parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>红黑树的定义如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> RBNode&lt;T&gt;root; </div><div class="line">    </div><div class="line">   <span class="keyword">private</span> RBNode&lt;T&gt;getGrandParent(RBNode&lt;T&gt;node)&#123;</div><div class="line">       <span class="keyword">return</span> node.parent.parent;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> RBNode&lt;T&gt;getUncle(RBNode&lt;T&gt;node)&#123;</div><div class="line">       <span class="keyword">if</span>(node.parent==getGrandParent(node).left)&#123;</div><div class="line">           <span class="keyword">return</span> getGrandParent(node).right;</div><div class="line">       &#125;<span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">return</span> getGrandParent(node).left;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中getGrandParent()和getUncle()会在后面用到，故这里先给出。  </p>
<h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h3><p>首先以普通二叉查找树的方法增加节点并标记它为红色(因为性质5的原因，如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。)代码如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span></span>&#123;</div><div class="line"></div><div class="line">	    RBNode&lt;T&gt;newNode;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</div><div class="line">            root=<span class="keyword">new</span> RBNode&lt;&gt;(key,RBNode.RED,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line">            newNode=root;</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        	RBNode&lt;T&gt;currentNode=root;</div><div class="line">	        <span class="keyword">int</span> result;</div><div class="line">	        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">	            result=key.compareTo(currentNode.key);</div><div class="line">	            <span class="keyword">if</span>(result&lt;<span class="number">0</span>)&#123;</div><div class="line">	                <span class="keyword">if</span>(currentNode.left==<span class="keyword">null</span>)&#123;</div><div class="line">	                    currentNode.left=<span class="keyword">new</span> RBNode&lt;&gt;(key,RBNode.RED,<span class="keyword">null</span>,<span class="keyword">null</span>,currentNode);</div><div class="line">	                    newNode=currentNode.left;</div><div class="line">	                    <span class="keyword">break</span>;</div><div class="line">	                &#125;<span class="keyword">else</span>&#123;</div><div class="line">	                    currentNode=currentNode.left;</div><div class="line">	                &#125;</div><div class="line">	            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</div><div class="line">	                <span class="keyword">if</span>(currentNode.right==<span class="keyword">null</span>)&#123;</div><div class="line">	                    currentNode.right=<span class="keyword">new</span> RBNode&lt;&gt;(key,RBNode.RED,<span class="keyword">null</span>,<span class="keyword">null</span>,currentNode);</div><div class="line">	                    newNode=currentNode.right;</div><div class="line">	                    <span class="keyword">break</span>;</div><div class="line">	                &#125;<span class="keyword">else</span>&#123;</div><div class="line">	                    currentNode=currentNode.right;</div><div class="line">	                &#125;</div><div class="line">	            &#125;<span class="keyword">else</span>&#123;</div><div class="line">	                <span class="keyword">return</span>;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//重新修正为红黑树</span></div><div class="line">        insertFix(newNode);</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>插入节点后，我们会发现:  </p>
<ul>
<li>1)性质1和性质3总是保持着;  </li>
<li>2)性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。  </li>
<li>3)性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁  </li>
</ul>
<p>在下面的示意图中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U.<br>综合起来，修正主要考虑以下情形:  </p>
<ul>
<li>1)新节点N位于根上，无父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertCase1</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(newNode.parent==<span class="keyword">null</span>)&#123;</div><div class="line">		newNode.color=RBNode.BLACK;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		insertCase2(newNode);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2)新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点,但由于新节点N是红色，通过它的每个子节点的路径中的黑色节点数不变。从而可直接返回。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertCase2</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(newNode.parent.color==RBNode.BLACK)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="comment">//it means parent.color==RBNode.RED</span></div><div class="line">		insertCase3(newNode);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3)如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）.  </li>
</ul>
<img src="/images/btree/red_black/insert_case3.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line"><span class="comment">   * pre-conditions:parent.color==RBNode.RED</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> newNode</span></div><div class="line"><span class="comment">   */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertCase3</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(getUncle(newNode)!=<span class="keyword">null</span>&amp;&amp;getUncle(newNode).color==RBNode.RED)&#123;</div><div class="line">        newNode.parent.color=RBNode.BLACK;</div><div class="line">        newNode.parent.color=RBNode.BLACK;</div><div class="line">        <span class="comment">//has uncle,so getGrandParent(newNode) will not be null</span></div><div class="line">        getGrandParent(newNode).color=RBNode.RED;</div><div class="line">        insertCase1(getGrandParent(newNode));</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="comment">//it means parent.color==RBNode.RED and getUncle(newNode).color==RBNode.BLACK if getUncle(newNode)!=null</span></div><div class="line">		insertCase4(newNode);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4)父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效.还有一种对称的情况，进行右旋转即可。  </li>
</ul>
<img src="/images/btree/red_black/insert_case4.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   * pre-conditions:parent.color==RBNode.RED and getUncle(newNode).color==RBNode.BLACK if getUncle(newNode)!=null</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> newNode</span></div><div class="line"><span class="comment">   */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertCase4</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(newNode==newNode.parent.right&amp;&amp;newNode.parent==getGrandParent(newNode).left)&#123;</div><div class="line">        newNode.parent=rotateLeft(newNode.parent);</div><div class="line">        newNode=newNode.parent.left; </div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNode==newNode.parent.left&amp;&amp;newNode.parent==getGrandParent(newNode).right)&#123;</div><div class="line">		newNode.parent=rotateRight(newNode.parent);</div><div class="line">		newNode=newNode.parent.right;</div><div class="line">	&#125;</div><div class="line">	insertCase5(newNode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>5)父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转（还有一种对称的情形，进行左旋转即可).  </li>
</ul>
<p>在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。  </p>
<img src="/images/btree/red_black/insert_case5.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   * pre-conditions:newNode.color==RBNode.RED,parent.color==RBNode.RED and getUncle(newNode).color==RBNode.BLACK if getUncle(newNode)!=null</span></div><div class="line"><span class="comment">   * <span class="doctag">@param</span> newNode</span></div><div class="line"><span class="comment">   */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertCase5</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	newNode.parent.color=RBNode.BLACK;</div><div class="line">	getGrandParent(newNode).color=RBNode.RED;</div><div class="line">	<span class="keyword">if</span>(newNode==newNode.left&amp;&amp;newNode.parent==getGrandParent(newNode).left)&#123;</div><div class="line">		getGrandParent(newNode)=rotateRight(getGrandParent(newNode));</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		getGrandParent(newNode)=rotateLeft(getGrandParent(newNode));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上，insertFix()的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFix</span><span class="params">(RBNode&lt;T&gt;newNode)</span></span>&#123;</div><div class="line">	insertCase1(newNode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h3><p>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题（为了表述方便，这里所指的儿子，为非叶子节点的儿子）。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。  </p>
<p>所以我们要考虑的只剩下只有一个孩子的节点。有以下情形需要考虑:  </p>
<ul>
<li><p>如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5;  </p>
</li>
<li><p>被删除节点是黑色而它的儿子是红色,只需要在删除后将它的孩子节点绘成黑色即可;  </p>
</li>
<li><p>需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。我们将使用下述函数找到兄弟节点：  </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> RBNode&lt;T&gt; <span class="title">getSibling</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(node==node.parent.left)&#123;</div><div class="line">		<span class="keyword">return</span> node.parent.right;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> node.parent.left;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除节点的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">	<span class="comment">//get the non-null child</span></div><div class="line">	RBNode&lt;T&gt;child=node.left!=<span class="keyword">null</span>?node.left:node.right;</div><div class="line">    </div><div class="line">    <span class="comment">//replace node with child</span></div><div class="line">    replaceNode(node,child);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(node.color==RBNode.BLACK)&#123;</div><div class="line">    	<span class="keyword">if</span>(child.color==RBNode.RED)&#123;</div><div class="line">    		child.color=RBNode.BLACK;</div><div class="line">    	&#125;<span class="keyword">else</span>&#123;</div><div class="line">    		removeCase1(child);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1)N（即上面的child)是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">*pre-conditions:node.color==RBNode.BLACK</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase1</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(node.parent==<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		removeCase2(node);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>2)S是红色。在这种情形下我们在N的父亲上做左旋转(对称的情况则需要右旋)，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。如下图所示: </li>
</ul>
<img src="/images/btree/red_black/remove_case2.png">
<p>代码如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">*pre-conditions:node.color==RBNode.BLACK and node.parent!=null</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase2</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">    RBNode&lt;T&gt;sibling=getSibling(node);</div><div class="line">    <span class="keyword">if</span>(sibling.color==RBNode.RED)&#123;</div><div class="line">    	node.parent.color=RBNode.RED;</div><div class="line">    	sibling.color=RBNode.BLACK;</div><div class="line">    	<span class="keyword">if</span>(node==node.parent.left)&#123;</div><div class="line">    		node.parent=rotateLeft(node.parent);</div><div class="line">    	&#125;<span class="keyword">else</span>&#123;</div><div class="line">    		node.parent=rotateRight(node.parent);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    removeCase3(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>3) N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase3</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">	RBNode&lt;T&gt;sibling=getSibling(node);</div><div class="line">	<span class="keyword">if</span>((node.parent.color==RBNode.BLACK)&amp;&amp;(sibling.color==BLACK)</div><div class="line">	&amp;&amp;(sibling.left.color==RBNode.BLACK)&amp;&amp;(sibling.right.color==BLACK))&#123;</div><div class="line">		sibling.color=RBNode.RED;</div><div class="line">		removeCase1(node.parent);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		removeCase4(node);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>4) S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。  </li>
</ul>
<img src="/images/btree/red_black/remove_case4.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase4</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line"></div><div class="line">   RBNode&lt;T&gt;sibling=getSibling(node);</div><div class="line">   <span class="keyword">if</span>((node.parent.color==RBNode.RED)&amp;&amp;(sibling.color==RBNode.BLACK)</div><div class="line">       &amp;&amp;(sibling.right.color==RBNode.BLACK)&amp;&amp;(sibling.right.color==RBNode.BLACK))&#123;</div><div class="line">       	  sibling.color=RBNode.RED;</div><div class="line">       	  node.parent.color=RBNode.BLACK;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    	  removeCase5(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>5)S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。  </li>
</ul>
<img src="/images/btree/red_black/remove_case5.png">
<p>代码如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase5</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">	RBNode&lt;T&gt;sibling=getSibling(node);</div><div class="line">	<span class="keyword">if</span>(sibling.color==RBNode.BLACK)&#123;</div><div class="line">		<span class="keyword">if</span>((node==node.parent.left)&amp;&amp;(sibling.right.color==RBNode.BLACK)</div><div class="line">		    &amp;&amp;(sibling.left.color==RBNode.RED))&#123;</div><div class="line">		    	sibling.color=RBNode.RED;</div><div class="line">		    	sibling.left.color=RBNode.BLACK;</div><div class="line">		    	sibling=rotateRight(sibling);</div><div class="line">		    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((node==node.parent.right)&amp;&amp;(sibling.left.color==RBNode.BLACK)</div><div class="line">		    &amp;&amp;(sibling.right.color==RBNode.RED))&#123;</div><div class="line">                sibling.color=RBNode.RED;</div><div class="line">                sibling.right.color=RBNode.BLACK;</div><div class="line">                sibling=rotateLeft(sibling);</div><div class="line">		    &#125;</div><div class="line">	&#125;</div><div class="line">	removeCase6(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>6)S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。<br>此时，如果一个路径不通过N，则有两种可能性：  </li>
<li>它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。</li>
<li>它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。<br>在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。</li>
</ul>
<img src="/images/btree/red_black/remove_case6.png">
<p>代码如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCase6</span><span class="params">(RBNode&lt;T&gt;node)</span></span>&#123;</div><div class="line">   RBNode&lt;T&gt;sibling=getSibling(node);</div><div class="line"></div><div class="line">   sibling.color=node.parent.color;</div><div class="line">   node.parent.color=RBNode.BLACK;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(node==node.parent.left)&#123;</div><div class="line">   	  sibling.right.color=RBNode.BLACK;</div><div class="line">   	  node.parent=rotateLeft(node.parent);</div><div class="line">   &#125;<span class="keyword">else</span>&#123;</div><div class="line">      sibling.left.color=RBNode.BLACK;</div><div class="line">      node.parent=rotateRight(node.parent);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/11/16/2016-07-17-shen-zhan-shu-ji-javashi-xian/" rel="next" title="伸展树及Java实现">
                <i class="fa fa-chevron-left"></i> 伸展树及Java实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/11/20/2015-11-20-creating-a-stub-authenticator/" rel="prev" title="Creating a Stub Authenticator">
                Creating a Stub Authenticator <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table Des Matières
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Ensemble
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">136</span>
                <span class="site-state-item-name">articles</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基本性质"><span class="nav-number">2.</span> <span class="nav-text">1.基本性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-定义"><span class="nav-number">3.</span> <span class="nav-text">2.定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-插入"><span class="nav-number">4.</span> <span class="nav-text">3.插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-删除"><span class="nav-number">5.</span> <span class="nav-text">4.删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-测试"><span class="nav-number">6.</span> <span class="nav-text">5.测试</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Thème -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
