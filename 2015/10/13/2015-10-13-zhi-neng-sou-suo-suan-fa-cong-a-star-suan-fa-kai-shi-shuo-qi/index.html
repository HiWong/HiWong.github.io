<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="首先解释一下状态空间搜索。状态空间搜索法就是将问题求解过程表现为从 初始状态到目标状态寻找这个路径的过程。通俗点说，就是在解一个问题时，找到一条解题的过程可以从 求解的开始到问题的结果。由于求解问题的过程中分枝有很多，主要是求解过程中求 解条件的不确定性，不完备性造成的，使得求解的路径很多这就构成了一个图，我们说这个图就是状态空 间。问题的求解实际上就是在这个图中找到一条路径可以从开始到结果。这个">
<meta property="og:type" content="article">
<meta property="og:title" content="智能搜索算法--从A*算法开始说起">
<meta property="og:url" content="http://yoursite.com/2015/10/13/2015-10-13-zhi-neng-sou-suo-suan-fa-cong-a-star-suan-fa-kai-shi-shuo-qi/index.html">
<meta property="og:site_name" content="AllenWang的个人博客">
<meta property="og:description" content="首先解释一下状态空间搜索。状态空间搜索法就是将问题求解过程表现为从 初始状态到目标状态寻找这个路径的过程。通俗点说，就是在解一个问题时，找到一条解题的过程可以从 求解的开始到问题的结果。由于求解问题的过程中分枝有很多，主要是求解过程中求 解条件的不确定性，不完备性造成的，使得求解的路径很多这就构成了一个图，我们说这个图就是状态空 间。问题的求解实际上就是在这个图中找到一条路径可以从开始到结果。这个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/A_star01.png">
<meta property="og:updated_time" content="2017-12-03T20:21:03.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="智能搜索算法--从A*算法开始说起">
<meta name="twitter:description" content="首先解释一下状态空间搜索。状态空间搜索法就是将问题求解过程表现为从 初始状态到目标状态寻找这个路径的过程。通俗点说，就是在解一个问题时，找到一条解题的过程可以从 求解的开始到问题的结果。由于求解问题的过程中分枝有很多，主要是求解过程中求 解条件的不确定性，不完备性造成的，使得求解的路径很多这就构成了一个图，我们说这个图就是状态空 间。问题的求解实际上就是在这个图中找到一条路径可以从开始到结果。这个">
<meta name="twitter:image" content="http://7xn1yt.com1.z0.glb.clouddn.com/A_star01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2015/10/13/2015-10-13-zhi-neng-sou-suo-suan-fa-cong-a-star-suan-fa-kai-shi-shuo-qi/"/>





  <title>智能搜索算法--从A*算法开始说起 | AllenWang的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AllenWang的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小楼一夜听春雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/13/2015-10-13-zhi-neng-sou-suo-suan-fa-cong-a-star-suan-fa-kai-shi-shuo-qi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AllenWang的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">智能搜索算法--从A*算法开始说起</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-13T03:13:07+08:00">
                2015-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>首先解释一下状态空间搜索。状态空间搜索法就是将问题求解过程表现为从 初始状态到目标状态寻找这个路径的过程。<br>通俗点说，就是在解一个问题时，找到一条解题的过程可以从 求解的开始到问题的结果。由于求解问题的过程中分枝有很多，主要是求解过程中求 解条件的不确定性，不完备性造成的，使得求解的路径很多这就构成了一个图，我们说这个图就是状态空 间。问题的求解实际上就是在这个图中找到一条路径可以从开始到结果。这个寻找的过程<a id="more"></a>就是状态空间搜索。<br>常用的状态空间搜索有深度优先和广度优先。广度优先是从初始状态一层一层向下找，直到找到目标 为止。深度优先是按照一定的顺序前查找完一个分支，再查找另一个分支，以至找到目标为止。<br>显然，只要目标点存在，广度优先(BFS)或深度优先(DFS)搜索算法都一定能够搜索到目标点。但是，当结点数很多时，BFS和DFS的空间复杂度和时间复杂度都变得不可接受。而它们的效率不高的一个重要原因在于没有利用任何已有的信息。而A*算法由于利用了启发信息，因而获得了较高的搜索效率。</p>
<p>我们先下个定义，如果一个估价函数可以找出最短的路径，我们称之为可采纳性。A<em>算法是一个可采纳的最好优先算法。A</em>算法的估价函数可表示为：  </p>
<pre><code>f&apos;(n) = g&apos;(n) + h&apos;(n)  
</code></pre><p>这里，f’(n)是估价函数，g’(n)是起点到节点n的最短路径值，h’(n)是n到目标的最短路经的启发值。由于这个f’(n)其实是无法预先知道的，所以我们用前面的估价函数f(n)做近似。g(n)代替g’(n)，但 g(n)&gt;=g’(n)才可（大多数情况下都是满足的，可以不用考虑），h(n)代替h’(n)，但h(n)&lt;=h’(n)才可（这一点特别的重要）。可以证明应用这样的估价函数是可以找到最短的，也就是可采纳的。我们说应用这种估价函数的最好优先算法就是A<em>算法。<br>因而实际在算法中采用的估价函数为：f(n)=g(n)+h(n)，其中g(n)为起始点到当前点的实际代价，而h(n)为当前点到目标点的启发信息，目前，在二维平面内常用的A</em>算法的启发函数h(n)有曼哈顿距离、对角线距离、欧几里德距离。也有学者采用所谓“折距”作为启发函数。但是，采用对角线距离的话会太保守，搜索效率不高，而采用曼哈顿距离或者“折距”，虽然可以提高效率，但是都不能保证满足可接纳性条件，因而不宜采用。目前用于二维平面内的A*算法普遍采用欧几里德距离。  </p>
<p>举一个例子，其实广度优先算法(BFS)就是A<em>算法的特例。其中g(n)是节点所在的层数，h(n)=0，这种h(n)肯定小于h’(n)，所以由前述可知广度优先算法是可采纳的。实际也是。当然它是一种最差的A</em>算法。  </p>
<p>通过上面的介绍，我们可以确定A*算法的流程如下(注：出自wikipedia)：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">function A*(start,goal)</div><div class="line">   closedset := the empty set    <span class="comment">// The set of nodes already evaluated.</span></div><div class="line">   openset := &#123;start&#125;    <span class="comment">// The set of tentative nodes to be evaluated, initially containing the start node</span></div><div class="line">   came_from := the empty map    <span class="comment">// The map of navigated nodes.</span></div><div class="line"></div><div class="line">   g_score[start] := <span class="number">0</span>    <span class="comment">// Cost from start along best known path.</span></div><div class="line">   <span class="comment">// Estimated total cost from start to goal through y.</span></div><div class="line">   f_score[start] := g_score[start] + heuristic_cost_estimate(start, goal)</div><div class="line">    </div><div class="line">   <span class="keyword">while</span> openset is not empty</div><div class="line">       current := the node in openset having the lowest f_score[] value</div><div class="line">       <span class="keyword">if</span> current = goal</div><div class="line">           <span class="keyword">return</span> reconstruct_path(came_from, goal)</div><div class="line">        </div><div class="line">       remove current from openset</div><div class="line">       add current to closedset</div><div class="line">       <span class="function"><span class="keyword">for</span> each neighbor in <span class="title">neighbor_nodes</span><span class="params">(current)</span></span></div><div class="line"><span class="function">           tentative_g_score :</span>= g_score[current] + dist_between(current,neighbor)</div><div class="line">           tentative_f_score := tentative_g_score + heuristic_cost_estimate(neighbor, goal)</div><div class="line">           <span class="keyword">if</span> neighbor in closedset and tentative_f_score &gt;= f_score[neighbor]</div><div class="line">                   <span class="keyword">continue</span></div><div class="line"></div><div class="line">           <span class="keyword">if</span> neighbor not in openset or tentative_f_score &lt; f_score[neighbor] </div><div class="line">               came_from[neighbor] := current</div><div class="line">               g_score[neighbor] := tentative_g_score</div><div class="line">               f_score[neighbor] := tentative_f_score</div><div class="line">               <span class="keyword">if</span> neighbor not in openset</div><div class="line">                   add neighbor to openset</div><div class="line"></div><div class="line">   <span class="keyword">return</span> failure</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function">function <span class="title">reconstruct_path</span><span class="params">(came_from, current_node)</span></span></div><div class="line"><span class="function">   <span class="keyword">if</span> current_node in came_from</span></div><div class="line"><span class="function">       p :</span>= reconstruct_path(came_from, came_from[current_node])</div><div class="line">       <span class="keyword">return</span> (p + current_node)</div><div class="line">   <span class="keyword">else</span></div><div class="line">       <span class="keyword">return</span> current_node</div></pre></td></tr></table></figure>
<p>这里必须吐槽一下度娘的A<em>算法流程是不严谨的（如果想要理解A</em>算法的同学，建议还是看英文版维基上的。当然，最好就是借一本人工智能方面的书认真看一下，可以理解得更透彻。<br>当然，上面只是最原始的A*算法。如果要获得较高的效率，还需要对其进行进一步的改进，其中目前大多数学者优化的重点都放在启发信息的改进和从Open表中更快地获取代价最小的结点。<br>其中，关于启发信息的讨论在前面已经提到过，而且由于它一般要与具体的学科问题相结合才有意义，此处不再赘述。<br>下面主要讲解如何能更快地从Open表中获取代价最小的节点。显然有两个途径：第一，根据具体的问题，预先将不符合某些约束（比如在航迹规划时，将不符合动力学约束的节点去除。或者说，我们只在符合动力学约束的空间内选择邻节点放入表中）的子节点剪除掉。<br>第二种方法就是在邻节点数无法改变的情况下，选择一种好的排序算法就至关重要了。可以选择快速排序等，目前较常用的一种高效排序算法是维持一个称为“最小堆”的数据结构，它是一种二叉树结构，其特征是对于任一结点，它的左孩子（如果有的话）和右孩子必定大于它。显然，这种排序算法的时间复杂度为O(log2N)。排好序后，每次只要将根结点移除即可。如下图所示。  </p>
<p><img src="http://7xn1yt.com1.z0.glb.clouddn.com/A_star01.png" alt="A_star01"></p>
<p>A<em>算法的理论介绍基本就这些。下面是自己写的一个利用A</em>算法寻找二维平面内任意两点间的最短路径，希望能够抛砖引玉。  </p>
<p>由于在节点的扩展过程中需要实现较多的操作，而这些操作与节点密切相关。因而，为了实现更好的封装，此处没有使用C++中的STL，而是自己实现了链表结构。  </p>
<p>首先是LisNode的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LISTNODE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTNODE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>;</span>  <span class="comment">//前向引用声明。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	ListNode(<span class="keyword">const</span> Point&amp;p);</div><div class="line">	<span class="comment">//////////////////只要有一个节点（比如起始节点）调用了下面这两个函数就行。</span></div><div class="line">	<span class="comment">//static void setStartPoint(const Point&amp;p);</span></div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEndPoint</span><span class="params">(<span class="keyword">const</span> Point&amp;p)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPlanAreaWidth</span><span class="params">(<span class="keyword">float</span> width)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPlanAreaHeight</span><span class="params">(<span class="keyword">float</span> height)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFather</span><span class="params">(ListNode*listNode)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setNext</span><span class="params">(ListNode*listNode)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">setg</span><span class="params">()</span></span>; <span class="comment">//这个是要知道它前一个节点的信息的。它是从起点到这个点所花费的实际代价。</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setg</span><span class="params">(<span class="keyword">float</span> g1)</span></span>;<span class="comment">//这个是为第一个点而设计的函数，直接设定它的g值。</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">seth</span><span class="params">()</span></span>; <span class="comment">//这个是需要知道终点信息的。它是从现在这个点到目标点的代价。</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setf</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">float</span> <span class="title">getg</span><span class="params">()</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function"><span class="keyword">float</span> <span class="title">getf</span><span class="params">()</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function">Point <span class="title">getPos</span><span class="params">()</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function">ListNode* <span class="title">getPrev</span><span class="params">()</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getNeightborNodes</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp;v)</span></span>; <span class="comment">//得到它的邻近节点。	</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isCloseEnough</span><span class="params">(<span class="keyword">float</span> r)</span><span class="keyword">const</span></span>;<span class="comment">//这个函数用于判断它是否离终点足够近。</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	Point pos;</div><div class="line">	<span class="keyword">float</span> g,h,f;</div><div class="line">	ListNode*prev;  <span class="comment">//其实，为了在prev和next这两个方面为了更好地模仿结构体，prev和next应该设置为public的。</span></div><div class="line">	ListNode*next;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">float</span> planAreaWidth;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">float</span> planAreaHeight;</div><div class="line">	<span class="keyword">static</span> Point endPoint;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>下面是ListNode的实现部分，即listNode.cpp文件：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListNode.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">80.0f</span>,<span class="number">80.0f</span>)</span></span>;</div><div class="line">Point ListNode::endPoint=p;</div><div class="line"><span class="keyword">float</span> ListNode::planAreaWidth=<span class="number">100.0f</span>;</div><div class="line"><span class="keyword">float</span> ListNode::planAreaHeight=<span class="number">100.0f</span>;</div><div class="line">ListNode::ListNode(<span class="keyword">const</span> Point&amp;p)</div><div class="line">&#123;</div><div class="line">	pos.x=p.x;</div><div class="line">	pos.y=p.y;</div><div class="line">	prev=<span class="literal">NULL</span>;</div><div class="line">	next=<span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setEndPoint(<span class="keyword">const</span> Point&amp;p)</div><div class="line">&#123;</div><div class="line">	endPoint.x=p.x;</div><div class="line">	endPoint.y=p.y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setPlanAreaWidth(<span class="keyword">float</span> widhth)</div><div class="line">&#123;</div><div class="line">	planAreaWidth=widhth;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setPlanAreaHeight(<span class="keyword">float</span> height)</div><div class="line">&#123;</div><div class="line">	planAreaHeight=height;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setFather(ListNode*listNode)</div><div class="line">&#123;</div><div class="line">	prev=listNode;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setNext(ListNode*listNode)</div><div class="line">&#123;</div><div class="line">	next=listNode;</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> ListNode::setg()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(prev==<span class="literal">NULL</span>)   <span class="comment">//其实可以把startPoint利用上，然后求解起始节点的g值的。</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">///////////////////////////////它与前一个节点的方向关系有5种可能。当然，如果不想写if语句，直接用距离公式也可以，只不过用距离公式会快一些。</span></div><div class="line">		<span class="keyword">if</span>(pos.x-prev-&gt;pos.x==<span class="number">0.0f</span>) <span class="comment">//这里包含两种情况。</span></div><div class="line">		&#123;</div><div class="line">			g=prev-&gt;g+<span class="number">1.0f</span>; <span class="comment">//实际上应该是delta，只不过这里风格间距为1.0f;</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pos.x-prev-&gt;pos.x&gt;<span class="number">0.0f</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(pos.y-prev-&gt;pos.y==<span class="number">0.0f</span>)</div><div class="line">			&#123;</div><div class="line">				g=prev-&gt;g+<span class="number">1.0f</span>;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">				<span class="comment">//g=prev-&gt;g+1.4142136f;</span></div><div class="line">				g=prev-&gt;g+<span class="number">1.414f</span>;</div><div class="line">				<span class="comment">//cout&lt;&lt;"Now g="&lt;&lt;g&lt;&lt;endl; //This is just for test.</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setg(<span class="keyword">float</span> g1)</div><div class="line">&#123;</div><div class="line">	g=g1;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::seth()</div><div class="line">&#123;</div><div class="line">	h=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos.x-endPoint.x,<span class="number">2</span>)+<span class="built_in">pow</span>(pos.y-endPoint.y,<span class="number">2</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> ListNode::setf()</div><div class="line">&#123;</div><div class="line">	f=g+h;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;pos.x&lt;&lt;<span class="string">","</span>&lt;&lt;pos.y&lt;&lt;<span class="string">") "</span>&lt;&lt;<span class="string">" f="</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">float</span> ListNode::getg()<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> g;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">float</span> ListNode::getf()<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point ListNode::getPos()<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> pos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ListNode* ListNode::getPrev()<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;prev;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个函数还不敢肯定写对了，要测试一下。另外，有一点自己还没有区分开来：那就是路线终点和规划区域终点是两回事，实际上这里要的是规划区域的终点而不是路线的终点!</span></div><div class="line"><span class="keyword">void</span> ListNode::getNeightborNodes(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp;v) <span class="comment">//注意：要传递引用才能改变实参的值。</span></div><div class="line">&#123;</div><div class="line">     <span class="comment">///////////////////////////////////注意：由于后面它算每个节点的估价值，而要求估值就要知道它的父节点，所以将所有邻节点的父节点都                  //设置成当前节点。</span></div><div class="line">     <span class="keyword">int</span> countNum=<span class="number">0</span>; <span class="comment">//countNum is just for test.</span></div><div class="line">    <span class="keyword">if</span>(pos.x+<span class="number">1.0f</span>&lt;=endPoint.x)</div><div class="line">	&#123;</div><div class="line">		<span class="function">Point <span class="title">tempPoint</span><span class="params">(pos.x+<span class="number">1.0f</span>,pos.y)</span></span>;</div><div class="line">		ListNode*tempPtr=<span class="keyword">new</span> ListNode(tempPoint); </div><div class="line">		tempPtr-&gt;prev=<span class="keyword">this</span>; <span class="comment">//This step is very important.</span></div><div class="line"></div><div class="line">		v.push_back(tempPtr);<span class="comment">//加入第三个方向的节点。</span></div><div class="line">		countNum++;</div><div class="line">		<span class="comment">//if(pos.y+1.0f&lt;=endPoint.y)</span></div><div class="line">		<span class="keyword">if</span>(pos.y+<span class="number">1.0f</span>&lt;=planAreaHeight)  <span class="comment">//注意：由于不能后退，所以x的限制条件仍然是endPoint.x，但是</span></div><div class="line">		&#123;</div><div class="line">			tempPoint.y=pos.y+<span class="number">1.0f</span>;</div><div class="line">			tempPtr=<span class="keyword">new</span> ListNode(tempPoint);  </div><div class="line">			tempPtr-&gt;prev=<span class="keyword">this</span>;</div><div class="line"></div><div class="line">			v.push_back(tempPtr);   <span class="comment">//加入第2个方向的节点。</span></div><div class="line">			countNum++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(pos.y<span class="number">-1.0f</span>&gt;=<span class="number">0.0f</span>)</div><div class="line">		&#123;</div><div class="line">			tempPoint.y=pos.y<span class="number">-1.0f</span>;</div><div class="line">			tempPtr=<span class="keyword">new</span> ListNode(tempPoint);</div><div class="line">			tempPtr-&gt;prev=<span class="keyword">this</span>;</div><div class="line"></div><div class="line">			v.push_back(tempPtr); <span class="comment">//加入第四个方向的节点</span></div><div class="line">			countNum++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">////////////////////////////////////////</span></div><div class="line">	<span class="comment">//if(pos.y+1.0f&lt;=endPoint.y)  </span></div><div class="line">	<span class="keyword">if</span>(pos.y+<span class="number">1.0f</span>&lt;=planAreaHeight)</div><div class="line">	&#123;</div><div class="line">		<span class="function">Point <span class="title">tempPoint</span><span class="params">(pos.x,pos.y+<span class="number">1.0f</span>)</span></span>;</div><div class="line">		ListNode*tempPtr=<span class="keyword">new</span> ListNode(tempPoint);</div><div class="line">		tempPtr-&gt;prev=<span class="keyword">this</span>;</div><div class="line"></div><div class="line">		v.push_back(tempPtr);  <span class="comment">//加入第一个方向（向上）的节点</span></div><div class="line">		countNum++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(pos.y<span class="number">-1.0f</span>&gt;=<span class="number">0.0f</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="function">Point <span class="title">tempPoint</span><span class="params">(pos.x,pos.y<span class="number">-1.0f</span>)</span></span>;</div><div class="line">		ListNode*tempPtr=<span class="keyword">new</span> ListNode(tempPoint);</div><div class="line">		tempPtr-&gt;prev=<span class="keyword">this</span>;</div><div class="line">		v.push_back(tempPtr);  <span class="comment">//加入第五个方向(向下)的节点</span></div><div class="line">		countNum++;		</div><div class="line">	&#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The node whose coordinates is ("</span>&lt;&lt;pos.x&lt;&lt;<span class="string">","</span>&lt;&lt;pos.y&lt;&lt;<span class="string">") has "</span>&lt;&lt;countNum&lt;&lt;<span class="string">" neighbor points."</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//This is for test.</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> ListNode::isCloseEnough(<span class="keyword">float</span> r)<span class="keyword">const</span>  <span class="comment">//这个函数用于判断它是否与终点足够接近。或者说是否在终点的大小为r的邻域内。</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">float</span> xDistance=<span class="built_in">abs</span>(pos.x-endPoint.x);</div><div class="line">	<span class="keyword">float</span> yDistance=<span class="built_in">abs</span>(pos.y-endPoint.y);</div><div class="line">	<span class="keyword">if</span>((xDistance&lt;=r)&amp;&amp;(yDistance&lt;=r))</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是链表的定义：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListNode.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	List();</div><div class="line">	~List();</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertAtBack</span><span class="params">(ListNode*pNode)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertProperly</span><span class="params">(ListNode*pNode)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isInList</span><span class="params">(ListNode*pNode,<span class="keyword">float</span>&amp;g)</span><span class="keyword">const</span></span>;</div><div class="line">	<span class="function">ListNode*<span class="title">getFromList</span><span class="params">(<span class="keyword">const</span> Point&amp;p)</span></span>;<span class="comment">//从链表中取出指定坐标的节点，然后再改变它的g和f值，注意不能改变它的prev，然后再插入Open链表中。</span></div><div class="line"></div><div class="line">	<span class="function">ListNode*<span class="title">removeBestNode</span><span class="params">()</span></span>;<span class="comment">//将f值最小的节点从链表中脱离出来，注意脱离只要解除与前后节点的关系就行，而不需要删除它，因为在后面还要用到它。	</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">exportList</span><span class="params">(<span class="keyword">char</span> dir[])</span><span class="keyword">const</span></span>; <span class="comment">//This is for test.</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	ListNode*firstPtr;</div><div class="line">	ListNode*lastPtr;	</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>下面是其实现：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"List.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">List::List()</div><div class="line">&#123;</div><div class="line">	firstPtr=<span class="literal">NULL</span>;</div><div class="line">	lastPtr=<span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">List::~List()</div><div class="line">&#123;</div><div class="line">	ListNode*tempNode01=firstPtr; <span class="comment">//注意：头结点也存放数据。</span></div><div class="line">	ListNode*tempNode02=tempNode01;</div><div class="line">	<span class="keyword">while</span>(tempNode01-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		tempNode02=tempNode01;</div><div class="line">		tempNode01=tempNode02-&gt;next;</div><div class="line">		<span class="keyword">delete</span> tempNode02;</div><div class="line">		tempNode02=<span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> List::insertAtBack(ListNode*pNode)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(isEmpty())</div><div class="line">	&#123;</div><div class="line">		firstPtr=lastPtr=pNode;</div><div class="line">		lastPtr-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		lastPtr-&gt;next=pNode;  <span class="comment">//让原来的最后一个节点的next指向pNode;</span></div><div class="line">		lastPtr=pNode;       <span class="comment">//新插入的节点成为新的最后一个节点。	</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> List::insertProperly(ListNode*pNode)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//////////////////////////只要找到第一个f值比它的f值大(&gt;=)的节点，然后插入在那个节点的前面就行。但是由于现在自己打算不在List中对ListNode中的Prev进行设置，所以这种方法操作起来不容易。还是先用原来那种方法。</span></div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	ListNode*tempNode=firstPtr;</span></div><div class="line"><span class="comment">	while((tempNode-&gt;f&lt;pNode-&gt;f)&amp;&amp;tempNode-&gt;next!=NULL)</span></div><div class="line"><span class="comment">	&#123;</span></div><div class="line"><span class="comment">		tempNode=tempNode-&gt;next;</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	*/</span></div><div class="line">	<span class="keyword">if</span>(isEmpty())</div><div class="line">		insertAtBack(pNode);</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(pNode-&gt;f&lt;=firstPtr-&gt;f)</div><div class="line">		&#123;</div><div class="line">			pNode-&gt;next=firstPtr;</div><div class="line">			firstPtr=pNode;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;f&gt;=lastPtr-&gt;f)</div><div class="line">		&#123;</div><div class="line">			lastPtr-&gt;next=pNode;</div><div class="line">			lastPtr=pNode;</div><div class="line">			lastPtr-&gt;next=<span class="literal">NULL</span>; 		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			ListNode*tempPtr=firstPtr;</div><div class="line">			<span class="keyword">while</span>(tempPtr-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>((tempPtr-&gt;f&lt;=pNode-&gt;f)&amp;&amp;(tempPtr-&gt;next-&gt;f&gt;=pNode-&gt;f))</div><div class="line">				&#123;</div><div class="line">					pNode-&gt;next=tempPtr-&gt;next;</div><div class="line">					tempPtr-&gt;next=pNode;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				tempPtr=tempPtr-&gt;next;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> List::isEmpty()<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> firstPtr==<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> List::isInList(ListNode*pNode,<span class="keyword">float</span> &amp;g)<span class="keyword">const</span> <span class="comment">//如果这个点已经在OpenList中的话，将该点的g值赋给g（因为是同一点，h值必然相同，所以比较f和比较g是一样的。）</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">////////////////////////////////////只要判断这个点的坐标在OpenList或者ClosedList中能不能找到相同的就行。</span></div><div class="line">	<span class="keyword">if</span>(!isEmpty())<span class="comment">//首先要不为空才可以继续下面的查找判断</span></div><div class="line">	&#123;</div><div class="line">		ListNode*tempPtr=firstPtr;</div><div class="line">		<span class="keyword">while</span>(tempPtr-&gt;next!=<span class="literal">NULL</span>)   <span class="comment">//这种查找方法用的是最古老的查找方法，其实对于排好了序的链表，可以用二分查找的，以后要改进这个。</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>((tempPtr-&gt;pos.x==pNode-&gt;pos.x)&amp;&amp;(tempPtr-&gt;pos.y==pNode-&gt;pos.y))</div><div class="line">			&#123;</div><div class="line">				g=tempPtr-&gt;g;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">			tempPtr=tempPtr-&gt;next;  <span class="comment">//千万别忘了这句。</span></div><div class="line">		&#125;</div><div class="line">   &#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">ListNode* List::getFromList(<span class="keyword">const</span> Point&amp;p)  <span class="comment">//取出坐标点与p相同的节点并从链表中移出。注意：一定要保证这个坐标点在链表中的基础上才能使用这个函数，否则会出错。</span></div><div class="line">&#123;</div><div class="line">	ListNode*tempPtr=firstPtr;</div><div class="line">	<span class="keyword">int</span> countNum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(tempPtr-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		countNum++;</div><div class="line">		<span class="keyword">if</span>((tempPtr-&gt;pos.x==p.x)&amp;&amp;(tempPtr-&gt;pos.y==p.y))</div><div class="line">		&#123;</div><div class="line">		<span class="comment">///////////////////////要先解除链接关系。</span></div><div class="line">			<span class="keyword">break</span>;		</div><div class="line">		&#125;</div><div class="line">		tempPtr=tempPtr-&gt;next;</div><div class="line">	&#125;</div><div class="line">	ListNode*tempPtr02=firstPtr;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;countNum<span class="number">-1</span>;++i)<span class="comment">//要找到那个等坐标节点的前一个节点以解除链接关系。</span></div><div class="line">	&#123;</div><div class="line">		tempPtr02=tempPtr02-&gt;next;</div><div class="line">	&#125;</div><div class="line">	tempPtr02-&gt;next=tempPtr-&gt;next;</div><div class="line">	tempPtr-&gt;next=<span class="literal">NULL</span>; <span class="comment">//为了彻底解除链接关系，将要移出的这个节点的next设置为NULL;</span></div><div class="line">	<span class="keyword">return</span> tempPtr; <span class="comment">//不需要用break，因为函数遇到return就会返回。</span></div><div class="line">&#125;</div><div class="line">ListNode* List::removeBestNode()</div><div class="line">&#123;</div><div class="line">	ListNode*tempPtr=firstPtr;</div><div class="line">	firstPtr=tempPtr-&gt;next;</div><div class="line">	tempPtr-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">return</span> tempPtr;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> List::exportList(<span class="keyword">char</span> dir[])<span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(firstPtr!=<span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		ListNode*tempPtr=firstPtr;</div><div class="line">		ofstream outData;</div><div class="line">		outData.open(dir);</div><div class="line">		<span class="keyword">while</span>(tempPtr-&gt;next!=<span class="literal">NULL</span>)</div><div class="line">		&#123;</div><div class="line">			outData&lt;&lt;<span class="string">"("</span>&lt;&lt;tempPtr-&gt;pos.x&lt;&lt;<span class="string">","</span>&lt;&lt;tempPtr-&gt;pos.y&lt;&lt;<span class="string">") "</span>&lt;&lt;<span class="string">"f="</span>&lt;&lt;tempPtr-&gt;f&lt;&lt;<span class="string">" g="</span>&lt;&lt;tempPtr-&gt;g&lt;&lt;<span class="string">" h="</span>&lt;&lt;tempPtr-&gt;h&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			tempPtr=tempPtr-&gt;next;</div><div class="line">		&#125;</div><div class="line">		outData.close();</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是main函数，它与上面介绍的A*算法几乎一样，只是自己作了一点小的改进：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"List.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	<span class="function">Point <span class="title">startPoint</span><span class="params">(<span class="number">10.0f</span>,<span class="number">60.0f</span>)</span></span>;</div><div class="line">	<span class="function">Point <span class="title">endPoint</span><span class="params">(<span class="number">100.0f</span>,<span class="number">59.0f</span>)</span></span>;   <span class="comment">//现在这个算法有一个缺陷就是只能计算终点横纵坐标相等的情形，这点必须改进。</span></div><div class="line">	<span class="keyword">float</span> width=<span class="number">200.0f</span>;</div><div class="line">	<span class="keyword">float</span> height=<span class="number">200.0f</span>;</div><div class="line">	ListNode*startNode=<span class="keyword">new</span> ListNode(startPoint);</div><div class="line">	<span class="comment">////////////////////////它是第一个节点，所以要它来调用static函数以设置类的static变量（起点和终点)</span></div><div class="line">	<span class="comment">//startNode-&gt;setStartPoint(startPoint);</span></div><div class="line">	startNode-&gt;setEndPoint(endPoint);</div><div class="line">	startNode-&gt;setPlanAreaWidth(width);</div><div class="line">	startNode-&gt;setPlanAreaHeight(height);</div><div class="line">	<span class="comment">/////////////////////</span></div><div class="line">	startNode-&gt;setg(<span class="number">0.0f</span>);</div><div class="line">	startNode-&gt;seth();</div><div class="line">	startNode-&gt;setf();</div><div class="line">	<span class="comment">//////////////////////////////</span></div><div class="line">	List OpenList;<span class="comment">//注意：要写成List OpenList而不是List OpenList()</span></div><div class="line">	List ClosedList;</div><div class="line">	<span class="comment">/////////////////////////////</span></div><div class="line">	OpenList.insertAtBack(startNode);</div><div class="line">	<span class="comment">////////////////////////</span></div><div class="line">	<span class="keyword">int</span> countNum=<span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(!OpenList.isEmpty())</div><div class="line">	&#123;</div><div class="line">		countNum++; <span class="comment">//输出文件号。</span></div><div class="line">		ListNode*currentNode=OpenList.removeBestNode();</div><div class="line">		<span class="keyword">if</span>(currentNode-&gt;isCloseEnough(<span class="number">0.1f</span>))  <span class="comment">//说明它离终点足够近，可以停止规划了。</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Congratulations! A Star Algorithm has succeeded!"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"And the path info is as follows:"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			ListNode*tempPtr=currentNode;</div><div class="line">			<span class="keyword">while</span>(tempPtr!=<span class="literal">NULL</span>) <span class="comment">//注意要写成tempPtr!=NULL而不是tempPtr-&gt;getPrev()!否则无法遍历到路径的第一个节点。</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">float</span> x=tempPtr-&gt;getPos().x;</div><div class="line">				<span class="keyword">float</span> y=tempPtr-&gt;getPos().y;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x&lt;&lt;<span class="string">","</span>&lt;&lt;y&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				tempPtr=tempPtr-&gt;getPrev();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//cout&lt;&lt;"("&lt;&lt;startPoint.x&lt;&lt;","&lt;&lt;startPoint.y&lt;&lt;")"&lt;&lt;endl;</span></div><div class="line"></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></div><div class="line">		<span class="built_in">vector</span>&lt;ListNode*&gt;v;</div><div class="line">		currentNode-&gt;getNeightborNodes(v);</div><div class="line">		<span class="built_in">vector</span>&lt;ListNode*&gt;::iterator iter;</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line"><span class="comment">	    //////////////////////////////////为了测试工作情况，把OpenList中的所有元素输出到文件中。By the way,this is for tes.</span></div><div class="line"><span class="comment">		char dir[20];</span></div><div class="line"><span class="comment">		sprintf(dir,"OpenList%d.txt",countNum);</span></div><div class="line"><span class="comment">		OpenList.exportList(dir);*/</span></div><div class="line"></div><div class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(iter=v.begin();iter!=v.end();++iter)</div><div class="line">		&#123;</div><div class="line">			v[i]-&gt;setg();</div><div class="line">			v[i]-&gt;seth();</div><div class="line">			v[i]-&gt;setf();</div><div class="line">			<span class="comment">/////////////////////////////////在求得g,h,f后，要取消父子连接吗？要!</span></div><div class="line">			v[i]-&gt;setFather(<span class="literal">NULL</span>);</div><div class="line">			<span class="keyword">float</span> tempg=<span class="number">-1.0f</span>;</div><div class="line">			<span class="keyword">if</span>(OpenList.isInList(v[i],tempg))</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(v[i]-&gt;getg()&lt;tempg)</div><div class="line">				&#123;</div><div class="line">					v[i]-&gt;setFather(currentNode);</div><div class="line">					ListNode*tempPtr=OpenList.getFromList(v[i]-&gt;getPos());	</div><div class="line">					<span class="comment">//OpenList.insertProperly(tempPtr);</span></div><div class="line">					OpenList.insertProperly(v[i]);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">					<span class="keyword">delete</span> v[i];  <span class="comment">//这样做会不会引起v的变化，还要先测试一下。</span></div><div class="line">					v[i]=<span class="literal">NULL</span>;  <span class="comment">//删除没有插入OpenList的邻节点，以防内存泄漏。</span></div><div class="line"></div><div class="line">				&#125;</div><div class="line">				</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="comment">///////////////////////////////////////////////////////////////////////</span></div><div class="line">			<span class="comment">//float tempg=-1.0f; //上面已经定义过了</span></div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ClosedList.isInList(v[i],tempg))   <span class="comment">//初步怀疑是因为下面的这个操作而导致出错。</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">delete</span> v[i];</div><div class="line">				v[i]=<span class="literal">NULL</span>; </div><div class="line">				++i; <span class="comment">//由于此时不会执行到下面，所以要在这里让i自加!</span></div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line">			<span class="comment">//if((!OpenList.isInList(v[i],tempg))&amp;&amp;(!ClosedList.isInList(v[i],tempg)))</span></div><div class="line">			<span class="keyword">else</span>  <span class="comment">//一个节点只有这三种可能：要么在OpenList中，要么在ClosedList中，要么都不在。</span></div><div class="line">			&#123;</div><div class="line">				v[i]-&gt;setFather(currentNode);</div><div class="line">				OpenList.insertProperly(v[i]);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		</div><div class="line">			++i;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		v.clear();</div><div class="line">		ClosedList.insertAtBack(currentNode);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"End of pathplaning!"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/13/2015-10-13-bo-ke-ban-jia-shuo-ming/" rel="next" title="博客搬家说明">
                <i class="fa fa-chevron-left"></i> 博客搬家说明
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/13/2015-10-13-li-zi-qun-suan-fa-yuan-li-ji-c-plus-plus-dai-ma-shi-li/" rel="prev" title="粒子群算法原理及C++代码实例">
                粒子群算法原理及C++代码实例 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Allen Wang" />
          <p class="site-author-name" itemprop="name">Allen Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">144</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
